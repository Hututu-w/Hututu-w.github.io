<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小结</title>
    <link href="/2022/02/10/%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/02/10/%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="encryptionparameters类">1.EncryptionParameters类</h1><ul><li>set_poly_modulus_degree()：设置多项式模数</li><li>set_coeff_modulus()：设置密文模数</li><li>set_plain_modulus()：设置明文模数</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//BFV</span><br>EncryptionParameters parms(scheme_type::bfv);<br><br>size_t poly_modulus_degree = <span class="hljs-number">4096</span>;<br>parms.set<span class="hljs-constructor">_poly_modulus_degree(<span class="hljs-params">poly_modulus_degree</span>)</span>;<br>parms.set<span class="hljs-constructor">_coeff_modulus(CoeffModulus::BFVDefault(<span class="hljs-params">poly_modulus_degree</span>)</span>);<br>parms.set<span class="hljs-constructor">_plain_modulus(1024)</span>;<br><span class="hljs-comment">//parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20));</span><br><br><span class="hljs-comment">//CKKS</span><br>EncryptionParameters parms(scheme_type::ckks);<br><br>size_t poly_modulus_degree = <span class="hljs-number">8192</span>;<br>parms.set<span class="hljs-constructor">_poly_modulus_degree(<span class="hljs-params">poly_modulus_degree</span>)</span>;<br>parms.set<span class="hljs-constructor">_coeff_modulus(CoeffModulus::Create(<span class="hljs-params">poly_modulus_degree</span>,&#123;60,40,40,60&#125;)</span>);<br><br>double scale = pow(<span class="hljs-number">2.0</span>,<span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><p>创建context <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">SEALContext context(parms);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    判断Encoder标志是否开启</span><br><span class="hljs-comment">*/</span><br>auto qualifiers = context.first_context_data<span class="hljs-function"><span class="hljs-params">()</span>-&gt;</span>qualifiers();<br></code></pre></td></tr></table></figure></p><h1 id="keygenerator类">2.KeyGenerator类</h1><ul><li>secret_key()：生成私钥</li><li>create_public_key()：生成公钥</li><li>create_relin_keys()：生成重新线性化密钥</li><li>create_galois_keys()：生成galois密钥</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">KeyGenerator keygen(context)<span class="hljs-comment">;</span><br><br>auto secret_key = keygen.secret_key()<span class="hljs-comment">;</span><br>PublicKey public_key<span class="hljs-comment">;</span><br>keygen.create_public_key(public_key)<span class="hljs-comment">;</span><br>RelinKeys relin_keys<span class="hljs-comment">;</span><br>keygen.create_relin_keys(relin_keys)<span class="hljs-comment">;</span><br>GaloisKeys gal_keys<span class="hljs-comment">;</span><br>keygen.create_galois_keys(gal_keys)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="batchencoderckksencoder类">3.BatchEncoder/CKKSEncoder类</h1><p>(1)BatchEncoder</p><ul><li>slot_count()</li><li>encode()：编码</li><li>decode()：解码</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BatchEncoder</span> batch_encoder(context);<br><br><span class="hljs-attribute">size_t</span> slot_count = batch_encoder.slot_count();<br><span class="hljs-attribute">size_t</span> row_size = slot_count / <span class="hljs-number">2</span>;<br><br><span class="hljs-attribute">vector</span>&lt;uint<span class="hljs-number">64</span>_t&gt; pod_matrix(slot_count, <span class="hljs-number">0</span>ULL);<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size] = <span class="hljs-number">4</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size + <span class="hljs-number">1</span>] = <span class="hljs-number">5</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size + <span class="hljs-number">2</span>] = <span class="hljs-number">6</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size + <span class="hljs-number">3</span>] = <span class="hljs-number">7</span>ULL;<br><br><span class="hljs-attribute">Plaintext</span> plain_matrix;<br><span class="hljs-attribute">batch_encoder</span>.encode(pod_matrix, plain_matrix);<br><br><span class="hljs-attribute">vector</span>&lt;uint<span class="hljs-number">64</span>_t&gt; pod_result;<br><span class="hljs-attribute">batch_encoder</span>.decode(plain_matrix, pod_result);<br></code></pre></td></tr></table></figure><p>(2)CKKSEncoder</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CKKSEncoder</span> encoder(context);<br><br><span class="hljs-attribute">size_t</span> slot_count = encoder.slot_count();<br><span class="hljs-attribute">vector</span>&lt;double&gt; input&#123; <span class="hljs-number">0</span>.<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.<span class="hljs-number">1</span>, <span class="hljs-number">2</span>.<span class="hljs-number">2</span>, <span class="hljs-number">3</span>.<span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-attribute">Plaintext</span> plain;<br><span class="hljs-attribute">double</span> scale = pow(<span class="hljs-number">2</span>.<span class="hljs-number">0</span>, <span class="hljs-number">30</span>);<br><span class="hljs-attribute">encoder</span>.encode(input, scale, plain);<br><br><span class="hljs-attribute">vector</span>&lt;double&gt; output;<br><span class="hljs-attribute">encoder</span>.decode(plain, output);<br></code></pre></td></tr></table></figure><h1 id="encryptorevaluatordecryptor类">4.Encryptor/Evaluator/Decryptor类</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">(context,public_key)</span></span>;<br><span class="hljs-function">Evaluator <span class="hljs-title">evaluator</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-function">Decryptor <span class="hljs-title">decryptor</span><span class="hljs-params">(context,secret_key)</span></span>;<br></code></pre></td></tr></table></figure><p>(1)Encryptor</p><ul><li>encrypt()</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">encryptor.encrypt(plain, <span class="hljs-keyword">encrypted</span>);<br></code></pre></td></tr></table></figure><p>(2)Evaluator</p><ul><li>square_inplace()：平方</li><li>square()</li><li>relinearize_inplace()：重新线性化</li><li>rescale_to_next_inplace()：rescale</li><li>mod_switch_to_next_inplace()：切换到下一个level</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">evaluator.square_inplace(<span class="hljs-keyword">encrypted</span>);<br>evaluator.relinearize_inplace(<span class="hljs-keyword">encrypted</span>, relin_keys);<br><br>evaluator.square(x1_encrypted, x3_encrypted);<br>evaluator.relinearize_inplace(x3_encrypted, relin_keys);<br><br>evaluator.mod_switch_to_next_inplace(<span class="hljs-keyword">encrypted</span>);<br></code></pre></td></tr></table></figure><p>(3)Decryptor</p><ul><li>decrypt()</li><li>invariant_noise_budget()：可用噪声预算</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">decryptor.decrypt(<span class="hljs-keyword">encrypted</span>, plain);<br><br>decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>)<br></code></pre></td></tr></table></figure><h1 id="saveload">5.save()/load()</h1><p>使用save()函数将密文存入指定文件；<br> 使用load()函数从指定文件载入密文。<br></p><p>(密钥同理)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> saveCiphertext(Ciphertext <span class="hljs-keyword">encrypted</span>, string filename)&#123;<br>  ofstream ct;<br>  ct.<span class="hljs-keyword">open</span>(filename, ios::binary);<br>  <span class="hljs-keyword">encrypted</span>.save(ct);<br>&#125;;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">  If you can&#x27;t / don&#x27;t want / don&#x27;t need to verify the encryption parameters</span><br><span class="hljs-comment">*/</span><br>Ciphertext unsafe_loadCiphertext(string filename)&#123;<br><br>  ifstream ct;<br>  ct.<span class="hljs-keyword">open</span>(filename, ios::binary);<br>  Ciphertext result;<br>  result.unsafe_load(context);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Verifying encryption parameters</span><br><span class="hljs-comment">*/</span><br>Ciphertext loadCiphertext(string filename, EncryptionParameters parms)&#123;<br><br>  auto context = SEALContext::<span class="hljs-keyword">Create</span>(parms);<br><br>  ifstream ct;<br>  ct.<span class="hljs-keyword">open</span>(filename, ios::binary);<br>  Ciphertext result;<br>  result.<span class="hljs-keyword">load</span>(context, ct);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEAL</tag>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6_serialization</title>
    <link href="/2022/02/09/6_serialization/"/>
    <url>/2022/02/09/6_serialization/</url>
    
    <content type="html"><![CDATA[<p>在本例中，展示了SEAL的serialization操作。同时提出了一些重要的概念，使用户在外包计算通信密文和密钥时能够优化数据大小。与前面的示例不同，为了最大限度地清晰，我们将此示例组织为客户-服务器类型。<strong>服务器选择加密参数，客户端生成密钥，服务器进行加密计算，客户端解密。</strong><br></p><p>本例要求ZLIB或Zstandard支持</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (!defined(SEAL_USE_ZSTD) &amp;&amp; !defined(SEAL_USE_ZLIB))</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Neither ZLIB nor Zstandard support is enabled; this example is not available.&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br></code></pre></td></tr></table></figure><p>类Serializzable&lt;T&gt;是一个包装器类，可以包装任意可序列化的类，包括：</p><ul><li>加密参数</li><li>模数</li><li>明文和密文</li><li>私钥、公钥、重新线性化密钥和Galois密钥</li></ul><p>Serializzable&lt;T&gt;通过将调用转到类型T的包装对象的对应函数，来提供序列化包装对象所需的最小函数功能。这需要SEAL中的对象包含两部分，其中一部分是独立于另一部分的伪随机数据。在实际使用之前，伪随机部分可以作为种子存储。我们将调用具有属性"seedable"的对象。<br></p><p>例如，Galois密钥的大小通常很大，但实际上一半的数据都是伪随机的，可以作为种子存储。因为Galois密钥的生成方不会使用它，在反序列化时扩展种子是有意义的。另一方面，我们不能允许用户使用未扩展的Galois密钥，这是通过将其包装为Serializable&lt;GaloisKeys&gt;并只能够被序列化来保证的。<br></p><p>只用一些SEAL对象是具有"seedable"的。包括：</p><ul><li>公钥、重新线性化密钥和Galois密钥</li><li>私钥模式下的密文(Encryptor::encrypt_symmetric或Encryptor::encrypt_zero_symmetric)</li></ul><p>公钥模式下的密文是不具有"seedable"的。因此当公钥不必需时，使用私钥模式的SEAL可能更有好处。<br></p><p>输出Serializable&lt;T&gt;的函数：</p><ul><li>Encryptor::encrypt(和variants)输出Serializable&lt;Ciphertext&gt;</li><li>KeyGenerator::create_...输出不同密钥类型的Serializable&lt;T&gt;</li></ul><p>注意Encryptor::encrypt包含在上述列表中，它在公钥模式下生成的密文也不具有"seedable"。这是为了保证API中公钥和私钥加密的一致性。输出Serializable&lt;T&gt;对象的函数也有以类型T的普通对象作为目标参数的重载。这些重载。这些重载对于不需要序列化且需要在构造点使用对象的本地测试来说很方便。这样的对象不能再被转换回种子状态。<br></p><p>为了模拟客户-服务器交互，我们设置了一个共享的c++流。在实际的用例中，这可以是网络缓冲区、文件流或任何共享资源。<br></p><p>需要注意的是，SEAL序列化的所有数据都是二进制格式的，因此将数据打印为ASCII字符是没有意义的。像Base64这样的编码会增加数据的大小，这已经是同态加密的瓶颈。因此，不支持或建议将序列化为文本。<br></p><p>文件流序列化需要ios::binary标志来表示被序列化的数据是二进制数据而不是文本。例如，一个适当的输出文件流可以设置为:<code>ofstream ofs("filename",ios::binary);</code><br></p><p>在本例中，使用std::stringstream，不需要ios::binary标志。注意std::stringstream的默认构造使用ios::in|ios::out打开流，因此读或写都是支持的。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">stringstream parms_stream<span class="hljs-comment">;</span><br>stringstream data_stream<span class="hljs-comment">;</span><br>stringstream sk_stream<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>服务器首先决定计算并设置解密参数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EncryptionParameters</span> parms(scheme_type::ckks);<br><span class="hljs-attribute">size_t</span> poly_modulus_degree = <span class="hljs-number">8192</span>;<br><span class="hljs-attribute">parms</span>.set_poly_modulus_degree(poly_modulus_degree);<br><span class="hljs-attribute">parms</span>.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span> &#125;));<br></code></pre></td></tr></table></figure><p>使用EncryptionParameters::save函数对共享流的加密参数的序列化是非常简单的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span> size = parms.<span class="hljs-built_in">save</span>(parms_stream);<br></code></pre></td></tr></table></figure><p>该函数的返回值是写入流中数据的实际字节数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;EncryptionParameters: wrote &quot;</span> &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>在序列化时，可以通过提供EncryptionParameters::save以所需的压缩模式启用或禁用压缩，如下示例所示:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">auto <span class="hljs-built_in">size</span> = parms.<span class="hljs-keyword">save</span>(shared_stream, compr_mode_type::<span class="hljs-keyword">none</span>);<br>auto <span class="hljs-built_in">size</span> = parms.<span class="hljs-keyword">save</span>(shared_stream, compr_mode_type::zlib);<br>auto <span class="hljs-built_in">size</span> = parms.<span class="hljs-keyword">save</span>(shared_stream, compr_mode_type::zstd);<br></code></pre></td></tr></table></figure><p>如果SEAL是由Zstandard或ZLIB支持下压缩的，默认使用其中之一。如果可行，Zstandard更优于ZLIB。<br></p><p>压缩可以对序列化的数据大小产生重大影响，因为密文和关键数据由许多对模coeff_modulus素数的均匀随机整数组成。当使用CKKS时，coeff_modulus中的素数与用于在内部存储密文和关键数据的64位字相比，可以相对较小。序列化项目标缓冲区或流中写入64位字，高字节可能留下许多0字节。去掉这些0的一种方便的方法是对加密的数据应用通用压缩算法。当使用带有小素数的CKKS时，压缩率可以是显著的(高达50-60%)。<br></p><p>也可以直接将数据序列化到缓冲区中。为此，需要知道所需缓冲区大小的上限，可以使用EncryptionParameters::save_size函数获取。此函数也接受所需的压缩模式，或者使用默认选项。<br></p><p>EncryptionParameters::save_size的输出如下：</p><ul><li>compr_mode_type::none所需的精确缓冲区大小</li><li>compr_mode_type::zlib或compr_mode_type::zstd所需大小的上限</li></ul><p>从输出中可以看到，这些函数返回的大小要比一开始写入共享流中的压缩数据大小更大。压缩在数据大小上产生了显著的改善，但是，不可能提前知道压缩数据的确切大小。如果不使用压缩，则大小完全由加密参数决定。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;EncryptionParameters: data size upper bound (compr_mode_type::none): &quot;</span><br>     &lt;&lt; parms.save<span class="hljs-constructor">_size(<span class="hljs-params">compr_mode_type</span>::<span class="hljs-params">none</span>)</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;             &quot;</span><br>     &lt;&lt; <span class="hljs-string">&quot;EncryptionParameters: data size upper bound (compression): &quot;</span><br>     &lt;&lt; parms.save<span class="hljs-constructor">_size(<span class="hljs-operator">/</span><span class="hljs-operator">*</span> Serialization::<span class="hljs-params">compr_mode_default</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span>)</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7f2bvr0fj317i05w457.jpg" /></p><p>将加密参数序列化到一个固定大小的缓冲区</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">vector&lt;seal_byte&gt; <span class="hljs-title">byte_buffer</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(parms.save_size()))</span></span>;<br>parms.<span class="hljs-built_in">save</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;seal_byte *&gt;(byte_buffer.<span class="hljs-built_in">data</span>()), byte_buffer.<span class="hljs-built_in">size</span>());<br></code></pre></td></tr></table></figure><p>为了说明反序列化，将加密参数从缓冲区加载回EncryptionParameters的另一个实例中。注意这种情况下，EncryptionParameters::load要求缓冲区大小比压缩参数的实际数据大小更大。序列化格式包括数据的真实大小，缓冲区的大小仅用于健全性检查。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">EncryptionParameters parms2;<br>parms2.<span class="hljs-built_in">load</span>(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> seal_byte *&gt;(byte_buffer.<span class="hljs-built_in">data</span>()), byte_buffer.<span class="hljs-built_in">size</span>());<br></code></pre></td></tr></table></figure><p>我们可以检查保存和加载的加密参数是否确实匹配。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">print_line(__LINE__)<span class="hljs-comment">;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;EncryptionParameters: parms == parms2: &quot;</span> &lt;&lt; boolalpha &lt;&lt; (parms == parms2) &lt;&lt; endl<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7flqt8atj315h058wlc.jpg" /></p><p>这里提供和使用的函数适用于所有具有序列化意义的SEAL对象。但是重要的是要了解更高级的技术，这些技术可用于进一步压缩数据大小。下面将介绍这些技术。<br></p><p>客户加载加密参数，设置SEALContext并创建所需的密钥</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">EncryptionParameters parms;<br>parms.load(parms_stream);<br><br><span class="hljs-comment">//我们将使用相同的流重复读取参数</span><br>parms_stream.seekg(<span class="hljs-number">0</span>, parms_stream.beg);<br><br>SEALContext context(parms);<br><br>KeyGenerator keygen(context);<br>auto sk = keygen.secret<span class="hljs-constructor">_key()</span>;<br>PublicKey pk;<br>keygen.create<span class="hljs-constructor">_public_key(<span class="hljs-params">pk</span>)</span>;<br><br><span class="hljs-comment">//我们需要保存私钥来后续解密</span><br>sk.save(sk_stream);<br><br><span class="hljs-comment">//正如本例开始所讨论的，密文可以在私钥模式下以种子状态创建，这大大减少了序列化后的数据大小。为此，我们需要在Encryptor的构造函数中为其提供私钥，或者稍后使用Encryptor::set_secret_key函数，并使用Encryptor::encrypt_symmetric函数进行加密。</span><br>encryptor.set<span class="hljs-constructor">_secret_key(<span class="hljs-params">sk</span>)</span>;<br>auto size_sym_encrypted2 = encryptor.encrypt<span class="hljs-constructor">_symmetric(<span class="hljs-params">plain2</span>)</span>.save(data_stream);<br></code></pre></td></tr></table></figure><p>大小大幅约简</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Serializable&lt;Ciphertext&gt; (public-key): wrote &quot;</span> &lt;&lt; size_encrypted1 &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;             &quot;</span><br>     &lt;&lt; <span class="hljs-string">&quot;Serializable&lt;Ciphertext&gt; (seeded secret-key): wrote &quot;</span> &lt;&lt; size_sym_encrypted2 &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7fyzzohbj315d02h0vq.jpg" /></p><p>服务器在加密数据上进行计算。重新创建SEALContext并设置评估器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    EncryptionParameters parms;<br>    parms.load(parms_stream);<br>    parms_stream.seekg(<span class="hljs-number">0</span>, parms_stream.beg);<br>    SEALContext context(parms);<br><br>    Evaluator evaluator(context);<br><br>    <span class="hljs-comment">//从data_stream中载入重新线性化密钥和密文</span><br>    RelinKeys rlk;<br>    Ciphertext encrypted1, encrypted2;<br><br>    <span class="hljs-comment">//反序列化</span><br>    rlk.load(context, data_stream);<br>    encrypted1.load(context, data_stream);<br>    encrypted2.load(context, data_stream);     <br><br>    <span class="hljs-comment">//计算乘积、rescale和重新线性化</span><br>    Ciphertext encrypted_prod;<br>    evaluator.multiply(encrypted1, encrypted2, encrypted_prod);<br>    evaluator.relinearize<span class="hljs-constructor">_inplace(<span class="hljs-params">encrypted_prod</span>, <span class="hljs-params">rlk</span>)</span>;<br>    evaluator.rescale<span class="hljs-constructor">_to_next_inplace(<span class="hljs-params">encrypted_prod</span>)</span>;<br><br>    <span class="hljs-comment">//使用data_stream将encrypted_prod发送回客户端。encrypted_prod无法存储为种子对象：只有新加密的私钥密文可以作为种子。注意结果密文的大小比新加密密文的大小更小，因为rescale操作使得它为欸与更低level</span><br>    data_stream.seekp(<span class="hljs-number">0</span>, parms_stream.beg);<br>    data_stream.seekg(<span class="hljs-number">0</span>, parms_stream.beg);<br>    auto size_encrypted_prod = encrypted_prod.save(data_stream);<br><br>    print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Ciphertext (secret-key): wrote &quot;</span> &lt;&lt; size_encrypted_prod &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; endl;<br>&#125;        <br></code></pre></td></tr></table></figure><p>最后客户解密结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">EncryptionParameters parms;<br>parms.<span class="hljs-built_in">load</span>(parms_stream);<br>parms_stream.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, parms_stream.beg);<br><span class="hljs-function">SEALContext <span class="hljs-title">context</span><span class="hljs-params">(parms)</span></span>;<br><br><span class="hljs-comment">//从sk_stream载入私钥</span><br>SecretKey sk;<br>sk.<span class="hljs-built_in">load</span>(context, sk_stream);<br><span class="hljs-function">Decryptor <span class="hljs-title">decryptor</span><span class="hljs-params">(context, sk)</span></span>;<br><span class="hljs-function">CKKSEncoder <span class="hljs-title">encoder</span><span class="hljs-params">(context)</span></span>;<br><br>Ciphertext encrypted_result;<br>encrypted_result.<span class="hljs-built_in">load</span>(context, data_stream);<br><br>Plaintext plain_result;<br>decryptor.<span class="hljs-built_in">decrypt</span>(encrypted_result, plain_result);<br>vector&lt;<span class="hljs-keyword">double</span>&gt; result;<br>encoder.<span class="hljs-built_in">decode</span>(plain_result, result);<br><br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print_vector</span>(result, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>);        <br></code></pre></td></tr></table></figure><p>序列化数据通常以16字节SEALHeader构造开头，定义位于 native/src/seal/serialization.h，然后是对象的压缩数据。<br></p><p>SEALHeader包含如下数据：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[offset 0]</span> <span class="hljs-selector-tag">2-byte</span> <span class="hljs-selector-tag">magic</span> <span class="hljs-selector-tag">number</span> <span class="hljs-selector-tag">0xA15E</span> (<span class="hljs-attribute">Serialization</span>::seal_magic)<br><span class="hljs-selector-attr">[offset 2]</span> <span class="hljs-selector-tag">1-byte</span> <span class="hljs-selector-tag">indicating</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">size</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">bytes</span> (always <span class="hljs-number">16</span>)<br><span class="hljs-selector-attr">[offset 3]</span> <span class="hljs-selector-tag">1-byte</span> <span class="hljs-selector-tag">indicating</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">Microsoft</span> <span class="hljs-selector-tag">SEAL</span> <span class="hljs-selector-tag">major</span> <span class="hljs-selector-tag">version</span> <span class="hljs-selector-tag">number</span><br><span class="hljs-selector-attr">[offset 4]</span> <span class="hljs-selector-tag">1-byte</span> <span class="hljs-selector-tag">indicating</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">Microsoft</span> <span class="hljs-selector-tag">SEAL</span> <span class="hljs-selector-tag">minor</span> <span class="hljs-selector-tag">version</span> <span class="hljs-selector-tag">number</span><br><span class="hljs-selector-attr">[offset 5]</span> <span class="hljs-selector-tag">1-byte</span> <span class="hljs-selector-tag">indicating</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">compression</span> <span class="hljs-selector-tag">mode</span> <span class="hljs-selector-tag">type</span><br><span class="hljs-selector-attr">[offset 6]</span> <span class="hljs-selector-tag">2-byte</span> <span class="hljs-selector-tag">reserved</span> <span class="hljs-selector-tag">field</span> (unused)<br><span class="hljs-selector-attr">[offset 8]</span> <span class="hljs-selector-tag">8-byte</span> <span class="hljs-selector-tag">size</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">bytes</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">serialized</span> <span class="hljs-selector-tag">data</span>, <span class="hljs-selector-tag">including</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">header</span><br></code></pre></td></tr></table></figure><p>作为示例，我们将演示通过保存明文创建的SEALHeader。注意，SEALHeader从未被压缩过，因此不需要指定压缩模式。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Plaintext pt(<span class="hljs-string">&quot;1x^2 + 3&quot;</span>)<span class="hljs-comment">;</span><br>stringstream stream<span class="hljs-comment">;</span><br>auto data_size = pt.save(stream)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>从流中载入SEALHeader</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Serialization<span class="hljs-type">::SEALHeader</span> <span class="hljs-keyword">header</span>;<br>Serialization<span class="hljs-type">::LoadHeader</span>(stream, <span class="hljs-keyword">header</span>);<br></code></pre></td></tr></table></figure><p>写入流中的数据大小与SEALHeader中指定的大小一致</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    <span class="hljs-built_in">print_line</span>(__LINE__);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Size written to stream: &quot;</span> &lt;&lt; data_size &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;             &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;Size indicated in SEALHeader: &quot;</span> &lt;&lt; header.size &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7gxd3a1vj30zv02qacd.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>SEAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEAL</tag>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5_rotation</title>
    <link href="/2022/02/09/5_rotation/"/>
    <url>/2022/02/09/5_rotation/</url>
    
    <content type="html"><![CDATA[<p>(使用BatchEncoder的)BFV方案和CKKS方案都支持加密数字上的自然向量运算。除了计算slot之外，还可以旋转加密向量。</p><h1 id="bfv">1.BFV</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_example_banner(<span class="hljs-string">&quot;Example: Rotation / Rotation in BFV&quot;</span>)</span>;<br><br>EncryptionParameters parms(scheme_type::bfv);<br><br>size_t poly_modulus_degree = <span class="hljs-number">8192</span>;<br>parms.set<span class="hljs-constructor">_poly_modulus_degree(<span class="hljs-params">poly_modulus_degree</span>)</span>;<br>parms.set<span class="hljs-constructor">_coeff_modulus(CoeffModulus::BFVDefault(<span class="hljs-params">poly_modulus_degree</span>)</span>);<br>parms.set<span class="hljs-constructor">_plain_modulus(PlainModulus::Batching(<span class="hljs-params">poly_modulus_degree</span>, 20)</span>);<br><br>SEALContext context(parms);<br>print<span class="hljs-constructor">_parameters(<span class="hljs-params">context</span>)</span>;<br>cout &lt;&lt; endl;<br><br>KeyGenerator keygen(context);<br>SecretKey secret_key = keygen.secret<span class="hljs-constructor">_key()</span>;<br>PublicKey public_key;<br>keygen.create<span class="hljs-constructor">_public_key(<span class="hljs-params">public_key</span>)</span>;<br>RelinKeys relin_keys;<br>keygen.create<span class="hljs-constructor">_relin_keys(<span class="hljs-params">relin_keys</span>)</span>;<br>Encryptor encryptor(context, public_key);<br>Evaluator evaluator(context);<br>Decryptor decryptor(context, secret_key);<br><br>BatchEncoder batch<span class="hljs-constructor">_encoder(<span class="hljs-params">context</span>)</span>;<br>size_t slot_count = batch_encoder.slot<span class="hljs-constructor">_count()</span>;<br>size_t row_size = slot_count<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Plaintext matrix row size: &quot;</span> &lt;&lt; row_size &lt;&lt; endl;<br><br>vector&lt;uint64_t&gt; pod<span class="hljs-constructor">_matrix(<span class="hljs-params">slot_count</span>, 0ULL)</span>;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">0</span>ULL;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-number">1</span>]</span> = <span class="hljs-number">1</span>ULL;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-number">2</span>]</span> = <span class="hljs-number">2</span>ULL;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-number">3</span>]</span> = <span class="hljs-number">3</span>ULL;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-identifier">row_size</span>]</span> = <span class="hljs-number">4</span>ULL;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-identifier">row_size</span> + <span class="hljs-number">1</span>]</span> = <span class="hljs-number">5</span>ULL;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-identifier">row_size</span> + <span class="hljs-number">2</span>]</span> = <span class="hljs-number">6</span>ULL;<br>pod_matrix<span class="hljs-literal">[<span class="hljs-identifier">row_size</span> + <span class="hljs-number">3</span>]</span> = <span class="hljs-number">7</span>ULL;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Input plaintext matrix:&quot;</span> &lt;&lt; endl;<br>print<span class="hljs-constructor">_matrix(<span class="hljs-params">pod_matrix</span>, <span class="hljs-params">row_size</span>)</span>;<br><br></code></pre></td></tr></table></figure><p>首先使用BatchEncoder将矩阵编码为明文并加密。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Plaintext plain_matrix;<br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Encode and encrypt.&quot;</span> &lt;&lt; endl;<br>batch_encoder.<span class="hljs-built_in">encode</span>(pod_matrix, plain_matrix);<br>Ciphertext encrypted_matrix;<br>encryptor.<span class="hljs-built_in">encrypt</span>(plain_matrix, encrypted_matrix);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Noise budget in fresh encryption: &quot;</span> &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(encrypted_matrix) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>旋转需要另一种特殊密钥"Galois key"，可以使用KeyGenerator创建。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">GaloisKeys galois_keys<span class="hljs-comment">;</span><br>keygen.create_galois_keys(galois_keys)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>将矩阵的行向左旋转3步，解密、解码并打印出。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Rotate rows 3 steps left.&quot;</span> &lt;&lt; endl;<br>evaluator.rotate<span class="hljs-constructor">_rows_inplace(<span class="hljs-params">encrypted_matrix</span>, 3, <span class="hljs-params">galois_keys</span>)</span>;<br>Plaintext plain_result;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Noise budget after rotation: &quot;</span> &lt;&lt; decryptor.invariant<span class="hljs-constructor">_noise_budget(<span class="hljs-params">encrypted_matrix</span>)</span> &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Decrypt and decode ...... Correct.&quot;</span> &lt;&lt; endl;<br>decryptor.decrypt(encrypted_matrix, plain_result);<br>batch_encoder.decode(plain_result, pod_matrix);<br>print<span class="hljs-constructor">_matrix(<span class="hljs-params">pod_matrix</span>, <span class="hljs-params">row_size</span>)</span>;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7c7522daj315e0fhdu8.jpg" /></p><p>也可以旋转列</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Rotate columns.&quot;</span> &lt;&lt; endl;<br>evaluator.rotate<span class="hljs-constructor">_columns_inplace(<span class="hljs-params">encrypted_matrix</span>, <span class="hljs-params">galois_keys</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Noise budget after rotation: &quot;</span> &lt;&lt; decryptor.invariant<span class="hljs-constructor">_noise_budget(<span class="hljs-params">encrypted_matrix</span>)</span> &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Decrypt and decode ...... Correct.&quot;</span> &lt;&lt; endl;<br>decryptor.decrypt(encrypted_matrix, plain_result);<br>batch_encoder.decode(plain_result, pod_matrix);<br>print<span class="hljs-constructor">_matrix(<span class="hljs-params">pod_matrix</span>, <span class="hljs-params">row_size</span>)</span>;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7c7z42h1j313t0drgy5.jpg" /></p><p>最后将行向右旋转4步，解密、解码并打印出</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Rotate rows 4 steps right.&quot;</span> &lt;&lt; endl;<br>evaluator.rotate<span class="hljs-constructor">_rows_inplace(<span class="hljs-params">encrypted_matrix</span>, -4, <span class="hljs-params">galois_keys</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Noise budget after rotation: &quot;</span> &lt;&lt; decryptor.invariant<span class="hljs-constructor">_noise_budget(<span class="hljs-params">encrypted_matrix</span>)</span> &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Decrypt and decode ...... Correct.&quot;</span> &lt;&lt; endl;<br>decryptor.decrypt(encrypted_matrix, plain_result);<br>batch_encoder.decode(plain_result, pod_matrix);<br>print<span class="hljs-constructor">_matrix(<span class="hljs-params">pod_matrix</span>, <span class="hljs-params">row_size</span>)</span>;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7c8r2qsxj31310deam5.jpg" /></p><p>旋转操作不消耗任何噪声预算。但是这要求特殊素数至少和其他素数一样大。SEAL没有对特殊素数的大小进行要求，因此这需要用户自行保证。</p><h1 id="ckks">2.CKKS</h1><p>CKKS中的旋转操作与BFV中类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">EncryptionParameters <span class="hljs-title">parms</span><span class="hljs-params">(scheme_type::ckks)</span></span>;<br><br><span class="hljs-keyword">size_t</span> poly_modulus_degree = <span class="hljs-number">8192</span>;<br>parms.<span class="hljs-built_in">set_poly_modulus_degree</span>(poly_modulus_degree);<br>parms.<span class="hljs-built_in">set_coeff_modulus</span>(CoeffModulus::<span class="hljs-built_in">Create</span>(poly_modulus_degree, &#123; <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span> &#125;));<br><br><span class="hljs-function">SEALContext <span class="hljs-title">context</span><span class="hljs-params">(parms)</span></span>;<br><span class="hljs-built_in">print_parameters</span>(context);<br>cout &lt;&lt; endl;<br><br><span class="hljs-function">KeyGenerator <span class="hljs-title">keygen</span><span class="hljs-params">(context)</span></span>;<br>SecretKey secret_key = keygen.<span class="hljs-built_in">secret_key</span>();<br>PublicKey public_key;<br>keygen.<span class="hljs-built_in">create_public_key</span>(public_key);<br>RelinKeys relin_keys;<br>keygen.<span class="hljs-built_in">create_relin_keys</span>(relin_keys);<br>GaloisKeys galois_keys;<br>keygen.<span class="hljs-built_in">create_galois_keys</span>(galois_keys);<br><span class="hljs-function">Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">(context, public_key)</span></span>;<br><span class="hljs-function">Evaluator <span class="hljs-title">evaluator</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-function">Decryptor <span class="hljs-title">decryptor</span><span class="hljs-params">(context, secret_key)</span></span>;<br><br><span class="hljs-function">CKKSEncoder <span class="hljs-title">ckks_encoder</span><span class="hljs-params">(context)</span></span>;<br><br><span class="hljs-keyword">size_t</span> slot_count = ckks_encoder.<span class="hljs-built_in">slot_count</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;Number of slots: &quot;</span> &lt;&lt; slot_count &lt;&lt; endl;<br>vector&lt;<span class="hljs-keyword">double</span>&gt; input;<br>input.<span class="hljs-built_in">reserve</span>(slot_count);<br><span class="hljs-keyword">double</span> curr_point = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> step_size = <span class="hljs-number">1.0</span> / (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(slot_count) - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; slot_count; i++, curr_point += step_size)<br>&#123;<br>    input.<span class="hljs-built_in">push_back</span>(curr_point);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Input vector:&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print_vector</span>(input, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br><br><span class="hljs-keyword">auto</span> scale = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">50</span>);<br><br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Encode and encrypt.&quot;</span> &lt;&lt; endl;<br>Plaintext plain;<br>ckks_encoder.<span class="hljs-built_in">encode</span>(input, scale, plain);<br>Ciphertext encrypted;<br>encryptor.<span class="hljs-built_in">encrypt</span>(plain, encrypted);<br><br>Ciphertext rotated;<br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Rotate 2 steps left.&quot;</span> &lt;&lt; endl;<br>evaluator.<span class="hljs-built_in">rotate_vector</span>(encrypted, <span class="hljs-number">2</span>, galois_keys, rotated);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Decrypt and decode ...... Correct.&quot;</span> &lt;&lt; endl;<br>decryptor.<span class="hljs-built_in">decrypt</span>(rotated, plain);<br>vector&lt;<span class="hljs-keyword">double</span>&gt; result;<br>ckks_encoder.<span class="hljs-built_in">decode</span>(plain, result);<br><span class="hljs-built_in">print_vector</span>(result, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz7c4zjr54j31060aswoi.jpg" /></p><p>在CKKS方案中，可以使用Evaluator::complex_conjugate对加密复数向量求共轭。这实际上也是一种旋转操作，需要用到Galois key。</p>]]></content>
    
    
    <categories>
      
      <category>SEAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEAL</tag>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4_ckks_basics</title>
    <link href="/2022/02/08/4_ckks_basics/"/>
    <url>/2022/02/08/4_ckks_basics/</url>
    
    <content type="html"><![CDATA[<p>本例中演示了一个多项式函数的求值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PI</span>*x^<span class="hljs-number">3</span> + <span class="hljs-number">0</span>.<span class="hljs-number">4</span>*x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>x是位于区间[0,1]的一组4096等距点中的一个加密浮点输入数据。这个例子演示了CKKS方案的主要特性。<br></p><p>首先选择方案</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">EncryptionParameters</span> parms(scheme_<span class="hljs-keyword">type</span>::ckks);<br></code></pre></td></tr></table></figure><p>在2_encoders中看到CKKS的乘法导致密文规模增长。任意密文的规模都不能太接近coeff_modulus的总大小，否则存储放大的明文将耗尽空间。CKKS方案提供了一个rescale功能，用于减小scale并稳定scale扩展。<br></p><p>rescale是一种模切换操作(参考3_levels)。在转换模数时，会从coeff_modulus中移除最后一个素数，这将缩小密文。更精确地说，假设CKKS密文中的scale为S，当前coeff_modulus中的最后一个素数是P，rescale下一层将scale更改为S/P，并从coeff_modulus中去除P。素数的数量限制了rescale的次数，从而限制了计算的乘法深度。<br></p><p>自由选择初始scale是可能的。一个方法是在coeff_modulus中设置初始scale S和素数P_i非常接近。如果在乘法操作之前的scale是S，则操作后scale变为<span class="math inline">\(S^2\)</span>，rescale后scale变为<span class="math inline">\(S^2/P_i\)</span>。若所有<span class="math inline">\(P_i\)</span>都接近于S，则<span class="math inline">\(S^2/P_i\)</span>就接近于S。通过这种方法，可以在整个计算过程中使scale稳定在接近S。一般来说，对于深度为D的电路，需要rescale D次，即把D个素数从coeff_modulus中去除。一旦coeff_moudlus中只剩下一个素数，要求这个素数必须比S大几个位，以保留明文在小数点前的值。<br></p><p>通常选择CKKS方案的参数如下：<br> (1)选择一个60位素数作为coeff_modulus中的第一个素数。这提供了解密时的最高精度；<br> (2)选择另一个60位素数作为coeff_modulus的最后一个元素，它作为特殊素数，应该与其他素数中的最大素数相等；<br> (3)中间的素数应该相接近。<br></p><p>使用CoeffModulus::Create生成合适大小的素数。注意coeff_modulus是200位的，低于poly_modulus_degree的界限：coeff_modulus_degree::MaxBitCount(8192)返回218.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">size_t</span> poly_modulus_degree = <span class="hljs-number">8192</span>;<br><span class="hljs-attribute">parms</span>.set_poly_modulus_degree(poly_modulus_degree);<br><span class="hljs-attribute">parms</span>.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; <span class="hljs-number">60</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span> &#125;));<br></code></pre></td></tr></table></figure><p>选择初始规模位<span class="math inline">\(2^{40}\)</span>。在最后一层，小数点前留下60-40=20位精度，小数点后留下足够的精度(大约10-20位)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> scale = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">40</span>);<br><br><span class="hljs-function">SEALContext <span class="hljs-title">context</span><span class="hljs-params">(parms)</span></span>;<br><span class="hljs-built_in">print_parameters</span>(context);<br>cout &lt;&lt; endl;<br><br><span class="hljs-function">KeyGenerator <span class="hljs-title">keygen</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-keyword">auto</span> secret_key = keygen.<span class="hljs-built_in">secret_key</span>();<br>PublicKey public_key;<br>keygen.<span class="hljs-built_in">create_public_key</span>(public_key);<br>RelinKeys relin_keys;<br>keygen.<span class="hljs-built_in">create_relin_keys</span>(relin_keys);<br>GaloisKeys gal_keys;<br>keygen.<span class="hljs-built_in">create_galois_keys</span>(gal_keys);<br><span class="hljs-function">Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">(context, public_key)</span></span>;<br><span class="hljs-function">Evaluator <span class="hljs-title">evaluator</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-function">Decryptor <span class="hljs-title">decryptor</span><span class="hljs-params">(context, secret_key)</span></span>;<br><br><span class="hljs-function">CKKSEncoder <span class="hljs-title">encoder</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-keyword">size_t</span> slot_count = encoder.<span class="hljs-built_in">slot_count</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;Number of slots: &quot;</span> &lt;&lt; slot_count &lt;&lt; endl;<br><br>vector&lt;<span class="hljs-keyword">double</span>&gt; input;<br>input.<span class="hljs-built_in">reserve</span>(slot_count);<br><span class="hljs-keyword">double</span> curr_point = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> step_size = <span class="hljs-number">1.0</span> / (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(slot_count) - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; slot_count; i++)<br>&#123;<br>    input.<span class="hljs-built_in">push_back</span>(curr_point);<br>    curr_point += step_size;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Input vector: &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print_vector</span>(input, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Evaluating polynomial PI*x^3 + 0.4x + 1 ...&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>为PI、0.4和1创建明文，使用CKKSEncoder将给定浮点值编码为向量的每个slot</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Plaintext</span> plain_coeff<span class="hljs-number">3</span>, plain_coeff<span class="hljs-number">1</span>, plain_coeff<span class="hljs-number">0</span>;<br><span class="hljs-attribute">encoder</span>.encode(<span class="hljs-number">3</span>.<span class="hljs-number">14159265</span>, scale, plain_coeff<span class="hljs-number">3</span>);<br><span class="hljs-attribute">encoder</span>.encode(<span class="hljs-number">0</span>.<span class="hljs-number">4</span>, scale, plain_coeff<span class="hljs-number">1</span>);<br><span class="hljs-attribute">encoder</span>.encode(<span class="hljs-number">1</span>.<span class="hljs-number">0</span>, scale, plain_coeff<span class="hljs-number">0</span>);<br><br><span class="hljs-attribute">Plaintext</span> x_plain;<br><span class="hljs-attribute">print_line</span>(__LINE__);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;Encode input vectors.&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">encoder</span>.encode(input, scale, x_plain);<br><span class="hljs-attribute">Ciphertext</span> x<span class="hljs-number">1</span>_encrypted;<br><span class="hljs-attribute">encryptor</span>.encrypt(x_plain, x<span class="hljs-number">1</span>_encrypted);<br></code></pre></td></tr></table></figure><p>为了计算<span class="math inline">\(x^3\)</span>，首先计算<span class="math inline">\(x^2\)</span>并执行relinearize操作，scale增长至<span class="math inline">\(2^{80}\)</span></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Ciphertext</span> x<span class="hljs-number">3</span>_encrypted;<br><span class="hljs-attribute">print_line</span>(__LINE__);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;Compute x^2 and relinearize:&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">evaluator</span>.square(x<span class="hljs-number">1</span>_encrypted, x<span class="hljs-number">3</span>_encrypted);<br><span class="hljs-attribute">evaluator</span>.relinearize_inplace(x<span class="hljs-number">3</span>_encrypted, relin_keys);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;    + Scale of x^2 before rescale: &quot;</span> &lt;&lt; log<span class="hljs-number">2</span>(x<span class="hljs-number">3</span>_encrypted.scale()) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>执行rescale操作；除了模数切换之外，scale减少了一个因子，该因子等于被去掉的素数(40位素数)。因此新的scale应该接近<span class="math inline">\(2^{40}\)</span>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">print_line(__LINE__)<span class="hljs-comment">;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Rescale x^2.&quot;</span> &lt;&lt; endl<span class="hljs-comment">;</span><br>evaluator.rescale_to_next_inplace(x3_encrypted)<span class="hljs-comment">;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;    + Scale of x^2 after rescale: &quot;</span> &lt;&lt; log2(x3_encrypted.scale()) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>现在得到的x3_encrypted和x1_encrypted位于不同的level，这使得我们无法直接将其相乘来计算<span class="math inline">\(x^{3}\)</span>。我们可以简单地将x1_encryption切换到模数转换链的下一个元素。但是由于我们还需要将<span class="math inline">\(x^{3}\)</span>与PI(plain_coeff3)相乘，所以我们可以先将PI与x相乘(得到x1_encrypted_coeff3)，再将得到的结果与<span class="math inline">\(x^{2}\)</span>相乘，得到<span class="math inline">\(PI*x^{3}\)</span>.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print_line</span>(__LINE__);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;Compute and rescale PI*x.&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">Ciphertext</span> x<span class="hljs-number">1</span>_encrypted_coeff<span class="hljs-number">3</span>;<br><span class="hljs-attribute">evaluator</span>.multiply_plain(x<span class="hljs-number">1</span>_encrypted, plain_coeff<span class="hljs-number">3</span>, x<span class="hljs-number">1</span>_encrypted_coeff<span class="hljs-number">3</span>);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;    + Scale of PI*x before rescale: &quot;</span> &lt;&lt; log<span class="hljs-number">2</span>(x<span class="hljs-number">1</span>_encrypted_coeff<span class="hljs-number">3</span>.scale()) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">evaluator</span>.rescale_to_next_inplace(x<span class="hljs-number">1</span>_encrypted_coeff<span class="hljs-number">3</span>);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;    + Scale of PI*x after rescale: &quot;</span> &lt;&lt; log<span class="hljs-number">2</span>(x<span class="hljs-number">1</span>_encrypted_coeff<span class="hljs-number">3</span>.scale()) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure><p>因为x3_encrypted与x1_encrypted_coeff3具有相同的scale，且使用相同的加密参数，因此可以直接将其相乘。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute, relinearize, and rescale (PI*x)*x^2.&quot;</span> &lt;&lt; endl;<br>evaluator.multiply<span class="hljs-constructor">_inplace(<span class="hljs-params">x3_encrypted</span>, <span class="hljs-params">x1_encrypted_coeff3</span>)</span>;<br>evaluator.relinearize<span class="hljs-constructor">_inplace(<span class="hljs-params">x3_encrypted</span>, <span class="hljs-params">relin_keys</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Scale of PI*x^3 before rescale: &quot;</span> &lt;&lt; log2(x3_encrypted.scale<span class="hljs-literal">()</span>) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br>evaluator.rescale<span class="hljs-constructor">_to_next_inplace(<span class="hljs-params">x3_encrypted</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Scale of PI*x^3 after rescale: &quot;</span> &lt;&lt; log2(x3_encrypted.scale<span class="hljs-literal">()</span>) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>接下来计算一次项</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print_line</span>(__LINE__);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;Compute and rescale 0.4*x.&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">evaluator</span>.multiply_plain_inplace(x<span class="hljs-number">1</span>_encrypted, plain_coeff<span class="hljs-number">1</span>);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;    + Scale of 0.4*x before rescale: &quot;</span> &lt;&lt; log<span class="hljs-number">2</span>(x<span class="hljs-number">1</span>_encrypted.scale()) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">evaluator</span>.rescale_to_next_inplace(x<span class="hljs-number">1</span>_encrypted);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;    + Scale of 0.4*x after rescale: &quot;</span> &lt;&lt; log<span class="hljs-number">2</span>(x<span class="hljs-number">1</span>_encrypted.scale()) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>接下来需要求三项的和，但是问题是这三项使用的加密参数是不同的，因为模数经过了rescale转换(加密的加法和减法要求level相同且加密参数匹配，若不匹配则抛出异常)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cout &lt;&lt; endl;<br>print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Parameters used by all three terms are different.&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Modulus chain index for x3_encrypted: &quot;</span><br>     &lt;&lt; context.get<span class="hljs-constructor">_context_data(<span class="hljs-params">x3_encrypted</span>.<span class="hljs-params">parms_id</span>()</span>)-&gt;chain<span class="hljs-constructor">_index()</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Modulus chain index for x1_encrypted: &quot;</span><br>     &lt;&lt; context.get<span class="hljs-constructor">_context_data(<span class="hljs-params">x1_encrypted</span>.<span class="hljs-params">parms_id</span>()</span>)-&gt;chain<span class="hljs-constructor">_index()</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Modulus chain index for plain_coeff0: &quot;</span><br>     &lt;&lt; context.get<span class="hljs-constructor">_context_data(<span class="hljs-params">plain_coeff0</span>.<span class="hljs-params">parms_id</span>()</span>)-&gt;chain<span class="hljs-constructor">_index()</span> &lt;&lt; endl;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz6ezkwn2ij30w304lq6v.jpg" /></p><p>将系数中的素数表示为<span class="math inline">\(P_{0}、P_{1}、P_{2}、P_{3}\)</span>，其中<span class="math inline">\(P_{3}\)</span>作为特殊模数不涉及rescale</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- Product x^<span class="hljs-number">2</span> has scale <span class="hljs-number">2</span>^<span class="hljs-number">80</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> at <span class="hljs-keyword">level</span> <span class="hljs-number">2</span>;<br>- Product PI*x has scale <span class="hljs-number">2</span>^<span class="hljs-number">80</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> at <span class="hljs-keyword">level</span> <span class="hljs-number">2</span>;<br>- We rescaled <span class="hljs-keyword">both</span> down <span class="hljs-keyword">to</span> scale <span class="hljs-number">2</span>^<span class="hljs-number">80</span>/P_2 <span class="hljs-keyword">and</span> <span class="hljs-keyword">level</span> <span class="hljs-number">1</span>;<br>- Product PI*x^<span class="hljs-number">3</span> has scale (<span class="hljs-number">2</span>^<span class="hljs-number">80</span>/P_2)^<span class="hljs-number">2</span>;<br>- We rescaled it down <span class="hljs-keyword">to</span> scale (<span class="hljs-number">2</span>^<span class="hljs-number">80</span>/P_2)^<span class="hljs-number">2</span>/P_1 <span class="hljs-keyword">and</span> <span class="hljs-keyword">level</span> <span class="hljs-number">0</span>;<br>- Product <span class="hljs-number">0.4</span>*x has scale <span class="hljs-number">2</span>^<span class="hljs-number">80</span>;<br>- We rescaled it down <span class="hljs-keyword">to</span> scale <span class="hljs-number">2</span>^<span class="hljs-number">80</span>/P_2 <span class="hljs-keyword">and</span> <span class="hljs-keyword">level</span> <span class="hljs-number">1</span>;<br>- The contant term <span class="hljs-number">1</span> has scale <span class="hljs-number">2</span>^<span class="hljs-number">40</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> at <span class="hljs-keyword">level</span> <span class="hljs-number">2.</span><br></code></pre></td></tr></table></figure><p>虽然三项的scale都大约是<span class="math inline">\(2^{40}\)</span>，但它们的确切值是不同的，因此不能相加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;The exact scales of all three terms are different:&quot;</span> &lt;&lt; endl;<br><span class="hljs-function">ios <span class="hljs-title">old_fmt</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;<br>old_fmt.<span class="hljs-built_in">copyfmt</span>(cout);<br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Exact scale in PI*x^3: &quot;</span> &lt;&lt; x3_encrypted.<span class="hljs-built_in">scale</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Exact scale in  0.4*x: &quot;</span> &lt;&lt; x1_encrypted.<span class="hljs-built_in">scale</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Exact scale in      1: &quot;</span> &lt;&lt; plain_coeff0.<span class="hljs-built_in">scale</span>() &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>cout.<span class="hljs-built_in">copyfmt</span>(old_fmt);<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz6fqv39woj30vf04e0wu.jpg" /></p><p>解决方法：<br> (1)由于<span class="math inline">\(P_{1}\)</span>和<span class="math inline">\(P_{2}\)</span>非常接近<span class="math inline">\(2^40\)</span>，我们可以简单"欺骗"SEAL，直接设置为相同的scale。<br> (2)用<span class="math inline">\(2^{80}/P_{2}\)</span>对1进行编码，然后用0.4*x进行乘法运算，最后rescale。这种方法还需要我们确保使用适当的加密参数(parms_id)对1进行编码。<br></p><p>本例中使用第一种(最简单的)方法，将<span class="math inline">\(PI*x^{3}\)</span>和0.4*x的scale设置为<span class="math inline">\(2^{40}\)</span>.</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print_line</span>(__LINE__);<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;Normalize scales to 2^40.&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">x3_encrypted</span>.scale() = pow(<span class="hljs-number">2</span>.<span class="hljs-number">0</span>, <span class="hljs-number">40</span>);<br><span class="hljs-attribute">x1_encrypted</span>.scale() = pow(<span class="hljs-number">2</span>.<span class="hljs-number">0</span>, <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><p>还有加密参数不匹配的问题。使用传统的模数切换(没有rescale)就可以解决。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Normalize encryption parameters to the lowest level.&quot;</span> &lt;&lt; endl;<br>parms_id_type last_parms_id = x3_encrypted.parms<span class="hljs-constructor">_id()</span>;<br>evaluator.<span class="hljs-keyword">mod</span><span class="hljs-constructor">_switch_to_inplace(<span class="hljs-params">x1_encrypted</span>, <span class="hljs-params">last_parms_id</span>)</span>;<br>evaluator.<span class="hljs-keyword">mod</span><span class="hljs-constructor">_switch_to_inplace(<span class="hljs-params">plain_coeff0</span>, <span class="hljs-params">last_parms_id</span>)</span>;<br></code></pre></td></tr></table></figure><p>现在即可将三个密文相加</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute PI*x^3 + 0.4*x + 1.&quot;</span> &lt;&lt; endl;<br>Ciphertext encrypted_result;<br>evaluator.<span class="hljs-built_in">add</span>(x3_encrypted, x1_encrypted, encrypted_result);<br>evaluator.<span class="hljs-built_in">add_plain_inplace</span>(encrypted_result, plain_coeff0);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">First print the true result.</span><br><span class="hljs-comment">*/</span><br>Plaintext plain_result;<br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Decrypt and decode PI*x^3 + 0.4x + 1.&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Expected result:&quot;</span> &lt;&lt; endl;<br>vector&lt;<span class="hljs-keyword">double</span>&gt; true_result;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    <span class="hljs-keyword">double</span> x = input[i];<br>    true_result.<span class="hljs-built_in">push_back</span>((<span class="hljs-number">3.14159265</span> * x * x + <span class="hljs-number">0.4</span>) * x + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">print_vector</span>(true_result, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Decrypt, decode, and print the result.</span><br><span class="hljs-comment">*/</span><br>decryptor.<span class="hljs-built_in">decrypt</span>(encrypted_result, plain_result);<br>vector&lt;<span class="hljs-keyword">double</span>&gt; result;<br>encoder.<span class="hljs-built_in">decode</span>(plain_result, result);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Computed result ...... Correct.&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print_vector</span>(result, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SEAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEAL</tag>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3_levels</title>
    <link href="/2022/02/08/3_levels/"/>
    <url>/2022/02/08/3_levels/</url>
    
    <content type="html"><![CDATA[<p>在SEAL中，一组加密参数(不包括随机数生成器)由参数的SHA-3唯一标识。这个哈希值称为"parms_id"，任何参数的改变都会导致哈希值的改变。<br></p><p>当为给定的加密参数创建SEALContext时，SEAL自动创建一个"模数转换链"，链中的参数与原始参数是相同的，但系数模数的大小沿着链向下递减。更准确地说，链中的每个参数集都试图从前一个集合中移除最后一个系数模数素数；这种情况一直持续到参数集不再有效为止(例如，plain_modulus大于剩余的coeff_modulus)。遍历链并访问所有参数集是很容易的。此外，链中的每个参数集都有一个"链索引"，该索引表示其在链中的位置，最后一个参数集的索引为0。如果一组加密参数或携带这些参数的对象的链索引更大，则称其在链中的级别更高。<br></p><p>链中的每一组参数都包含SEALContext创建时执行的唯一预计算，存储在SEALContext::ContextData对象中。该链基本上是一个SEALContext::ContextData对象的链表，每个节点都可以通过特定参数的parms_id来标识(poly_modulus_degree保持不变，但coeff_modulus会变化)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">EncryptionParameters <span class="hljs-title">parms</span><span class="hljs-params">(scheme_type::bfv)</span></span>;<br><br><span class="hljs-keyword">size_t</span> poly_modulus_degree = <span class="hljs-number">8192</span>;<br>parms.<span class="hljs-built_in">set_poly_modulus_degree</span>(poly_modulus_degree);<br></code></pre></td></tr></table></figure><p>本例中，我们使用自定义的coeff_modulus，包含size为50、30、30、50和50位的个素数</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">CoeffModulus</span>::<span class="hljs-function"><span class="hljs-title">MaxBitCount</span>(<span class="hljs-variable">poly_modulus_degree</span>)</span><br></code></pre></td></tr></table></figure><p>返回218(大于50+30+30+50+50=210)<br></p><p>由于模数转换链的关系，五个素数的顺序是重要的。最后一个素数具有特殊含义，称之为"特殊素数"。因此，模数转换链中的第一个参数集是唯一涉及到特殊素数的参数集。所有密钥对象，如SecretKey都是在这个最高级别创建的。所有数据对象(如密文)只能在较低的级别上。特殊模数应该与coeff_modulus中最大质数一样大。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml">          <span class="hljs-string">special</span> <span class="hljs-string">prime</span> <span class="hljs-string">+---------+</span><br>                                  <span class="hljs-string">|</span><br><span class="hljs-string">                                  v</span><br><span class="hljs-string"></span><span class="hljs-attr">coeff_modulus:</span> &#123; <span class="hljs-number">50</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span> &#125;  <span class="hljs-string">+---+</span>  <span class="hljs-string">Level</span> <span class="hljs-number">4</span> <span class="hljs-string">(all</span> <span class="hljs-string">keys;</span> <span class="hljs-string">`key</span> <span class="hljs-string">level&#x27;)</span><br>                                           <span class="hljs-string">|</span><br><span class="hljs-string">                                           |</span><br><span class="hljs-string"></span>    <span class="hljs-attr">coeff_modulus:</span> &#123; <span class="hljs-number">50</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span> &#125;  <span class="hljs-string">+---+</span>  <span class="hljs-string">Level</span> <span class="hljs-number">3</span> <span class="hljs-string">(highest</span> <span class="hljs-string">`data</span> <span class="hljs-string">level&#x27;)</span><br>                                           <span class="hljs-string">|</span><br><span class="hljs-string">                                           |</span><br><span class="hljs-string"></span>        <span class="hljs-attr">coeff_modulus:</span> &#123; <span class="hljs-number">50</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span> &#125;  <span class="hljs-string">+---+</span>  <span class="hljs-string">Level</span> <span class="hljs-number">2</span><br>                                           <span class="hljs-string">|</span><br><span class="hljs-string">                                           |</span><br><span class="hljs-string"></span>            <span class="hljs-attr">coeff_modulus:</span> &#123; <span class="hljs-number">50</span>, <span class="hljs-number">30</span> &#125;  <span class="hljs-string">+---+</span>  <span class="hljs-string">Level</span> <span class="hljs-number">1</span><br>                                           <span class="hljs-string">|</span><br><span class="hljs-string">                                           |</span><br><span class="hljs-string"></span>                <span class="hljs-attr">coeff_modulus:</span> &#123; <span class="hljs-number">50</span> &#125;  <span class="hljs-string">+---+</span>  <span class="hljs-string">Level</span> <span class="hljs-number">0</span> <span class="hljs-string">(lowest</span> <span class="hljs-string">level)</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">parms.set<span class="hljs-constructor">_coeff_modulus(CoeffModulus::Create(<span class="hljs-params">poly_modulus_degree</span>, &#123; 50, 30, 30, 50, 50 &#125;)</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">In this example the plain_modulus does not play much of a role; we choose</span><br><span class="hljs-comment">some reasonable value.</span><br><span class="hljs-comment">*/</span><br>parms.set<span class="hljs-constructor">_plain_modulus(PlainModulus::Batching(<span class="hljs-params">poly_modulus_degree</span>, 20)</span>);<br><br>SEALContext context(parms);<br>print<span class="hljs-constructor">_parameters(<span class="hljs-params">context</span>)</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>提供了一些简便方法来访问重要level的SEALContext::ContextData</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">SEALContext::key_context_data(): <span class="hljs-keyword">access</span> <span class="hljs-keyword">to</span> key <span class="hljs-keyword">level</span> ContextData<br>SEALContext::first_context_data(): <span class="hljs-keyword">access</span> <span class="hljs-keyword">to</span> highest data <span class="hljs-keyword">level</span> ContextData<br>SEALContext::last_context_data(): <span class="hljs-keyword">access</span> <span class="hljs-keyword">to</span> lowest <span class="hljs-keyword">level</span> ContextData<br></code></pre></td></tr></table></figure><p>遍历每个参数集并打印parms_id</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Print the modulus switching chain.&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">First print the key level parameter information.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">auto</span> context_data = context.<span class="hljs-built_in">key_context_data</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----&gt; Level (chain index): &quot;</span> &lt;&lt; context_data-&gt;<span class="hljs-built_in">chain_index</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot; ...... key_context_data()&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;      parms_id: &quot;</span> &lt;&lt; context_data-&gt;<span class="hljs-built_in">parms_id</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;      coeff_modulus primes: &quot;</span>;<br>cout &lt;&lt; hex;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;prime : context_data-&gt;<span class="hljs-built_in">parms</span>().<span class="hljs-built_in">coeff_modulus</span>())<br>&#123;<br>    cout &lt;&lt; prime.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; dec &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;\\&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot; \\--&gt;&quot;</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Next iterate over the remaining (data) levels.</span><br><span class="hljs-comment">*/</span><br>context_data = context.<span class="hljs-built_in">first_context_data</span>();<br><span class="hljs-keyword">while</span> (context_data)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot; Level (chain index): &quot;</span> &lt;&lt; context_data-&gt;<span class="hljs-built_in">chain_index</span>();<br>    <span class="hljs-keyword">if</span> (context_data-&gt;<span class="hljs-built_in">parms_id</span>() == context.<span class="hljs-built_in">first_parms_id</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot; ...... first_context_data()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context_data-&gt;<span class="hljs-built_in">parms_id</span>() == context.<span class="hljs-built_in">last_parms_id</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot; ...... last_context_data()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;      parms_id: &quot;</span> &lt;&lt; context_data-&gt;<span class="hljs-built_in">parms_id</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;      coeff_modulus primes: &quot;</span>;<br>    cout &lt;&lt; hex;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;prime : context_data-&gt;<span class="hljs-built_in">parms</span>().<span class="hljs-built_in">coeff_modulus</span>())<br>    &#123;<br>        cout &lt;&lt; prime.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; dec &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\\&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot; \\--&gt;&quot;</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    Step forward in the chain.</span><br><span class="hljs-comment">    */</span><br>    context_data = context_data-&gt;<span class="hljs-built_in">next_context_data</span>();<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot; End of chain reached&quot;</span> &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">We create some keys and check that indeed they appear at the highest level.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">KeyGenerator <span class="hljs-title">keygen</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-keyword">auto</span> secret_key = keygen.<span class="hljs-built_in">secret_key</span>();<br>PublicKey public_key;<br>keygen.<span class="hljs-built_in">create_public_key</span>(public_key);<br>RelinKeys relin_keys;<br>keygen.<span class="hljs-built_in">create_relin_keys</span>(relin_keys);<br><br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Print the parameter IDs of generated elements.&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + public_key:  &quot;</span> &lt;&lt; public_key.<span class="hljs-built_in">parms_id</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + secret_key:  &quot;</span> &lt;&lt; secret_key.<span class="hljs-built_in">parms_id</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + relin_keys:  &quot;</span> &lt;&lt; relin_keys.<span class="hljs-built_in">parms_id</span>() &lt;&lt; endl;<br><br><span class="hljs-function">Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">(context, public_key)</span></span>;<br><span class="hljs-function">Evaluator <span class="hljs-title">evaluator</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-function">Decryptor <span class="hljs-title">decryptor</span><span class="hljs-params">(context, secret_key)</span></span>;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz5xajgoo8j31cr0sye81.jpg" /></p><p>在BFV方案中，明文没有parms_id参数，但密文有，注意最高数据level的新加密密文</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Plaintext plain(&quot;1x^3 + 2x^2 + 3x^1 + 4&quot;);<br>Ciphertext <span class="hljs-keyword">encrypted</span>;<br>encryptor.encrypt(plain, <span class="hljs-keyword">encrypted</span>);<br>cout &lt;&lt; &quot;    + plain:       &quot; &lt;&lt; plain.parms_id() &lt;&lt; &quot; (not set in BFV)&quot; &lt;&lt; endl;<br>cout &lt;&lt; &quot;    + encrypted:   &quot; &lt;&lt; <span class="hljs-keyword">encrypted</span>.parms_id() &lt;&lt; endl &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>"模数切换"是一种改变密文参数的技术。函数Evaluaor::mod_switch_to_next切换到链的下一层，Evaluator::mod_switch_to切换到与给定parms_id对应的链下的参数集。但无法在链中向上切换。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">print_line(__LINE__);<br>cout &lt;&lt; &quot;Perform modulus switching on encrypted and print.&quot; &lt;&lt; endl;<br>context_data = context.first_context_data();<br>cout &lt;&lt; &quot;----&gt;&quot;;<br><span class="hljs-keyword">while</span> (context_data-&gt;next_context_data())<br>&#123;<br>    cout &lt;&lt; &quot; Level (chain index): &quot; &lt;&lt; context_data-&gt;chain_index() &lt;&lt; endl;<br>    cout &lt;&lt; &quot;      parms_id of encrypted: &quot; &lt;&lt; <span class="hljs-keyword">encrypted</span>.parms_id() &lt;&lt; endl;<br>    cout &lt;&lt; &quot;      Noise budget at this level: &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot; &lt;&lt; endl;<br>    cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;<br>    cout &lt;&lt; &quot; \\--&gt;&quot;;<br>    evaluator.mod_switch_to_next_inplace(<span class="hljs-keyword">encrypted</span>);<br>    context_data = context_data-&gt;next_context_data();<br>&#125;<br>cout &lt;&lt; &quot; Level (chain index): &quot; &lt;&lt; context_data-&gt;chain_index() &lt;&lt; endl;<br>cout &lt;&lt; &quot;      parms_id of encrypted: &quot; &lt;&lt; <span class="hljs-keyword">encrypted</span>.parms_id() &lt;&lt; endl;<br>cout &lt;&lt; &quot;      Noise budget at this level: &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot; &lt;&lt; endl;<br>cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;<br>cout &lt;&lt; &quot; \\--&gt;&quot;;<br>cout &lt;&lt; &quot; End of chain reached&quot; &lt;&lt; endl &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz5xgnirdsj31980hwaut.jpg" /></p><p>正确解密</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">print_line(__LINE__);<br>cout &lt;&lt; &quot;Decrypt still works after modulus switching.&quot; &lt;&lt; endl;<br>decryptor.decrypt(<span class="hljs-keyword">encrypted</span>, plain);<br>cout &lt;&lt; &quot;    + Decryption of encrypted: &quot; &lt;&lt; plain.to_string();<br>cout &lt;&lt; &quot; ...... Correct.&quot; &lt;&lt; endl &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>好处：密文的大小线性取决于系数模数中素数的数量。因此，如果不需要或不打算对给定的密文执行任何进一步的计算，那么在将其发送回密钥持有者进行解密之前，我们不妨将其切换到链中的最小(最后的)参数集。<br></p><p>首先重新创建原始密文并执行计算</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">cout &lt;&lt; &quot;Computation is more efficient with modulus switching.&quot; &lt;&lt; endl;<br>print_line(__LINE__);<br>cout &lt;&lt; &quot;Compute the 8th power.&quot; &lt;&lt; endl;<br>encryptor.encrypt(plain, <span class="hljs-keyword">encrypted</span>);<br>cout &lt;&lt; &quot;    + Noise budget fresh:                   &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot;<br>     &lt;&lt; endl;<br>evaluator.square_inplace(<span class="hljs-keyword">encrypted</span>);<br>evaluator.relinearize_inplace(<span class="hljs-keyword">encrypted</span>, relin_keys);<br>cout &lt;&lt; &quot;    + Noise budget of the 2nd power:         &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot;<br>     &lt;&lt; endl;<br>evaluator.square_inplace(<span class="hljs-keyword">encrypted</span>);<br>evaluator.relinearize_inplace(<span class="hljs-keyword">encrypted</span>, relin_keys);<br>cout &lt;&lt; &quot;    + Noise budget of the 4th power:         &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot;<br>     &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>模数切换对噪声预算没有任何影响</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">evaluator.mod_switch_to_next_inplace(<span class="hljs-keyword">encrypted</span>);<br>cout &lt;&lt; &quot;    + Noise budget after modulus switching:  &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot;<br>     &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这意味着在做足够的计算后，降低一些系数模数没有任何坏处。在某些情况下，可能想要更早地切换到较低level，这牺牲了过程中的一些噪声预算，通过较小的参数获得计算性能。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">evaluator.square_inplace(<span class="hljs-keyword">encrypted</span>);<br>evaluator.relinearize_inplace(<span class="hljs-keyword">encrypted</span>, relin_keys);<br>cout &lt;&lt; &quot;    + Noise budget of the 8th power:         &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot;<br>     &lt;&lt; endl;<br>evaluator.mod_switch_to_next_inplace(<span class="hljs-keyword">encrypted</span>);<br>cout &lt;&lt; &quot;    + Noise budget after modulus switching:  &quot; &lt;&lt; decryptor.invariant_noise_budget(<span class="hljs-keyword">encrypted</span>) &lt;&lt; &quot; bits&quot;<br>     &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>密文仍然可以正确解密，它的大小是非常小的，计算高效。解密器可以用于解密在模数转换链上任何level的密文</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">decryptor.decrypt(<span class="hljs-keyword">encrypted</span>, plain);<br>cout &lt;&lt; &quot;    + Decryption of the 8th power (hexadecimal) ...... Correct.&quot; &lt;&lt; endl;<br>cout &lt;&lt; &quot;    &quot; &lt;&lt; plain.to_string() &lt;&lt; endl &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>在BFV中，模数切换是不必呀的，某些情况下，除了最高两个级别，用户可能不希望创建模数转换链，可以通过SEALContext设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">context</span> = SEALContext(parms, <span class="hljs-literal">false</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>检查是否只有最高两个level</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;Optionally disable modulus switching chain expansion.&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Print the modulus switching chain.&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;----&gt;&quot;</span>;<br><span class="hljs-keyword">for</span> (context_data = context.<span class="hljs-built_in">key_context_data</span>(); context_data; context_data = context_data-&gt;<span class="hljs-built_in">next_context_data</span>())<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot; Level (chain index): &quot;</span> &lt;&lt; context_data-&gt;<span class="hljs-built_in">chain_index</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;      parms_id: &quot;</span> &lt;&lt; context_data-&gt;<span class="hljs-built_in">parms_id</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;      coeff_modulus primes: &quot;</span>;<br>    cout &lt;&lt; hex;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;prime : context_data-&gt;<span class="hljs-built_in">parms</span>().<span class="hljs-built_in">coeff_modulus</span>())<br>    &#123;<br>        cout &lt;&lt; prime.<span class="hljs-built_in">value</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; dec &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\\&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot; \\--&gt;&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot; End of chain reached&quot;</span> &lt;&lt; endl &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gz5xl7lz8mj31810bk7hp.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>SEAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEAL</tag>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2_encoders</title>
    <link href="/2022/02/07/2_encoders/"/>
    <url>/2022/02/07/2_encoders/</url>
    
    <content type="html"><![CDATA[<h1 id="batchencoder">1.BatchEncoder</h1><p>设N为poly_modulus_degree，T为plain_modulus。批处理将BFV明文多项式视为2×(N/2)矩阵，每个元素都是一个模T整数。在矩阵视图中，加密操作在加密矩阵上逐个执行element-wise。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">EncryptionParameters parms(scheme_type::bfv);<br>size_t poly_modulus_degree = <span class="hljs-number">8192</span>;<br>parms.set<span class="hljs-constructor">_poly_modulus_degree(<span class="hljs-params">poly_modulus_degree</span>)</span>;<br>parms.set<span class="hljs-constructor">_coeff_modulus(CoeffModulus::BFVDefault(<span class="hljs-params">poly_modulus_degree</span>)</span>);<br></code></pre></td></tr></table></figure><p>为了启用批处理，我们需要将plain_modulus设置为一个素数，它全等于1模2*oly_modulus_degree，SEAL提供了一种辅助方法来查找这样一个素数。在本例中我们创建了一个支持批处理的20位素数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">parms.set<span class="hljs-constructor">_plain_modulus(PlainModulus::Batching(<span class="hljs-params">poly_modulus_degree</span>, 20)</span>);<br><br>SEALContext context(parms);<br>print<span class="hljs-constructor">_parameters(<span class="hljs-params">context</span>)</span>;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>可以通过查看由SEALContext创建的加密参数限定符来验证是否启用了批处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> qualifiers = context.<span class="hljs-built_in">first_context_data</span>()-&gt;<span class="hljs-built_in">qualifiers</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;Batching enabled: &quot;</span> &lt;&lt; boolalpha &lt;&lt; qualifiers.using_batching &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>生成密钥对、加密/解密/评估器 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">KeyGenerator keygen(context);<br>SecretKey secret_key = keygen.secret<span class="hljs-constructor">_key()</span>;<br>PublicKey public_key;<br>keygen.create<span class="hljs-constructor">_public_key(<span class="hljs-params">public_key</span>)</span>;<br>RelinKeys relin_keys;<br>keygen.create<span class="hljs-constructor">_relin_keys(<span class="hljs-params">relin_keys</span>)</span>;<br>Encryptor encryptor(context, public_key);<br>Evaluator evaluator(context);<br>Decryptor decryptor(context, secret_key);<br></code></pre></td></tr></table></figure></p><p>生成批处理编码类实例 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BatchEncoder batch<span class="hljs-constructor">_encoder(<span class="hljs-params">context</span>)</span>;<br></code></pre></td></tr></table></figure></p><p>批处理slot的总数等于poly_modulus_degree，N，这些slot被组织为2×(N/2)矩阵，可以对其进行加密和计算。每个slot都包含一个整数模plain_modulus。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">size_t</span> slot_count = batch_encoder.<span class="hljs-built_in">slot_count</span>();<br><span class="hljs-keyword">size_t</span> row_size = slot_count / <span class="hljs-number">2</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Plaintext matrix row size: &quot;</span> &lt;&lt; row_size &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>矩阵明文被简单地作为一个扁平的数字向量提供给BatchEncoder。'row_size'最多的组成第一行，其余组成第二行。我们创建如下矩阵：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, ...,  <span class="hljs-number">0</span> ]<br>[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, ...,  <span class="hljs-number">0</span> ]<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vector</span>&lt;uint<span class="hljs-number">64</span>_t&gt; pod_matrix(slot_count, <span class="hljs-number">0</span>ULL);<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size] = <span class="hljs-number">4</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size + <span class="hljs-number">1</span>] = <span class="hljs-number">5</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size + <span class="hljs-number">2</span>] = <span class="hljs-number">6</span>ULL;<br><span class="hljs-attribute">pod_matrix</span>[row_size + <span class="hljs-number">3</span>] = <span class="hljs-number">7</span>ULL;<br><br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;Input plaintext matrix:&quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">print_matrix</span>(pod_matrix, row_size);<br></code></pre></td></tr></table></figure><p>首先使用BatchEncoder将矩阵编码为明文多项式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Plaintext plain_matrix;<br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Encode plaintext matrix:&quot;</span> &lt;&lt; endl;<br>batch_encoder.<span class="hljs-built_in">encode</span>(pod_matrix, plain_matrix);<br></code></pre></td></tr></table></figure><p>解码，验证编码正确性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">uint64_t</span>&gt; pod_result;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Decode plaintext matrix ...... Correct.&quot;</span> &lt;&lt; endl;<br>batch_encoder.<span class="hljs-built_in">decode</span>(plain_matrix, pod_result);<br><span class="hljs-built_in">print_matrix</span>(pod_result, row_size);<br><br></code></pre></td></tr></table></figure><p>加密编码明文</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Ciphertext encrypted_matrix;<br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Encrypt plain_matrix to encrypted_matrix.&quot;</span> &lt;&lt; endl;<br>encryptor.<span class="hljs-built_in">encrypt</span>(plain_matrix, encrypted_matrix);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Noise budget in encrypted_matrix: &quot;</span> &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(encrypted_matrix) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>对密文的操作是在所有8192个slot中同时执行的同态操作。为了说明这一点，构造以下明文矩阵：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>, ..., <span class="hljs-number">2</span> ]<br>[ <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>, ..., <span class="hljs-number">2</span> ]<br></code></pre></td></tr></table></figure><p>将其编码为明文</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">uint64_t</span>&gt; pod_matrix2;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; slot_count; i++)<br>&#123;<br>    pod_matrix2.<span class="hljs-built_in">push_back</span>((i &amp; <span class="hljs-built_in">size_t</span>(<span class="hljs-number">0x1</span>)) + <span class="hljs-number">1</span>);<br>&#125;<br>Plaintext plain_matrix2;<br>batch_encoder.<span class="hljs-built_in">encode</span>(pod_matrix2, plain_matrix2);<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Second input plaintext matrix:&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print_matrix</span>(pod_matrix2, row_size);<br></code></pre></td></tr></table></figure><p>将第二个明文矩阵与加密矩阵相加，并对和执行平方操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Sum, square, and relinearize.&quot;</span> &lt;&lt; endl;<br>evaluator.add<span class="hljs-constructor">_plain_inplace(<span class="hljs-params">encrypted_matrix</span>, <span class="hljs-params">plain_matrix2</span>)</span>;<br>evaluator.square<span class="hljs-constructor">_inplace(<span class="hljs-params">encrypted_matrix</span>)</span>;<br>evaluator.relinearize<span class="hljs-constructor">_inplace(<span class="hljs-params">encrypted_matrix</span>, <span class="hljs-params">relin_keys</span>)</span>;<br></code></pre></td></tr></table></figure><p>查看剩余噪声预算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;    + Noise budget in result: &quot;</span> &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(encrypted_matrix) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>解密并解码以恢复明文结果(矩阵)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Plaintext plain_result;<br>print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Decrypt and decode result.&quot;</span> &lt;&lt; endl;<br>decryptor.decrypt(encrypted_matrix, plain_result);<br>batch_encoder.decode(plain_result, pod_result);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Result plaintext matrix ...... Correct.&quot;</span> &lt;&lt; endl;<br>print<span class="hljs-constructor">_matrix(<span class="hljs-params">pod_result</span>, <span class="hljs-params">row_size</span>)</span>;<br></code></pre></td></tr></table></figure><p>当所需的加密计算高度可并行化时，批处理允许我们有效地使用全明文多项式。但是，他并没有解决数据类型溢出问题(除非明文模数非常大)。CKKSEncoder解决了该问题，但代价是只能得到近似的结果。</p><h1 id="ckksencoder">2.CKKSEncoder</h1><p>首先为CKKS方案创建加密参数，与BFV方案相比，有两个重要的区别：<br> (1)CKKS不使用plain_modulus参数<br> (2)在使用CKKS方案时，以特定的方式选择coeff_modulus是非常重要的<br> 在本例中，使用CoeffModulus::Create生成5个40位素数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EncryptionParameters</span> parms(scheme_type::ckks);<br><br><span class="hljs-attribute">size_t</span> poly_modulus_degree = <span class="hljs-number">8192</span>;<br><span class="hljs-attribute">parms</span>.set_poly_modulus_degree(poly_modulus_degree);<br><span class="hljs-attribute">parms</span>.set_coeff_modulus(CoeffModulus::Create(poly_modulus_degree, &#123; <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span> &#125;));<br></code></pre></td></tr></table></figure><p>创建SEALContext实例</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SEALContext context(parms)<span class="hljs-comment">;</span><br>print_parameters(context)<span class="hljs-comment">;</span><br>cout &lt;&lt; endl<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>创建密钥对、加密/解密/评估器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">KeyGenerator <span class="hljs-title">keygen</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-keyword">auto</span> secret_key = keygen.<span class="hljs-built_in">secret_key</span>();<br>PublicKey public_key;<br>keygen.<span class="hljs-built_in">create_public_key</span>(public_key);<br>RelinKeys relin_keys;<br>keygen.<span class="hljs-built_in">create_relin_keys</span>(relin_keys);<br><br><span class="hljs-function">Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">(context, public_key)</span></span>;<br><span class="hljs-function">Evaluator <span class="hljs-title">evaluator</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-function">Decryptor <span class="hljs-title">decryptor</span><span class="hljs-params">(context, secret_key)</span></span>;<br></code></pre></td></tr></table></figure><p>要创建CKKS明文，需要一个特殊的编码器。CKKSEncoder将实数或复数的向量编码成明文对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CKKSEncoder encoder(context)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>在CKKS中，slot的数量是poly_modulus_degree/2，每个slot编码一个实数或复数(而在BatchEncoder中slot的数量等于poly_modulus_degree)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">size_t</span> slot_count = encoder.<span class="hljs-built_in">slot_count</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;Number of slots: &quot;</span> &lt;&lt; slot_count &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>创建一个小向量进行编码，在编码时，CKKSEncoder将隐式地用0填充</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vector</span>&lt;double&gt; input&#123; <span class="hljs-number">0</span>.<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.<span class="hljs-number">1</span>, <span class="hljs-number">2</span>.<span class="hljs-number">2</span>, <span class="hljs-number">3</span>.<span class="hljs-number">3</span> &#125;;<br><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&quot;Input vector: &quot;</span> &lt;&lt; endl;<br><span class="hljs-attribute">print_vector</span>(input);<br></code></pre></td></tr></table></figure><p>使用CKKSEncoder编码，输入的浮点系数将由参数scale放大。这是必须的，因为即使是在CKKS方案中，明文元素基本上也是整系数多项式。scale决定了编码的位精度，这影响了结果的准确性。在CKKS中，消息模coeff_modulus后存储(在BFV中，消息模plain_modulu存储)，因此缩放后的消息不能太接近coeff_modulu。在这种情况下，coeff_modulus相当大(218位)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Plaintext plain;<br><span class="hljs-keyword">double</span> scale = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">30</span>);<br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Encode input vector.&quot;</span> &lt;&lt; endl;<br>encoder.<span class="hljs-built_in">encode</span>(input, scale, plain);<br><br></code></pre></td></tr></table></figure><p>解码，检验编码正确性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">double</span>&gt; output;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + Decode input vector ...... Correct.&quot;</span> &lt;&lt; endl;<br>encoder.<span class="hljs-built_in">decode</span>(plain, output);<br><span class="hljs-built_in">print_vector</span>(output);<br></code></pre></td></tr></table></figure><p>加密(与BFV类似)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Ciphertext <span class="hljs-keyword">encrypted</span>;<br>print_line(__LINE__);<br>cout &lt;&lt; &quot;Encrypt input vector, square, and relinearize.&quot; &lt;&lt; endl;<br>encryptor.encrypt(plain, <span class="hljs-keyword">encrypted</span>);<br></code></pre></td></tr></table></figure><p>对密文的基本操作仍然是容易的。本例中我们对密文进行了平方、解密、解码操作，并打印了结果。注意，由于隐式补零，encoding返回一个full size(poly_modulus_degree/2)向量。结果中的scale变为原始scale的平方。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">evaluator.square_inplace(<span class="hljs-keyword">encrypted</span>);<br>evaluator.relinearize_inplace(<span class="hljs-keyword">encrypted</span>, relin_keys);<br><br><br>cout &lt;&lt; &quot;    + Scale in squared input: &quot; &lt;&lt; <span class="hljs-keyword">encrypted</span>.scale() &lt;&lt; &quot; (&quot; &lt;&lt; log2(<span class="hljs-keyword">encrypted</span>.scale()) &lt;&lt; &quot; bits)&quot;<br>     &lt;&lt; endl;<br><br>print_line(__LINE__);<br>cout &lt;&lt; &quot;Decrypt and decode.&quot; &lt;&lt; endl;<br>decryptor.decrypt(<span class="hljs-keyword">encrypted</span>, plain);<br>encoder.decode(plain, output);<br>cout &lt;&lt; &quot;    + Result vector ...... Correct.&quot; &lt;&lt; endl;<br>print_vector(output);<br></code></pre></td></tr></table></figure><p>CKKS方案允许在加密计算之间减少scale。</p>]]></content>
    
    
    <categories>
      
      <category>SEAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEAL</tag>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1_bfv_basics</title>
    <link href="/2022/02/06/1_bfv_basics/"/>
    <url>/2022/02/06/1_bfv_basics/</url>
    
    <content type="html"><![CDATA[<h1 id="bfv源码分析">BFV源码分析</h1><h2 id="设置encryptionparameters类实例">1.设置EncryptionParameters类实例</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">EncryptionParameters parms(scheme_type::bfv);<br><br>size_t poly_modulus_degree = <span class="hljs-number">8192</span>;<br>parms.set<span class="hljs-constructor">_poly_modulus_degree(<span class="hljs-params">poly_modulus_degree</span>)</span>;<br><br>parms.set<span class="hljs-constructor">_coeff_modulus(CoeffModulus::BFVDefault(<span class="hljs-params">poly_modulus_degree</span>)</span>);<br><br>parms.set<span class="hljs-constructor">_plain_modulus(2048)</span>;<br></code></pre></td></tr></table></figure><ul><li>poly_modulus_degree(多项式模数)：2的正幂，表示分圆多项式的degree。值越大则密文大小越大，导致所有操作更慢但能够实现更加复杂的加密计算，推荐值为1024/2048/4096/8192/16384/32768或更大</li><li>coeff_modulus([密文]系数模数)：不同质数的乘积，每个质数最多60位。其位长是指其质因数位长之和，值越大噪声预算越大，意味着更强的加密计算能力，总位长受到poly_modulus_degree限制</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+---------------------+---------------------------- ---+<br>|<span class="hljs-string"> poly_modulus_degree </span>|<span class="hljs-string"> 最大 coeff_modulus 位长 </span>|<br>+---------------------+---------------------------- ---+<br>|<span class="hljs-string"> 1024  </span>|<span class="hljs-string">  27 </span>|<br>|<span class="hljs-string"> 2048  </span>|<span class="hljs-string">  54 </span>|<br>|<span class="hljs-string"> 4096  </span>|<span class="hljs-string"> 109 </span>|<br>|<span class="hljs-string"> 8192  </span>|<span class="hljs-string"> 218 </span>|<br>|<span class="hljs-string"> 16384 </span>|<span class="hljs-string"> 438 </span>|<br>|<span class="hljs-string"> 32768 </span>|<span class="hljs-string"> 881 </span>|<br>+---------------------+---------------------------- ---+<br></code></pre></td></tr></table></figure><ul><li>plain_modulus(明文模数，仅适用于BFV方案)：可以是任意正整数。它决定了明文数据类型的大小和乘法中噪声预算的消耗，因此必须尽量保持明文数据类型尽可能小。</li></ul><p>新加密密文的噪声预算：~<span class="math inline">\(log_{2}(coeff\_modulus/plain\_modulus)\)</span>(位)<br> 同态乘法的噪声预算消耗为<span class="math inline">\(log_{2}(plain\_modulus)+(other\ terms)\)</span>.<br></p><h2 id="构造sealcontext对象">2. 构造SEALContext对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SEALContext <span class="hljs-title">context</span><span class="hljs-params">(parms)</span></span>;<br><br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Set encryption parameters and print&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">print_parameters</span>(context);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Parameter validation (success): &quot;</span> &lt;&lt; context.<span class="hljs-built_in">parameter_error_message</span>() &lt;&lt; endl;<br><br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;~~~~~~ A naive way to calculate 4(x^2+1)(x+1)^2. ~~~~~~&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="设置keygenerator类实例">3. 设置KeyGenerator类实例</h2><p>用于生成公私钥对 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">KeyGenerator keygen(context)<span class="hljs-comment">;</span><br>SecretKey secret_key = keygen.secret_key()<span class="hljs-comment">;</span><br>PublicKey public_key<span class="hljs-comment">;</span><br>keygen.create_public_key(public_key)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></p><h2 id="设置encryptorevaluatordecryptor类实例">4. 设置Encryptor/Evaluator/Decryptor类实例</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">(context, public_key)</span></span>;   <br><span class="hljs-function">Evaluator <span class="hljs-title">evaluator</span><span class="hljs-params">(context)</span></span>;<br><span class="hljs-function">Decryptor <span class="hljs-title">decryptor</span><span class="hljs-params">(context, secret_key)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="示例">5.示例</h2><p>对于加密的x=6，计算<span class="math inline">\(4x^{4}+8x^{3}+8x^{2}+8x+4\)</span><br></p><p>首先创建一个包含常数6的明文。对于明文元素，使用构造函数将所需的多项式作为一个字符串，其系数表示为十六进制数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br><span class="hljs-built_in">int</span> x = <span class="hljs-number">6</span>;<br>Plaintext x<span class="hljs-constructor">_plain(<span class="hljs-params">to_string</span>(<span class="hljs-params">x</span>)</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;Express x = &quot;</span> + <span class="hljs-keyword">to</span><span class="hljs-constructor">_string(<span class="hljs-params">x</span>)</span> +<br>    <span class="hljs-string">&quot; as a plaintext polynomial 0x&quot;</span> + x_plain.<span class="hljs-keyword">to</span><span class="hljs-constructor">_string()</span> + <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>然后对明文进行加密，生成密文</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">print_line</span>(__LINE__);<br>Ciphertext x_encrypted;<br>cout &lt;&lt; <span class="hljs-string">&quot;Encrypt x_plain to x_encrypted.&quot;</span> &lt;&lt; endl;<br>encryptor.<span class="hljs-built_in">encrypt</span>(x_plain, x_encrypted);<br></code></pre></td></tr></table></figure><p>在SEAL中，一个有效的密文由两个或多个多项式组成，它们的系数是整数mod(在coeff_modulus中素数的乘积)。密文中多项式的个数称为它的"size"，由Ciphertext::size()给出。新加密的密文size总是2.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">cout &lt;&lt; <span class="hljs-string">&quot;    + size of freshly encrypted x: &quot;</span> &lt;&lt; x_encrypted.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">There is plenty of noise budget left in this freshly encrypted ciphertext.</span><br><span class="hljs-comment">*/</span><br>cout &lt;&lt; <span class="hljs-string">&quot;    + noise budget in freshly encrypted x: &quot;</span><br>    &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(x_encrypted) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">We decrypt the ciphertext and print the resulting plaintext in order to</span><br><span class="hljs-comment">demonstrate correctness of the encryption.</span><br><span class="hljs-comment">*/</span><br>Plaintext x_decrypted;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + decryption of x_encrypted: &quot;</span>;<br>decryptor.<span class="hljs-built_in">decrypt</span>(x_encrypted, x_decrypted);<br>cout &lt;&lt; <span class="hljs-string">&quot;0x&quot;</span> &lt;&lt; x_decrypted.<span class="hljs-built_in">to_string</span>() &lt;&lt; <span class="hljs-string">&quot; ...... Correct.&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>当使用SEAL时，以最小化最长的顺序乘法链的方式进行计算通常是有利的。换句话说，加密计算最好以最小化计算乘法深度的方式进行评估，因为总噪声预算消耗与乘法深度成正比。例如，在计算给定多项式时，因式分解多项式是有利的：<br></p><p><span class="math inline">\(4x^{4}+8x^{3}+8x^{2}+8x+4=4(x+1)^{2}*(x^{2}+1)\)</span><br></p><p>因此我们可以分别计算<span class="math inline">\(x^{2}+1\)</span>和<span class="math inline">\((x+1)^{2}\)</span>，再将其相乘，最后乘上一个明文'4'.<br></p><p>首先计算<span class="math inline">\(x^{2}\)</span>，并加上一个明文'1'.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute x_sq_plus_one (x^2+1).&quot;</span> &lt;&lt; endl;<br>Ciphertext x_sq_plus_one;  <span class="hljs-comment">//把密文记作x_sq_plus_one</span><br>evaluator.square(x_encrypted, x_sq_plus_one); <br> <span class="hljs-comment">//先利用内置函数square ,平方x_encrypted,刷新入x_sq_plus_one</span><br>Plaintext plain<span class="hljs-constructor">_one(<span class="hljs-string">&quot;1&quot;</span>)</span>;  <span class="hljs-comment">//添加明文 1</span><br>evaluator.add<span class="hljs-constructor">_plain_inplace(<span class="hljs-params">x_sq_plus_one</span>, <span class="hljs-params">plain_one</span>)</span>;<br><span class="hljs-comment">//利用内置函数密文加  </span><br></code></pre></td></tr></table></figure><p>再计算<span class="math inline">\((x+1)^{2}\)</span></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute x_plus_one_sq ((x+1)^2).&quot;</span> &lt;&lt; endl;<br>Ciphertext x_plus_one_sq;<br>evaluator.add<span class="hljs-constructor">_plain(<span class="hljs-params">x_encrypted</span>, <span class="hljs-params">plain_one</span>, <span class="hljs-params">x_plus_one_sq</span>)</span>;<br>evaluator.square<span class="hljs-constructor">_inplace(<span class="hljs-params">x_plus_one_sq</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + size of x_plus_one_sq: &quot;</span> &lt;&lt; x_plus_one_sq.size<span class="hljs-literal">()</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + noise budget in x_plus_one_sq: &quot;</span> &lt;&lt; decryptor.invariant<span class="hljs-constructor">_noise_budget(<span class="hljs-params">x_plus_one_sq</span>)</span> &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + decryption of x_plus_one_sq: &quot;</span>;<br>decryptor.decrypt(x_plus_one_sq, decrypted_result);<br>cout &lt;&lt; <span class="hljs-string">&quot;0x&quot;</span> &lt;&lt; decrypted_result.<span class="hljs-keyword">to</span><span class="hljs-constructor">_string()</span> &lt;&lt; <span class="hljs-string">&quot; ...... Correct.&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>最后计算<span class="math inline">\(4(x+1)^{2}*(x^{2}+1)\)</span></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute encrypted_result (4(x^2+1)(x+1)^2).&quot;</span> &lt;&lt; endl;<br>Ciphertext encrypted_result;<br><span class="hljs-function">Plaintext <span class="hljs-title">plain_four</span><span class="hljs-params">(<span class="hljs-string">&quot;4&quot;</span>)</span></span>;<br>evaluator.<span class="hljs-built_in">multiply_plain_inplace</span>(x_sq_plus_one, plain_four);<br>evaluator.<span class="hljs-built_in">multiply</span>(x_sq_plus_one, x_plus_one_sq, encrypted_result);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + size of encrypted_result: &quot;</span> &lt;&lt; encrypted_result.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + noise budget in encrypted_result: &quot;</span> &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(encrypted_result) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;NOTE: Decryption can be incorrect if noise budget is zero.&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;~~~~~~ A better way to calculate 4(x^2+1)(x+1)^2. ~~~~~~&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>当噪声预算达到0，则意味着不能期望解密给出正确的结果。在上述计算方法中，由于密文x_sq_plus_one和x_plus_one_sq都由三个多项式组成(这是由平方运算造成的)，对大密文的同态运算比小密文的计算消耗更多的噪声预算。<br></p><p>"Relinearization"是一种将密文的size刷新为初始size(2)的一种操作。因此，在下一次乘法之前对密文进行重新线性化操作，可以降低噪声增长，优化性能。"Relinearization"需要特殊的"Relinearization密钥"，可以将其视为一种公钥，使用KeyGenerator生成。在BFV和CKKS方案中都有类似用到。<br></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//生成Relinearation密钥</span><br>print<span class="hljs-constructor">_line(<span class="hljs-params">__LINE__</span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Generate relinearization keys.&quot;</span> &lt;&lt; endl;<br>RelinKeys relin_keys;<br>keygen.create<span class="hljs-constructor">_relin_keys(<span class="hljs-params">relin_keys</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute and relinearize x_squared (x^2),&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">string</span>(<span class="hljs-number">13</span>, <span class="hljs-string">&#x27; &#x27;</span>) &lt;&lt; <span class="hljs-string">&quot;then compute x_sq_plus_one (x^2+1)&quot;</span> &lt;&lt; endl;<br>Ciphertext x_squared;<br>evaluator.<span class="hljs-built_in">square</span>(x_encrypted, x_squared);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + size of x_squared: &quot;</span> &lt;&lt; x_squared.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>evaluator.<span class="hljs-built_in">relinearize_inplace</span>(x_squared, relin_keys);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + size of x_squared (after relinearization): &quot;</span> &lt;&lt; x_squared.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>evaluator.<span class="hljs-built_in">add_plain</span>(x_squared, plain_one, x_sq_plus_one);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + noise budget in x_sq_plus_one: &quot;</span> &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(x_sq_plus_one) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + decryption of x_sq_plus_one: &quot;</span>;<br>decryptor.<span class="hljs-built_in">decrypt</span>(x_sq_plus_one, decrypted_result);<br>cout &lt;&lt; <span class="hljs-string">&quot;0x&quot;</span> &lt;&lt; decrypted_result.<span class="hljs-built_in">to_string</span>() &lt;&lt; <span class="hljs-string">&quot; ...... Correct.&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">print_line</span>(__LINE__);<br>Ciphertext x_plus_one;<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute x_plus_one (x+1),&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">string</span>(<span class="hljs-number">13</span>, <span class="hljs-string">&#x27; &#x27;</span>) &lt;&lt; <span class="hljs-string">&quot;then compute and relinearize x_plus_one_sq ((x+1)^2).&quot;</span> &lt;&lt; endl;<br>evaluator.<span class="hljs-built_in">add_plain</span>(x_encrypted, plain_one, x_plus_one);<br>evaluator.<span class="hljs-built_in">square</span>(x_plus_one, x_plus_one_sq);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + size of x_plus_one_sq: &quot;</span> &lt;&lt; x_plus_one_sq.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>evaluator.<span class="hljs-built_in">relinearize_inplace</span>(x_plus_one_sq, relin_keys);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + noise budget in x_plus_one_sq: &quot;</span> &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(x_plus_one_sq) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + decryption of x_plus_one_sq: &quot;</span>;<br>decryptor.<span class="hljs-built_in">decrypt</span>(x_plus_one_sq, decrypted_result);<br>cout &lt;&lt; <span class="hljs-string">&quot;0x&quot;</span> &lt;&lt; decrypted_result.<span class="hljs-built_in">to_string</span>() &lt;&lt; <span class="hljs-string">&quot; ...... Correct.&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">print_line</span>(__LINE__);<br>cout &lt;&lt; <span class="hljs-string">&quot;Compute and relinearize encrypted_result (4(x^2+1)(x+1)^2).&quot;</span> &lt;&lt; endl;<br>evaluator.<span class="hljs-built_in">multiply_plain_inplace</span>(x_sq_plus_one, plain_four);<br>evaluator.<span class="hljs-built_in">multiply</span>(x_sq_plus_one, x_plus_one_sq, encrypted_result);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + size of encrypted_result: &quot;</span> &lt;&lt; encrypted_result.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>evaluator.<span class="hljs-built_in">relinearize_inplace</span>(encrypted_result, relin_keys);<br>cout &lt;&lt; <span class="hljs-string">&quot;    + size of encrypted_result (after relinearization): &quot;</span> &lt;&lt; encrypted_result.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;    + noise budget in encrypted_result: &quot;</span> &lt;&lt; decryptor.<span class="hljs-built_in">invariant_noise_budget</span>(encrypted_result) &lt;&lt; <span class="hljs-string">&quot; bits&quot;</span><br>     &lt;&lt; endl;<br><br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;NOTE: Notice the increase in remaining noise budget.&quot;</span> &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure><h1 id="主流fhe方案比较">主流FHE方案比较</h1><p>1.FHEW/TFHE/GSW</p><ul><li>快速比较</li><li>支持任意布尔电路</li><li>快速bootstrapping(噪声刷新过程，减少因密文计算而产生的噪声，降低失败的可能性)</li></ul><p>2.BGV/BFV</p><ul><li>在整数向量上进行高效的SIMD计算(使用批处理)</li><li>快速高精度整数算术</li><li>快速向量的标量乘法</li><li>Leveled design(通常不使用bootstrapping)</li></ul><p>3.CKKS</p><ul><li>快速多项式近似计算</li><li>相对快速的倒数和离散傅里叶变换</li><li>深度近似计算，如逻辑回归学习</li><li>在实数向量上进行高效的SIMD计算(使用批处理)</li><li>Leveled design(通常不使用bootstrapping)</li></ul><hr /><p>参考：</p><p><a href="https://blog.csdn.net/ldxcsdn/category_11390861.html" class="uri">https://blog.csdn.net/ldxcsdn/category_11390861.html</a></p>]]></content>
    
    
    <categories>
      
      <category>SEAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEAL</tag>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCS18</title>
    <link href="/2022/02/02/CCS18/"/>
    <url>/2022/02/02/CCS18/</url>
    
    <content type="html"><![CDATA[<center><big>Secure Search on Encrypted Data via Multi-Ring Sketch</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  我们考虑这样一个安全检索问题，从一个无序数据<span class="math inline">\(array=(x_{1},...,x_{m})\)</span>中检索一个满足给定值<span class="math inline">\(\mathcal{l}\)</span>的元素<span class="math inline">\((i,x_{i})\)</span>，其中输入和输出都是全同态加密的。该安全检索问题在安全外包给不受信任方(云)的应用中处于核心地位。先前在FHE加密数据上的安全检索算法需要次数<span class="math inline">\(\Omega(m)\)</span>的多项式实现，在<span class="math inline">\(\Omega(log\ m)\)</span>序列同态乘法步骤下评估(即乘法深度)，即使有无限的并行处理器。在现在FHE实现中，这对于即使是中等大小m的数组来说，例如几千，也太慢了。<br></p><p>  我们提出了第一个安全搜索算法，该算法由一个对数多项式实现，使用m个并行处理器在<span class="math inline">\(O(log\ log\ m)\)</span>个顺序同态乘法步骤(即乘法深度)中进行评估。我们在基于HElib的开源库中实现了我们的算法，并在亚马逊的EC2云上运行了多达100个处理器的实验。我们的实验表明，在标准的EC2 64核机器上，我们可以在不到一个小时的时间内安全地搜索m =数百万个条目。<br></p><p>  我们通过以下方式实现我们的结果:(1)使用称为sketch化的现代数据汇总技术，用于将短sketch C(的加密)作为输出返回，对于短sketch C，其匹配项<span class="math inline">\((i,x_{i})\)</span>可以与计算多对数解加密/加密操作成比例地被及时解码。(2)为此设计一个新的sketch，返回非负实数(不一定稀疏)数组中的第一个严格正条目；这个sketch可能是独立的。(3)建议对FHE进行多环评估，以便将度数从线性减少到对数。<br></p><p><strong>CCS概念</strong><br></p><ul><li>安全与隐私→公钥加密；</li></ul><p><strong>关键词</strong><br></p><p>  安全搜索;全同态加密;同态加密;sketch;低次多项式;第一正sketch</p><h1 id="介绍">1. 介绍</h1><p>  随着越来越多的组织和个人(客户端)将存储和计算外包给通常称为“云”(服务器)的大型第三方系统，存储和计算正迅速成为一种商品。通常这需要客户端向服务器公开其私有记录，以便服务器能够为客户端运行计算。随着电子邮件、医疗、金融和其他个人信息转移到云中，在保证数据可用性的同时保证隐私至关重要。<br></p><p>  全同态加密(FHE)是一种加密方案，由于其能够对加密数据进行计算的特殊属性，有助于计算的安全外包；具体来说，FHE允许在加密输入(密文)上计算任何算法，不需要解密或访问会破坏保密性的密钥，但成功地返回了所需结果的加密。<br></p><p>  使用FHE的安全计算外包在概念上很简单:客户端发送加密输入x的密文<span class="math inline">\([x]\)</span>，接收加密输出<span class="math inline">\(y=f(x)\)</span>的密文<span class="math inline">\([y]\)</span>，其中计算在服务器端完成，不需要与客户端进行进一步的交互。这提供了一个具有较低通信量的单轮协议；特别地，通信复杂度仅与输入和输出密文的大小成比例(与当使用现有的安全多方计算(MPC)技术时与计算f()的运行时间成比例的通信相反)。底层FHE加密的语义安全性确保了服务器不会从看到和处理密文中获知关于明文输入和输出的新信息。<br></p><p>  设计在用完全(或分级)同态加密(FHE)加密的数据上运行的算法的主要挑战是将它们的计算表示为低次多项式<span class="math inline">\(f()\)</span>，这样在输入x上，算法的输出是<span class="math inline">\(f(x)\)</span>。否则，导致高次多项式<span class="math inline">\(f()\)</span>的原始转换对于当前最先进的FHE实现通常是非常不切实际的，其中运行时间随着相应电路的次数和乘法深度而快速增长。<br></p><p>  自从Gentry的突破性成果构建了第一个FHE，<strong>使用FHE的安全搜索</strong>就成为了FHE应用的一个主要例子。我们考虑从未排序的数据<span class="math inline">\(array=(x_{1},...,x_{m})\)</span>中匹配给定值<span class="math inline">\(\mathcal{l}\)</span>(具有通用匹配标准，例如相等或相似性测试)的安全搜索问题，其中输入和输出都用全同态加密(FHE)加密。我们注意到，在从数据库中进行安全检索的上下文中，我们认为<span class="math inline">\(array\)</span>是数据库表(或特定列)，而<span class="math inline">\(\mathcal{l}\)</span>是查询。<br></p><p>  在安全外包的背景下，我们关注单轮协议和低通信，其中服务器除了接收加密输入和返回加密输出之外，不需要与客户端交互。<br></p><p>  <strong>定义1(安全搜索)。</strong><br>服务器保存加密值的无序数组(以前上传到服务器，并且服务器无法访问秘密解密密钥):<br></p><p>  <span class="math inline">\([array]=([x_{1}],...,[x_{m}])\)</span><br></p><p>(在这里和整个工作中，<span class="math inline">\([msg]\)</span>表示加密消息msg的密文；加密可以是任何完全或分级的同态加密(FHE)方案).客户端向服务器发送加密的查询<span class="math inline">\(\mathcal{l}\)</span>。服务器向客户端返回一个加密的索引和值:<br></p><p>  <span class="math inline">\([y]=([i],[x_{i}])\)</span><br></p><p>  满足条件:<span class="math inline">\(isMatch(x_{i},\mathcal{l})=1\)</span><br></p><p><span class="math inline">\(isMatch()\)</span>是指定搜索条件的一个谓词(参阅下方关于使用通用谓词的讨论)。此外，y可能是一个值(sketch)，客户端可以计算(编码的)<span class="math inline">\((i,x_{i})\)</span>。<br></p><p>  如果满足一下条件，则认为客户端/服务器端/协议是高效的:</p><ul><li>如果客户端的运行时间在计算底层FHE的<span class="math inline">\(|\mathcal{l}|\)</span>的加密和<span class="math inline">\(|(i,x_{i})|\)</span>，的解密的时间内是多项式的，则客户端是高效的(<span class="math inline">\(|\mathcal{l}|\)</span>和<span class="math inline">\(|(i,x_{i})|=log\ m+|x_{i}|\)</span>分别是输入和输出的比特形式长度)。</li><li>如果服务器端用于评估得到<span class="math inline">\([y]\)</span>的多项式<span class="math inline">\(f([array],[\mathcal{l}])\)</span>是<span class="math inline">\(log\ m\)</span>和<span class="math inline">\(isMatch()\)</span>的次数以及m上多项式的大小(即计算f的所有加法和乘法操作的次数)和<span class="math inline">\(isMatch\)</span>的大小上的次数多项式，则服务器端是高效的。</li><li>如果客户端和服务器端都是高效的，则协议是高效的。</li></ul><p>  如果运行时间/次数/二者都至少为<span class="math inline">\(\Omega(m)\)</span>，则称客户端/服务器端/协议是低效的。<br></p><p>  <strong>通用<span class="math inline">\(isMatch\)</span>谓词。</strong>定义1中的<span class="math inline">\(isMatch()\)</span>谓词是一个通用谓词，可以实例化为任何所需的功能(复杂性会因此受到影响，请参见定理2)。此外，通常可以使用简单的<span class="math inline">\(isMatch\)</span>规范，例如，由提供函数名称的客户端使用。例如，最常见的是，<span class="math inline">\(isMatch()\)</span>是一个通用电路，<span class="math inline">\(\mathcal{l}\)</span>是定义匹配值的谓词的完整规范。另外，给定一个更具体的实例化，我们可以扩展搜索查询来提供使用的特定<span class="math inline">\(isMatch()\)</span>电路的名称，从一组常见的选项中选择(例如，等式运算符、连接/析取查询、范围查询、相似性条件等)。更具体地说，我们可以预先确定一个特定的谓词，比如，<span class="math inline">\(isMatch(x_{i},\mathcal{l})=1\)</span>当且仅当<span class="math inline">\(x_{i}=\mathcal{l}\)</span>.我们的实验是后一种情况；尽管如此，我们的结果是一般性的，适用于任何一般的<span class="math inline">\(isMatch\)</span>条件(见定理2).<br></p><p>  先前的工作已经提供了一个工具箱，其中包含了FHE加密数据上<span class="math inline">\(isMatch\)</span>谓词的具体实例，包括例如用于计算Hamming和编辑距离的有效实现。这些工作侧重于给定两个值<span class="math inline">\(x_{i}\)</span>和<span class="math inline">\(\mathcal{l}\)</span>，有效计算<span class="math inline">\(isMatch\)</span>谓词。然后根据数据数组中是否存在匹配项来给出YES/NO的答案，或者返回长度为m的指示向量<span class="math inline">\(indicator=(isMatch(x_{1},\mathcal{l}),...,isMatch(x_{m},\mathcal{l}))\)</span>，它指示了每条记录<span class="math inline">\(x_{i}\)</span>是否是值<span class="math inline">\(\mathcal{l}\)</span>的一个匹配项。工作中，我们将重点放在检索匹配条目<span class="math inline">\((i,x_{i})\)</span>的补充问题上，同时将提供<span class="math inline">\(isMatch\)</span>标准。<br></p><p>  <strong>威胁模型。</strong>我们的协议实现的功能包含客户端的输入数组<span class="math inline">\((array,\mathcal{l})\)</span>；客户端输出检索记录<span class="math inline">\((i,x_{i})\)</span>；服务器端无共享参数的输入或输出，包括数据记录的数量、记录的大小和查询值等(参见图4)<br></p><p>  我们处理的敌手是计算受限的控制着服务器的半诚实敌手。也就是说，敌手遵循协议，但可能试图了解更多的信息。我们指出，没有必要考虑由对手控制客户端，因此服务器端没有输入/输出。<br></p><p>  我们的安全性要求是除了共享参数中显式泄露的信息之外，敌手不能从参与协议中了解任何信息。特别地，如果客户端选择两个大小相等的查询值(类似地，数据数组)，控制服务器的敌手无法区分它们。接下来介绍了FHE方案的语义安全性。<br></p><p>  在FHE加密的数据上的<strong>安全搜索的应用</strong>是十分丰富的，在将计算安全外包给不受信任的一方(“云”/服务器)的背景下，例子包括：</p><ul><li>从数据库中进行安全检索</li><li>在图像语料库的标签中进行安全搜索</li><li>在文本文档中进行安全搜索</li><li>在基因数据中进行安全搜索</li></ul><p>在所有应用中，查询值和数据(数据库，图像/标签，文本文档，基因数据)是由客户端预先加密然后送至服务器端的，以确保保密性。<br></p><p>  最相关的应用出现在数据预排序或预索引不可行的设置中，且使用了不考虑安全性的数据的线性扫描。这些是特别吸引人的情况，因为已知的下限需要线性扫描，以安全地搜索FHE加密的数据。这类应用程序出现在以下设置中：</p><ul><li>一个预先未知的匹配标准，如在索引不可行的特定SQL查询和我们的通用<span class="math inline">\(isMatch\)</span>谓词中；</li><li>通用匹配标准，要求索引大小和属性数量成指数关系，如对高维数据的范围查询；</li><li>流数据的每个元素加密上传到服务器后立即被客户端丢弃，从而不可能对整个明文数据进行预排序；</li><li>低容量的客户端，无法存储/排序清晰的文本数据，比如在物联网(IoT)设备中；</li><li>从多个不同的客户端(例如，代理/用户/设备)上传到服务器的碎片数据，没有一个单独的实体保存并可以预先排序整个纯文本数据。</li></ul><p>  文中 <strong>我们的主要动机</strong> 是肯定地回答以下问题：是否存在一个高效的安全搜索协议？</p><h2 id="相关工作">1.1 相关工作</h2><p>  安全搜索是一个被广泛研究的基础计算问题。我们调查了与我们搜索FHE加密数据的安全搜索公式(定义1)最相关的工作，包括1-轮通信协议、高效通信量、客户端和服务器端。<br></p><p>  <strong>安全双方计算(2PC)</strong> 允许两个参与方计算各自私人输入的任意(多项式次数计算)函数，交互协议除了可以从函数的输出中推断信息外，不显示任何其他信息。但是，这些解决方案的通信复杂度随着计算函数的复杂度而增长，而不是只与输入和输出的大小成比例。<br></p><p>  FHE加密数据上的计算解决了上述高通信警告，表明1轮低通信的安全双方计算在理论上是可行的(假设FHE具有语义安全性)。然而，这种FHE方法会导致很高的计算开销(尽管是多项式)。涉及得到合理的具体效率的协议在许多以前的工作中已经研究过；下面我们将讨论与安全搜索问题最相关的几个问题。<br></p><p>  对FHE加密数据进行安全搜索的自然解决方案存在这样一个问题：服务器评估次数为<span class="math inline">\(\Omega(m)\)</span>的多项式的效率很低，其中m是记录的数量(而不是我们需要的m的多重对数)。这对于当前的FHE方案和实现来说太慢了，即使是对于中等大小的m，比如几千。<br></p><p>  <strong>FHE加密数据上的安全模式匹配</strong> 是一个与安全搜索相关的问题。在这个问题中，向服务器提供加密的数据和加密的查询值。然后计算一个加密指引的数组，对于每一个数据元素<span class="math inline">\(x_{i}\)</span>指定它是否与查询值<span class="math inline">\(\mathcal{l}\)</span>相匹配：<br></p><p>  <span class="math inline">\([indicator]\gets([isMatch(x_{1},\mathcal{l})],...,[isMatch(x_{m},\mathcal{l})])\)</span><br></p><p>(其中匹配标准isMatch随着工作的不同而不同)。服务器将该数组indicator发送给客户端(或者在某些工作中，返回是否匹配的YES/NO的回答)。客户端解密并扫描该长度为m的指引数组来找出匹配项的索引。为了检索到记录本身，参与方可以使用私有信息检索(PIR)协议(参见下文)，这需要第二轮交互。<br></p><p>  在这些工作中，服务器是高效的，但客户端和通信量并不是：它们至少是记录数量<span class="math inline">\(\Omega(m)\)</span>上的线性(而不是我们需要的对数)。<br></p><p>  <strong>基于PIR的FHE上的唯一约束搜索。</strong></p><h1 id="数据设置和上传">2. 数据设置和上传</h1><p>  在本章中，我们设置如下符号；指定FHE方案的需求(2.1节)；指定我们的输入输出标准(2.2节)；提出数据上传协议(2.3节)。<br></p><p><strong>符号。</strong> 对于一个数据记录或查询值<span class="math inline">\(\mathcal{z}\)</span>，我们定义<span class="math inline">\(|\mathcal{z}|\)</span>为<span class="math inline">\(\mathcal{z}\)</span>的二进制表示的长度。对于整数<span class="math inline">\(\mathcal{m}\)</span>，我们定义<span class="math inline">\([m]=\{1,...,m\}\)</span>。数组索引从1开始，第i项为<span class="math inline">\(array(i)\)</span>。我们也使用符号<span class="math inline">\(array(b)\)</span>，其中<span class="math inline">\(b\)</span>是<span class="math inline">\(i\)</span>的二进制表示，指定数组的第i个元素。向量除非具体说明以外都是列向量。我们假设数组大小m是2的一个幂(不足位用0补齐)。对数除非具体说明以外都以2为底。</p><h2 id="我们的fhe黑盒使用">2.1 我们的FHE黑盒使用</h2><p>  全同态(或分级同态)加密(FHE)在本工作中是以黑盒方式使用的：我们要求黑盒使用FHE的标准算法(密钥生成、加密、解密和评估)。方案中我们制定的唯一要求是我们可以自己选择明文模数为素数p，从而使同态操作是模p加法或乘法。对于我们方案的安全性，要求语义安全。<br></p><p>  <strong>符号。</strong> 为了强调明文模数p，我们使用下列标准算法符号来指定FHE方案<span class="math inline">\(E=(Gen,Enc,Dec,Eval)\)</span>：<br></p><ul><li>Gen是以安全参数<span class="math inline">\(\lambda\)</span>和素数<span class="math inline">\(p\)</span>为输入的随机算法，输出公钥<span class="math inline">\(pk_p=(p,pk)\)</span>和私钥<span class="math inline">\(sk_p=(p,sk)\)</span>，p为明文模数，定义:</li></ul><p>  <span class="math inline">\((pk_p=(p,pk),sk_p=(p,sk))\gets Gen(1^\lambda;p)\)</span></p><ul><li>Enc是以<span class="math inline">\(pk_p\)</span>和明文信息<span class="math inline">\(msg\)</span>为输入的随机算法，输出明文模<span class="math inline">\(p\)</span>的密文<span class="math inline">\([msg]_p\)</span>，定义：</li></ul><p>  <span class="math inline">\([msg]_p\gets Enc_{pk_p}(msg)\)</span></p><ul><li>Dec是以<span class="math inline">\(sk_p\)</span>和密文<span class="math inline">\([msg]_p\)</span>为输入的算法，输出明文<span class="math inline">\(msg&#39;\)</span>，定义：</li></ul><p>  <span class="math inline">\(msg&#39; \gets Dec_{sk_p}([msg]_p)\)</span>. 正确性要求<span class="math inline">\(msg&#39;=msg\)</span></p><ul><li>Eval是以<span class="math inline">\(pk_p\)</span>、多项式<span class="math inline">\(f(x_1,...,x_t)\)</span>和一组密文<span class="math inline">\(([m_1]_p,...,[m_t]_p)\)</span>为输入的(可能随机)的算法，输出密文c，定义：</li></ul><p>  <span class="math inline">\(c\gets Eval_{pk_p}(f,[m_1]_p,...,[m_t]_p)\)</span>. 正确性要求解密返回的信息与在输入<span class="math inline">\(m_1,...,m_t\)</span>上评估多项式<span class="math inline">\(f()\)</span>相同，<span class="math inline">\(Dec_{sk_p}(Eval_{pk_p}(f,[m_1]_p,...,[m_t]_p))=f(m_1,...,m_t)\ mod\ p\)</span>. 语义安全表明结果密文c与新密文<span class="math inline">\([f(m_1,...,m_t)]_p\)</span>在计算上是不可区分的。<br></p><p>为了加密以二进制形式给定的信息<span class="math inline">\(msg=(m_1,...,m_t)\in \{,1\}^t\)</span>，我们使用比特加密来处理一组密文<span class="math inline">\([msg]_p=([m_1]_p,...,[m_t]_p)\)</span>，其中<span class="math inline">\([msg(i)]_p\gets Enc_{pk_p}(m_i)\)</span>。我们定义<span class="math inline">\([msg]_p\gets Enc_{pk_p}(msg)\)</span>。同样，我们按项加密<span class="math inline">\(array=(array(1),...,array(m))，[array(i)]_p\gets Enc_{pk_p}(array(i))\)</span>。我们定义<span class="math inline">\([array]_p=([array(1)]_p,...,[array(m)]_p).\)</span><br></p><p>  我们不知道如何高效地合并模数不同的密文，即将它们相加或相乘。这也是我们的服务器发送一个多环sketch而不是检索答案的原因。</p><h2 id="输入和输出格式">2.2 输入和输出格式</h2><p>  在本节中我们制定了客户端输入和输出格式(服务器无输入输出)。<br></p><p>  客户的输入是一个数据数组<span class="math inline">\(array=(x_1,...,x_m)\)</span>以及一个查询值<span class="math inline">\(\mathcal{l}\)</span>。为了简化表示，我们假设数据项<span class="math inline">\(x_i\)</span>和查询值<span class="math inline">\(\mathcal{l}\)</span>以二进制格式给出。数据项和查询值按比特加密(每个比特对应一个密文)；数组按项加密。<span class="math inline">\(\mathcal{M}\)</span>和<span class="math inline">\(\mathcal{Q}\)</span>分别表示数据项和查询值的空间。我们要求<span class="math inline">\(\mathcal{M}\)</span>由长度相等的项组成，<span class="math inline">\(\mathcal{Q}\)</span>由长度相等的查询值组成，因为我们的协议会泄露长度信息；按需求使用填充。匹配标准应该与选择的输入格式相符，<span class="math inline">\(isMatch: \mathcal{M}×\mathcal{Q}\to\{0,1\}\)</span>.例如，当匹配标准是二进制相等操作(参见5.2节)时，我们设置<span class="math inline">\(\mathcal{M}=\mathcal{Q}=\{0,1\}^t\)</span>，t是数据项的二进制表示的比特长度。<br></p><p>  客户的输出是第一个匹配项<span class="math inline">\((i,x_i)\)</span>，其中<span class="math inline">\(i=min\{i\in[m]|isMatch(x_i,\mathcal{l})=1\}\)</span>.输出索引i由它的二进制表示<span class="math inline">\(b\in\{0,1\}^{1+log\ m}\)</span>给出。我们指出当模数<span class="math inline">\(p&lt;&lt;m\)</span>时，不能以自然环元素返回索引i，因为我们只能得到它的剩余模p。<br></p><p>  注意我们除了使用二进制格式的输入输出外，还要求在多环<span class="math inline">\(GF(p)\)</span>上进行计算；参见1.3节。</p><h2 id="数据上传协议">2.3 数据上传协议</h2><p>  在上传协议中，客户生成密钥，加密数据数组，并将其与对应公钥上传至服务器。<br></p><p>  客户为E生成<span class="math inline">\(k=1+log^{2}m/log\ log\ m\)</span>个密钥以及k个对应密文：每个明文模数<span class="math inline">\(p_1,...,p_k\)</span>对应一个密钥和一个密文。素数设置为大于<span class="math inline">\(log\ m\)</span>的前k个素数。参见图9。<br></p><p>  <em>备注和扩展</em> 为了简化表示，我们假设数据项<span class="math inline">\(array\)</span>上传和密钥生成经过同一轮协议执行。密钥可以分开生产，可能上传数据至服务器的客户(数据源)生成公钥，发送检索查询的客户(检索客户)生成私钥。上传可以随着时间的推移，从多个数据源，逐渐上传新的加密数据记录，以便服务器附加到它的密文数组中。</p><h1 id="我们的安全搜索协议">3. 我们的安全搜索协议</h1><p>  本章中，我们展示了我们的安全搜索协议：3.1节是一个高层次的概述；3.2节是我们安全搜索协议的核心。我们的SPiRiTsketcch；3.3节是优化；3.4节是我们方案的一个随机化变体。协议总结于图9.</p><p>  我们的安全搜索协议计算功能如下。客户端输入为查询值<span class="math inline">\(\mathcal{l}\)</span>和上传协议中生成的公私钥对(pk,sk)。这里<span class="math inline">\(pk=(pk_{p_1},...,pk_{p_k}),sk=(sk_{p_1},...,sk_{p_k})\)</span>，其中<span class="math inline">\(k=o(log^{2}m)\)</span>，对应模明文<span class="math inline">\(p_1,...,p_k.\)</span>服务器输入客户先前与公钥对pk一起上传的加密数据<span class="math inline">\([array]\)</span>。客户的输出第一个与查询值匹配的数据项<span class="math inline">\((i,x_{i}),i=min{i\in[m]|isMatch(x_{i},\mathcal{l})}\)</span>，其中<span class="math inline">\(i\in[m]\)</span>由它的二进制表示<span class="math inline">\(b\in\{0,1\}^{1+log\ m}\)</span>指定。服务器无输出。<br></p><p>  我们可能将上传和搜索功能作为一个反应功能的两步；这种情况下密钥和加密数据是由参与双方维护的状态。</p><h2 id="概述">3.1 概述</h2><p>  在高层次上，安全搜索协议第一步是用户发送加密的查询值<span class="math inline">\([\mathcal{l}]\)</span>；第二步服务器计算并能发送加密的多环sketch(如下)；最后一步客户解密并识别正确答案。<br></p><p>  详细来说，加密的查询值为<span class="math inline">\([\mathcal{l}]=([\mathcal{l}]_{p_1},...,[\mathcal{l}]_{p_k}), [\mathcal{l}_{p_j}]\gets Enc_{pk_j}(\mathcal{l})\)</span>.多环sketch是一个加密的候选答案的列表：<span class="math inline">\(([b_{p_j}],[indicator(b_{p_j})],[array(b_{p_j})]_{p_j}),j\in[k]\)</span>.用户解密并输出<span class="math inline">\((b_{p_j},array(b_{p_j}))\)</span>，其中<span class="math inline">\(b_{p_j}\)</span>是<span class="math inline">\(indicator(b_{p_j})=1\)</span>的最小索引。<br></p><p>  我们通过服务器执行(上述第二步)来详细说明上述步骤。<br></p><p>  对于每个<span class="math inline">\(j\in[k]\)</span>，服务器在加密数据<span class="math inline">\([array]_{p_j}=([x_{1}]_{p_j},...,[x_{m}]_{p_j})\)</span>和查询值<span class="math inline">\([\mathcal{l}]_{p_j}\)</span>上执行如下三步(参见图2)：</p><p>  (1)首先，服务器计算二进制指示器的一个加密数组<span class="math inline">\([indicator]_{p_j}=([indicator_1]_{p_j},...,[indicator_m]_{p_j})\)</span>，从而有<span class="math inline">\(indicator_i=isMatch(x_i,\mathcal{l})\)</span>。当且仅当数据项<span class="math inline">\(x_{i}\)</span>与查询值<span class="math inline">\(\mathcal{l}\)</span>匹配时<span class="math inline">\(indicator_i\)</span>为1，匹配谓词isMatch是同态评估的：<span class="math inline">\([indicator_i]_{p_j}\gets Eval_{pk_{p_j}}(isMatch,[x_i]_{p_j},[\mathcal{l}]_{p_j})\)</span>.<br></p><p>  (2)第二，服务器将我们名为SPiRiT的第一正sketch应用到指示器<span class="math inline">\([indicator]_{p_j}\)</span>的加密数组上，得到二进制形式的一个候选<span class="math inline">\(b_{p_j}\in \{0,1\}^{1+log\ m},i\in[m]\)</span>是指示器第一个正条目的索引：<span class="math inline">\([b_{p_j}]_{p_j}\gets Eval_{p_j}(SPiRiT_{m,p_j},[indicator]_{p_j}).\)</span><br></p><p>  (3)第三，服务器以加密索引<span class="math inline">\(b_{p_j}\)</span>作为一个多项式实现的PIR功能的输入，得到加密的项<span class="math inline">\(array(b_{p_j})\)</span>和<span class="math inline">\(indicator(b_{p_j})\)</span>:<br></p><p>  <span class="math inline">\([array(b_{p_j})]_{p_j}\gets Eval_{p_j}(PIR,[array]_{p_j},[b_{p_j}]_{p_j}),\)</span><br></p><p>  <span class="math inline">\([indicator(b_{p_j})]_{p_j}\gets Eval_{p_j}(PIR,[indicator]_{p_j},[b_{p_j}]_{p_j})\)</span>,<br></p><p>服务器将候选答案列表<span class="math inline">\(([b_{p_j}],[indicator(b_{p_j})]_{p_j},[array(b_{p_j})]_{p_j})_{j\in[k]}\)</span>发送给客户。<br></p><p>  我们的安全搜索协议的核心是3.2节所述的SPiRiT。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gzb0aqtx2bj30mu0cltck.jpg" /></p><p>  在数据上传协议中，客户加密数据数组，分别模<span class="math inline">\(p_j(j\in[k])\)</span>，并将结果密文<span class="math inline">\([array]_{p_j}\)</span>发送至服务器。在安全搜索协议中，客户加密查询值<span class="math inline">\([\mathcal{l}]\)</span>，分别模<span class="math inline">\(p_j\)</span>，并发送结果密文<span class="math inline">\([\mathcal{l}]_{p_j}\)</span>至服务器；服务器计算并发送<span class="math inline">\(([b_{p_j}]_{p_j},[ind(b_{p_j})]_{p_j},[array(b_{p_j})]_{p_j})\)</span>给客户；客户解密并输出<span class="math inline">\((b_{j},array(b_{j}))\)</span>，其中<span class="math inline">\(b_{j}\)</span>是最小的候选，<span class="math inline">\(ind(b_{j})=1\)</span>.详细来说，对于每个模数<span class="math inline">\(p_j\)</span>，服务器做如下计算。首先，在加密查询值<span class="math inline">\([\mathcal{l}]_{p_j}\)</span>和每个数据项<span class="math inline">\([array(i)]_{p_j}\)</span>上同态评估模式匹配多项式isMatch，得到加密指示值<span class="math inline">\([ind(i)]_{p_j}\)</span>。第二，对于加密的指示数组，在第一个正数值上同态评估我们的<span class="math inline">\(SPiRiT_{m,p_j}\)</span>，得到第一个正索引的一个候选<span class="math inline">\([b_{p_j}]_{p_j}\)</span>，第三，在加密数组和<span class="math inline">\(b_{p_j}\)</span>上同态评估一个PIR多项式，以得到<span class="math inline">\([array(b_{p_j})]_{p_j}\)</span>.</p><h2 id="spirit的细节">3.2 SPiRiT的细节</h2><p>  我们的安全搜索协议的核心是在二进制向量<span class="math inline">\(x\in\{0,1\}^{m}\)</span>上进行评估(x是数组指引，参见3.1节)<br></p><p>  <span class="math inline">\(SPiRiT_{m,p}=S∘P∘i∘R∘i∘T\ mod\ p\)</span><br></p><p>  假设m是2的一个幂<br></p><p>  <strong>Tree矩阵</strong> <span class="math inline">\(T\in\{0,1\}^{(2m-1)×m}\)</span></p><p>  <span class="math inline">\(x=(0,1,1,1,1,0,0,1)\)</span>的树表示：</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gzb1aygna4j30r50btgne.jpg" /></p><p>  <strong>Roots矩阵</strong> <span class="math inline">\(R\in\{0,1\}^{m×(2m-1)}\)</span>，每一行至多有<span class="math inline">\(log\ m\)</span>个满足如下条件的非零项：和向量<span class="math inline">\(x=(x(1),...,x(m))\)</span>的树表示<span class="math inline">\(w=(w(1),...,w(2m-1))\)</span>右乘返回向量<span class="math inline">\(v=Rw\)</span>，<span class="math inline">\(v(j)\)</span>是<span class="math inline">\(x(1),...,x(j)\)</span>的和</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFV</title>
    <link href="/2022/01/22/BFV/"/>
    <url>/2022/01/22/BFV/</url>
    
    <content type="html"><![CDATA[<center><big>Somewhat Practical Fully Homomorphic Encryption</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  在本文中，我们将基于错误学习(LWE)问题的Brakerski全同态方案修改为基于环-LWE设置。我们介绍了两种重新线性化的优化版本，不仅能够得到更小的重新线性化密钥，而且计算速度更快。我们提供了对各种同态操作详细但简洁的分析，，如乘法、重新线性化和自举，并推导出了这些操作引起的噪声的严格最坏情况界限。自举步骤的分析通过使用模量切换技巧而大大简化了。最后，我们推导了具体的参数，使方案提供一个给定的安全等级并实现全同态。</p><h1 id="介绍">1. 介绍</h1><p>  全同态加密(FHE)允许对加密数据进行任意函数求值，从而产生无数潜在的应用，比如私有云计算。Gentry第一个证明了FHE在理论上是可能的。他的构造由三部分组成：首先，构造一个部分同态的加密方案，即能够评估有限复杂度的函数，第二，尽可能简化方案的解密函数(称为压缩)，第三，对简化后的解密函数进行同态计算，得到噪声大小固定的密文（称为自举）。<br></p><p>  Gentry方案起初的变体都遵循相同的结构，因此必须做出额外的安全假设来支持压缩步骤。最近的方案避免了压缩步骤，并能够通过评估实际解密电路实现自举。最近的方案的另一个优点是它们的安全性是基于LWE问题或它的环变体RLWE的，其难度与(理想)格上的经典问题相关联。<br></p><p>  所有现存方案都有一个共同的特质，就说它们在加密过程中增加了一个小的"噪声"部分。对密文的同态计算将导致这些噪声增长，当噪声过大则导致解密失败。Gentry的自举方法可以用来将密文中的噪声降低到由解密电路的复杂性决定的固定水平。特别是同态乘法引起的噪声增长问题成为设计有效方案的主要障碍。在方案的第一代，噪声本身在每个同态乘法上相乘，导致电路深度成倍增长，即在纯密文(噪声为E)上评估一个深度为n的电路会导致噪声<span class="math inline">\(E^{2^{n}}\)</span>。第一个主要改进使得深度为n的电路噪声等级仅仅为<span class="math inline">\(E^{n}\)</span>。最新的方案进一步改进了这一点，使得每一个乘法的噪声等级都以一个常数因子增长，与密文中的噪声无关，即深度为n的电路的噪声为<span class="math inline">\(E·c(\lambda)^{n}\)</span>，其中<span class="math inline">\(c(\lambda)\)</span>是一个取决于安全参数的常量。<br></p><p>  至于这些建议是否真的可行，答案是“不可行”。对于上述提到的大多方案，已经进行了几次尝试，但没有一次是接近实用的。最近的一篇论文成功地使用大量(数十GB)的RAM内存在8天内同态执行了一个AES加密。当然，与最初的提案相比，在效率方面有了重大进步。<br></p><p>  这篇论文的主要贡献在于它的简单性，因为我们采用了务实的方法，因此任何多余的数学机制都被忽略了。本文的其他贡献如下：我们将基于LWE的Brakerski方案移植到了RLWE上，这本身是相当简单的。我们对各种同态操作提供了一个详细但简洁的分析，如乘法、重新线性化和自举，并推导出这些操作导致的噪声的严格最坏情况界限。使用一个简单的模量切换技巧，我们简化了自举步骤的分析。结合对该方案的实际安全性分析，最终得到了具有给定安全等级的全同态方案的具体参数。<br></p><p>  尽管该文章不是关于优化各种子程序的，但我们确实提供了两个版本的更有效的重新线性化。只要适用，我们将提到对提议方案仍然有效的现有优化。在后续的论文中，我们将通过在软件和硬件中实现它来考虑方案的实际实用性，这将表明标题确实是合理的。<br></p><p>  本文的其余部分如下：第二章简单地回顾了概率的符号和一些背景知识。第三章回顾了一个基于RLWE的加密方案，它将作为第四章中描述的部分同态方案的基础。第五章分析了自举步骤并确定了使部分同态方案实现全同态的最小深度。第六章使用了Lindner和Peikert的分析来推导给定安全等级的全同态方案的参数。最后，第七章总结了本文，并强调了正在进行的工作。<br></p><h1 id="前言">2. 前言</h1><h2 id="基础符号">2.1 基础符号</h2><p>  我们要研究的基本对象是多项式环<span class="math inline">\(R=\mathbb{Z}[x]/(f(x))\)</span>，其中<span class="math inline">\(f(x)\in\mathbb{Z}[x]\)</span>是一个阶为d的一元不可约多项式。在实际中，通常会限制使用一个分圆多项式<span class="math inline">\(\Phi_{m}(x)\)</span>，即原始m次根的最小多项式。用于说明目的通常选择取<span class="math inline">\(f(x)=x^{d}+1,d=2^{n}\)</span>.<br></p><p>  环R的元素将用小写粗体表示，例如<span class="math inline">\(\mathrm{a}\in R\)</span>。元素<span class="math inline">\(\mathrm{a}\in R\)</span>系数用<span class="math inline">\(a_{i}\)</span>表示，即<span class="math inline">\(\mathrm{a}=\sum_{i=0}^{d-1}{a_{i}·x^{i}}\)</span>。无穷范数<span class="math inline">\(||\mathrm{a}||\)</span>定义为<span class="math inline">\(max_{i}|a_{i}|\)</span>，R的扩张因子定义为<span class="math inline">\(\delta_{R}=max\{||\mathrm{a}||·||\mathrm{b}||:\mathrm{a},b\in R\}\)</span>.<br></p><p>  设q&gt;1是一个整数，我们用<span class="math inline">\(\mathbb{Z}_{q}\)</span>表示整数集合<span class="math inline">\((-q/2,q/2]\)</span>。注意，我们只简单地把<span class="math inline">\(\mathbb{Z}_{q}\)</span>看作一个集合，因此不应该和环<span class="math inline">\(\mathbb{Z}/q\mathbb{Z}\)</span>混淆。对于<span class="math inline">\(a\in\mathbb{Z}\)</span>，我们用<span class="math inline">\([a]_{q}\)</span>表示<span class="math inline">\(\mathbb{Z}_{q}\)</span>中的唯一整数，<span class="math inline">\([a]_{q}=a\ mod\ q\)</span>。在少数情况下我们需要在区间[0,q)内进行约简，记该区间为<span class="math inline">\(r_{q}(a)\)</span>(模q的剩余)。<br></p><p>  类似地，当<span class="math inline">\(\mathrm{a}\in R\)</span>，我们用<span class="math inline">\([\mathrm{a}]_{q}\)</span>表示R中通过将<span class="math inline">\([·]_{q}\)</span>应用到它所有的系数上得到的元素。对于<span class="math inline">\(x\in\mathbb{R}\)</span>，我们使用<span class="math inline">\(\lfloor x\rceil\)</span>表示四舍五入到最接近的整数，<span class="math inline">\(\lfloor x\rfloor,\lceil x\rceil\)</span>表示向下取整或向上取整。给定一个整数n，我们用size(n)表示它的大小，即<span class="math inline">\(size(n)=\lceil{log_{2}(n+0.5)}\rceil\)</span>。我们用<span class="math inline">\(n[i]\)</span>表示<span class="math inline">\(|n|\)</span>的位扩展中的第i比特(从0开始计数)。<br></p><p>  注意，所有算术运算都发生在R本身上，在许多情况下甚至(暂时地)发生在<span class="math inline">\(\mathbb{Q}[x]/(f(x))\)</span>。在实施本文提出的方案时，必须注意，计算结果可以模某一整数q。</p><h2 id="概率">2.2 概率</h2><p>  给定概率分布D，我们用<span class="math inline">\(x\gets D\)</span>表示x从D中采样。对于集合S，<span class="math inline">\(x\gets S\)</span>表示x从S中均匀采样。整数上的分布<span class="math inline">\(\chi\)</span>在[-B, B]成立则称为B-bounded。<br></p><p>  整数上的离散高斯分布<span class="math inline">\(D_{\mathbb{Z},\sigma}\)</span>是一个概率分布，对于每个<span class="math inline">\(x\in\mathbb{Z}\)</span>，其概率与<span class="math inline">\(exp(-\pi|x|^{2}/\sigma^{2})\)</span>成正比。我们注意到对于足够大的B，<span class="math inline">\(D_{\mathbb{Z},\sigma}\)</span>统计学上与一个B-bounded分布是不可区分的，例如可以取<span class="math inline">\(B=10·\sigma\)</span>.<br></p><p>  离散高斯分布<span class="math inline">\(D_{\mathbb{Z},\sigma}\)</span>用于定义R上的一个分布<span class="math inline">\(\chi\)</span>。<span class="math inline">\(\chi\)</span>在一般情况下并不像仅仅根据<span class="math inline">\(D_{\mathbb{Z},\sigma}\)</span>进行系数采样那么简单。但是对于多项式<span class="math inline">\(f(x)=x^{d}+1\)</span>(d为2的幂)，我们可以将<span class="math inline">\(\chi\)</span>定义为<span class="math inline">\(D_{\mathbb{Z},\sigma}^{d}\)</span>。对于更一般的分圆多项式来说，从<span class="math inline">\(\chi\)</span>采样只涉及到一点。回顾一下，对于正态分布<span class="math inline">\(\mathcal{N}(0,\sigma^{2})\)</span>，有<span class="math inline">\(Prob_{x\gets\mathcal{N}(0,\sigma^{2})}[|x|&gt;k·\sigma]=erf(k/\sqrt{2})\)</span>。因此定义函数<span class="math inline">\(\beta(\epsilon):=min\{\beta|erf(\beta/\sqrt{2}&lt;\epsilon)\}\)</span>，概率为<span class="math inline">\(1-\epsilon\)</span>，样本以<span class="math inline">\(\beta·\sigma\)</span>为界。比如说，如果我们设置<span class="math inline">\(\epsilon=2^{-64}\)</span>，那么只需取<span class="math inline">\(\beta(\epsilon)&gt;9.2\)</span>.</p><h1 id="基于rlwe的加密">3. 基于RLWE的加密</h1><p>  在这一章，我们回顾了一个非常简单且经典的加密方案，它由Lyubashevsky、Peikert和Regev提出，基于RLWE问题。</p><h2 id="rlwe问题">3.1 RLWE问题</h2><p>  RLWE问题是LWE问题的一个基于环的版本，其表述如下。<br></p><p>  <strong>定义1(判断RLWE)</strong> 对于安全参数<span class="math inline">\(\lambda\)</span>，设f(x)是一个分圆多项式<span class="math inline">\(\Phi_{m}(x),deg(f)=\phi(m)\)</span>取决于<span class="math inline">\(\lambda\)</span>，设<span class="math inline">\(R=\mathbb{Z}[x]/(f(x))\)</span>。设<span class="math inline">\(q=q(\lambda)\ge 2\)</span>一个整数。对于一个随机元素<span class="math inline">\(s\in R_{q}\)</span>和R上的一个分布<span class="math inline">\(\chi=\chi(\lambda)\)</span>，用<span class="math inline">\(A_{s,\chi}^{(q)}\)</span>示通过选择一个均匀随机元素<span class="math inline">\(\mathrm{a}\gets R_{q}\)</span>和一个噪声项<span class="math inline">\(e\gets\chi\)</span>并输出<span class="math inline">\((\mathrm{a},[\mathrm{a}·s+e]_{q})\)</span>得到的分布。判断<span class="math inline">\(RLWE_{d,q,\chi}\)</span>问题是为了区分分布<span class="math inline">\(A_{s,\chi}^{(q)}\)</span>和均匀分布<span class="math inline">\(U(R_{q}^{2})\)</span>.<br></p><p>  RLWE问题可以（使用一个量子算法）约简为理想格上的最短向量问题。此外，我们可以限制s从<span class="math inline">\(\chi\)</span>中采样，而不是在<span class="math inline">\(R_{q}\)</span>中均匀取样而不涉及任何安全问题。最后，我们注意到问题的难度与q的精确类型无关，因此q不必是素数，可以简单取为2的幂。</p><h2 id="加密方案">3.2 加密方案</h2><p>  上述问题将推导出以下加密方案。明文空间取为<span class="math inline">\(R_{t}\)</span>，t为某个大于1的整数。设<span class="math inline">\(\Delta=\lfloor q/t\rfloor,r_{t}(q)=q\ mod\ t\)</span>，我们有<span class="math inline">\(q=\Delta·t+r_{t}(q)\)</span>。我们注意到q和t都不必是素数，也不必互素。加密方案LPR.ES定义如下：<br></p><ul><li><span class="math inline">\(LPR.ES.SecretKeyGen(1^{\lambda})\)</span>: 采样<span class="math inline">\(s\gets\chi\)</span>，输出<span class="math inline">\(sk=s\)</span>.</li><li><span class="math inline">\(LPR.ES.PublicKeyGen(sk)\)</span>: 设置<span class="math inline">\(s=sk\)</span>，采样<span class="math inline">\(\mathrm{a}\gets R_{q},e\gets\chi\)</span>并输出<span class="math inline">\(pk=([-(\mathrm{a}·s+e)]_{q},\mathrm{a})\)</span>.</li><li><span class="math inline">\(LPR.ES.Encrypt(pk,m)\)</span>: 为了加密消息<span class="math inline">\(m\in R_{t}\)</span>，设<span class="math inline">\(p_{0}=pk[0],p_{1}=pk[1]\)</span>，采样<span class="math inline">\(u,e_{1},e_{2}\gets\chi\)</span>并返回<span class="math inline">\(ct=([p_{0}·u+e_{1}+\Delta·m]_{q},[p_{1}·u+e_{2}]_{q})\)</span>.</li><li><span class="math inline">\(LPR.ES.Decrypt(sk,ct)\)</span>: 设置<span class="math inline">\(s=sk,c_{0}=ct[0],c_{1}=ct[1]\)</span>并计算<span class="math inline">\([\lfloor\frac{t·[c_{0}+c_{1}·s]_{q}}{q}\rceil]_{t}\)</span>.</li></ul><p>  假设给定3个采样的RLWE的难度，可以证明上述方案是语义安全的。<br>   为证明对于正确加密的密文，解密是正确的，我们证明了如下引理。</p><p>  <strong>引理1</strong> 使用上述加密方案LPR.ES的符号并假设<span class="math inline">\(||\chi||&lt;B\)</span>，我们有<span class="math inline">\([c_{0}+c_{1}·s]_{q}=\Delta·m+v\ (1),\ ||v||\le 2·\delta_{R}·B^{2}+B\)</span>。这表明对于<span class="math inline">\(2·\delta_{R}·B^{2}+B&lt;\Delta/2\)</span>，解密是正确工作的。<br></p><p>  证明：简单写出对q取模的定义可以得到：</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gynu3oyb6nj30hv023dgn.jpg" /></p><p>因为对于足够小的误差项，<span class="math inline">\(\Delta·m+e·u+e_{1}+e_{2}·s\)</span>已经位于<span class="math inline">\(R_{q}\)</span>中，我们可以总结<span class="math inline">\(v=e·u+e_{1}+e_{2}·s\)</span>。因为<span class="math inline">\(e,e_{1},e_{2},u,s\gets\chi\)</span>，我们恢复出给定的界限<span class="math inline">\(||v||\le 2·\delta_{R}·B^{2}+B\)</span>。记<span class="math inline">\(c_{0}+c_{1}·s=\Delta·m+v+q·r\)</span>，如果先除以q再乘以t，我们就得到了<span class="math inline">\(m+(t/q)·(v-\epsilon·m)+t·r\)</span>，其中<span class="math inline">\(\epsilon=q/t-\Delta=r_{t}(q)/t&lt;1\)</span>。为了使四舍五入是正确的，我们需要<span class="math inline">\((t/q)·||v-\epsilon·m||&lt;1/2\)</span>，因为<span class="math inline">\(m\in R_{t}\)</span>，给定界限如下。<br></p><p>  V被称为密文中包含的噪声，如果从上下文中不清楚它属于哪个密文ct，则表示为v(ct)。观察噪声项的精确表达式，我们可以看的让u和s尽可能小会让噪声变小。这导出了下列优化和对应的假设。<br></p><p>  <strong>优化/假设1</strong> 相比于采样<span class="math inline">\(s,u\gets\chi\)</span>，我们从<span class="math inline">\(R_{2}\)</span>中采样s和u，即范数<span class="math inline">\(||s||=||u||=1\)</span>。我们注意到噪声项<span class="math inline">\(e_{1},e_{2}\)</span>仍然从<span class="math inline">\(\chi\)</span>中采样。引理1中的界限变为<span class="math inline">\(B·(2·\delta_{R}+1)\)</span>。这种优化的安全性影响似乎很小，至少当我们假设LWE设置的结果可以转移到RLWE设置时是这样的。对于标准LWE，只要分布有足够的熵，我们就可以从任何分布中得到秘密s。假设LWE分析也适用于RLWE设置，只要<span class="math inline">\((_{h}^{d})\)</span>足够大，我们甚至可以使用一个给定的低Hamming权值h的秘密。</p><h1 id="部分同态加密">4. 部分同态加密</h1><p>  在本章，我们将利用LPR.ES推导出一个简单的基于RLWE的部分同态加密方案FV.SH。事实上，FV.SH主要是Brakerski基于标准LWE的全同态方案RLWE设置的一个简单移植。<br></p><p>  该方案由前一章介绍的LPR.ES的一个扩展版本构成。私钥、公钥的生成和加密/解密过程将保持不变，使用优化<span class="math inline">\(u,s\gets\mathbb{R}_{2}\)</span>。LPR.ES的主要补充是一个所谓的重新线性化密钥rlk，它将用于计算同态乘法。<br></p><p>  方案LPR.ES的主要不变量由等式(1)给出，即当我们将密文ct的元素解释为多项式ct(x)的系数并在s中评估该多项式时，得到<span class="math inline">\([ct(s)]_{q}=\Delta·m+v\)</span>，据此我们可以轻易恢复消息m。利用这种解释，可以很容易地推导出同态加法FV.SH.Add和乘法FV.SH.Mul。<br></p><h2 id="加法">加法</h2><p>  设i=1,2，<span class="math inline">\(ct_{i}\)</span>是两个密文，<span class="math inline">\([ct_{i}(s)]_{q}=\Delta·m_{i}+v_{i}\)</span>，很容易看到<span class="math inline">\([ct_{1}(s)+ct_{2}(s)]_{q}=\Delta·[m_{1}+m_{2}]+v_{1}+v_{2}-\epsilon·t·r\)</span>，其中<span class="math inline">\(\epsilon=q/t-\Delta=r_{t}(q)/t&lt;1,m_{1}+m_{2}=[m_{1}+m_{2}]_{t}+t·r\)</span>。注意<span class="math inline">\(||r||\le 1\)</span>，这表明和中的噪声增加了t的一个最大值。因此我们可以简单定义<span class="math inline">\(FV.SH.Add(ct_{1},ct_{2}):=([ct_{1}[0]+ct_{2}[0]]_{q},[ct_{1}[1]+ct_{2}[1]]_{q})\)</span></p><h2 id="乘法">乘法</h2><p>  同态乘法由两步构成：第一步十分简单，基本上由多项式<span class="math inline">\(ct_{1}(x)\)</span>和<span class="math inline">\(ct_{2}(x)\)</span>相乘和t/q扩展构成。但问题是，我们最终得到的密文由3个环元素构成，而不是2个。第二步解决了这个问题，称为“重新线性化”。</p><h3 id="基础乘法">基础乘法</h3><p>  首先将s中<span class="math inline">\(ct_{i}(x)\)</span>的评估记为R中的一个等式，<span class="math inline">\(ct_{i}(s)=\Delta·m_{i}+v_{i}+q·r_{i}\)</span>。一个简单的计算表明了<span class="math inline">\(||r_{i}||&lt;\delta_{R}·||s||\)</span>。如果我们将这些表达式相乘，得到：</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gynwwvxxktj30o102675l.jpg" /></p><p>上述表达式证明我们需要以<span class="math inline">\(1/\Delta\)</span>的倍数进行扩展，以便能够恢复加密<span class="math inline">\([m_{1}·m_{2}]_{t}\)</span>的密文。但是，因为<span class="math inline">\(\Delta\)</span>不一定能够被q整除，由于上一项的舍入误差，我们会得到很大的噪声。因此，我们将按t/q进行扩展，从而解决该舍入问题。设<span class="math inline">\(ct_{1}(x)·ct_{2}(x)=c_{0}+c_{1}·x+c_{2}·x^{2}\)</span>，我们将使用近似</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gynwyb4gb7j30o10200ti.jpg" /></p><p>这引入了一个大小小于<span class="math inline">\((\delta_{R}·||s||+1)^{2}/2\)</span>的近似误差<span class="math inline">\(r_{a}\)</span>.<br></p><p>  如果记<span class="math inline">\(m_{1}·m_{2}=[m_{1}·m_{2}]_{t}+t·r_{m}\)</span>，那么<span class="math inline">\(||r_{m}||&lt;(t·\delta_{R})/4\)</span>。类似地，如果我们记<span class="math inline">\(v_{1}·v_{2}=[v_{1}·v_{2}]_{\Delta}+\Delta·r_{v}\)</span>，则<span class="math inline">\(||r_{v}||&lt;(E^{2}·\delta_{R})/\Delta\)</span>，其中E是原始噪声项的一个界限，即<span class="math inline">\(||v_{i}||&lt;E\)</span>。通过将等式(2)乘以t/q，并将项组合在一起，我们得到一个看起来有点复杂的等式，其中我们主要使用<span class="math inline">\(t·\Delta=q-r_{t}(q)\)</span>：</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gynx2w8vrxj30o104yq58.jpg" /></p><p>这样写表达式的基本思想是为了明确q约简后哪些项会小时，哪些项会受到舍入的影响。注意在上述表达式中除了最后一行的<span class="math inline">\(r_{r}\)</span>，所有项都是积分的。因此舍入只影响最后一行，可以很容易看出<span class="math inline">\(||r_{r}||\)</span>小于<span class="math inline">\(\delta_{R}·(t+1/2)^{2}+1/2\)</span>。对q取模，带入方程（3）可得：</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gynx49a035j30o102b75u.jpg" /></p><p>很容易在右边限制新噪声项的大小，这最终证明了以下引理。<br></p><p>   <strong>引理2</strong> 设i=1,2，<span class="math inline">\(ct_{i}\)</span>是两个密文，有<span class="math inline">\([ct_{i}(s)]_{q}=\Delta·m_{i}+v_{i},\ ||v_{i}||&lt; E &lt;\Delta/2\)</span>，并设<span class="math inline">\(ct_{1}(x)·ct_{2}(x)=c_{0}+c_{1}·x+c_{2}·x^{2}\)</span>，则<span class="math inline">\([\lfloor t·c_{0}/q\rceil+\lfloor t·c_{q}/q\rceil·s+\lfloor t·c_{2}/q\rceil·s^{2}]_{q}=\Delta·[m_{1}m_{2}]_{t}+v_{3},\ ||v_{3}||&lt;2·\delta_{R}·t·E·(\delta_{R}·||s||+1)+2·t^{2}·\delta_{R}^{2}·(||s||+1)^{2}\)</span>。该引理证明了噪声不会在相乘时呈二次方增长，而只是粗略地乘以<span class="math inline">\(2·t·\delta_{R}^{2}·||s||\)</span>。由此可见，不只是t，秘密s的范数对噪声的增长也有显著的影响。通过再次使用优化1，我们有<span class="math inline">\(||s||=1\)</span> ，从而极大地限制了乘法过程中噪声的增长。</p><h3 id="重新线性化">重新线性化</h3><p>  使用引理2，我们已经得到一个加密了两个明文的乘法的密文。但是，一个仍然存在的问题是密文中元素的个数增加了。为了纠正这一现象，我们需要一个称为重新线性化的过程，将二次密文再次还原为一次密文。在这一步需要引入一个重新线性化密钥rlk。设<span class="math inline">\(ct=[c_{0},c_{1},c_{2}]\)</span>表示一个二次密文，则我们需要找到<span class="math inline">\(ct&#39;=[c_{0}&#39;,c_{1}&#39;]\)</span>使得<span class="math inline">\([c_{0}+c_{1}·s+c_{2}·s^{2}]_{q}=[c_{0}&#39;+c_{1}&#39;·s+r]_{q}\)</span>，其中<span class="math inline">\(||r||\)</span>是很小的。因为<span class="math inline">\(s^{2}\)</span>是未知的，第一个想法是提供一个<span class="math inline">\(s^{2}\)</span>的掩码版本如下(与LPR.ES.PublicKeyGen相比)：采样<span class="math inline">\(\mathrm{a}_{0}\gets R_{q},e_{0}\gets\chi\)</span>并输出<span class="math inline">\(rlk:=([-(\mathrm{a}·s+e_{0})+s^{2}],\mathrm{a}_{0})\)</span>。注意<span class="math inline">\(rlk[0]+rlk[1]·s=s^{2}+e_{0}\)</span>。但问题是，因为<span class="math inline">\(c_{2}\)</span>是<span class="math inline">\(R_{q}\)</span>中的一个随机元素，噪声<span class="math inline">\(e_{0}\)</span>将被放大得过大从而导致<span class="math inline">\(c_{2}·s^{2}\)</span>的一个很差的近似，因此导致一个大的误差r。</p><h4 id="重新线性化版本1">重新线性化：版本1</h4><p>  第一种可能的解决方案是选择一个基T(T完全独立于t)，将<span class="math inline">\(c_{2}\)</span>切分成一个以T为基的小范数的几部分，并在T中将<span class="math inline">\(c_{2}\)</span>表示出来，即<span class="math inline">\(c_{2}=\sum_{i=0}^{\mathcal{l}}{T^{i}·c_{2}^{(i)}mod\ q}\)</span>，其中<span class="math inline">\(\mathcal{l}=\lfloor log_{T}(q)\rfloor,c_{2}^{(i)}\)</span>的系数位于<span class="math inline">\(R_{T}\)</span>中。重新线性化密钥rlk由<span class="math inline">\(T^{i}·s^{2}\)</span>的掩码版本组成，对<span class="math inline">\(i=0,...,\mathcal{l}\)</span>:<span class="math inline">\(rlk=[([-(\mathrm{a}_{i}·s+e_{i})+T^{i}·s^{2}]_{q},\mathrm{a}_{i}):i\in[0,\mathrm{l}]]\)</span>.<br></p><p>  <strong>假设2</strong> 注意重新线性化密钥rlk包含了<span class="math inline">\(T^{i}·s^{2}\)</span>的掩码版本，它们不是RLWE分布的正式采样，也不是<span class="math inline">\(T^{i}·s^{2}\)</span>的真实加密。这一事实在我们方案中引入了一个额外的假设，即当对手可以访问rlk时，方案仍然是安全的。该属性是弱循环安全性的一种形式。<br></p><p>  如果我们定义</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gynxr5na57j30o102pab2.jpg" /></p><p>则可以计算<span class="math inline">\(c_{0}&#39;+c_{1}&#39;·s=c_{0}+c_{1}·s+c_{2}·s^{2}-\sum_{i=0}^{\mathcal{l}}{c_{2}^{(i)}·e_{i}\ mod\ q}\)</span>。通过对两侧应用<span class="math inline">\([·]_{q}\)</span>，我们最终可以取<span class="math inline">\(\sum_{i=0}^{\mathcal{l}}{c_{2}^{(i)}·e_{i}}\)</span>。上述推导也证明T具有以下作用：<br></p><ul><li>评估密钥的大小由<span class="math inline">\(\mathcal{l}+1\simeq log_{T}(q)\)</span>给定，因此T越大rlk越小</li><li>重新线性化中乘法的个数为<span class="math inline">\(2·\mathcal{l}\simeq 2·log_{T}(q)\)</span>，它是将<span class="math inline">\(R_{T}\)</span>的一个元素与<span class="math inline">\(R_{q}\)</span>的一个元素相乘</li><li>重新线性化引入的噪声受限于<span class="math inline">\((\mathcal{l}+1)·B·T·\delta_{R}/2\)</span>，因此T越大噪声越大。注意重新线性化引入的噪声是完全独立于被重新线性化的密文中的固有噪声的。此外，我们只需要在乘法之后进行重新线性化(这会导致基本误差的增长)，因此，我们应该至少选择最大的T，从而重新线性化误差的大小与一次乘法之后的密文包含的误差类似。这个了我们一个应该考虑使用的最小的T值。但是，当经过多次乘法后误差变大，我们可以对<span class="math inline">\(T^{2}\)</span>而不是T进行重新线性化。注意所有需要的信息都已经包含在评估密钥rlk中。我们称这种方法为动态重新线性化。<br></li></ul><p>  上述策略最小化了重新线性化误差，但是另一个策略是为了最小化重新线性化时间和空间。因此我们想要将T取得非常大，例如<span class="math inline">\(T=\lceil \sqrt{q}\rceil\)</span>，因为这样我们就只需要处理两部分。对如此大的T，第一次重新线性化后噪声的大小将会有一个巨大的跳跃，但所有后续的重新线性化不会导致噪声的增加。</p><h4 id="重新线性化版本2">重新线性化：版本2</h4><p>  第二种可能的解决方案类似于某种形式的“模量切换”，其工作原理如下。回顾一下，简单掩码<span class="math inline">\(s_{2}\)</span>的问题是误差项<span class="math inline">\(e_{0}\)</span>与<span class="math inline">\(c_{2}\)</span>相乘，产生一个巨大的误差项r。因此，假设我们不是简单给出<span class="math inline">\(s_{2}\)</span>的掩码版本，而是给出一个可以容纳这个额外错误的掩码版本。例如，对于某个整数p，我们可以考虑给出一个模pq的掩码版本，而不是模q。因为我们想要得到<span class="math inline">\(c_{2}·s^{2}\)</span>模q的一个近似值，需要乘以p。因此，我们需要给出<span class="math inline">\(rlk:=([-(\mathrm{a}·s+e)+p·s^{2}]_{p·q},\mathrm{a})\)</span> ，其中<span class="math inline">\(\mathrm{a}\in R_{p·q},e\gets\chi&#39;\)</span>。这里我们要注意选择<span class="math inline">\(\chi&#39;\)</span>的方差，从而使得到的系统是安全的。简单取<span class="math inline">\(\chi=\chi&#39;\)</span>导致一个相当大的安全损失。如第六章所述，如果对某些k&gt;0，我们记<span class="math inline">\(pq=q^{k}\)</span>并假设<span class="math inline">\(||\chi||&lt; B\)</span>，则我们需要<span class="math inline">\(||\chi&#39;||=B_{k}&gt;\alpha^{1-\sqrt{k}}·q^{k-\sqrt{k}}·B^{\sqrt{k}}\)</span>，其中<span class="math inline">\(\alpha\)</span>是一个常量，例如<span class="math inline">\(\alpha\simeq 3.758\)</span>.<br></p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCS21</title>
    <link href="/2022/01/17/CCS21/"/>
    <url>/2022/01/17/CCS21/</url>
    
    <content type="html"><![CDATA[<center><big>Compressed Oblivious Encoding for Homomorphically Encrypted Search</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  全同态加密（FHE）为安全搜索提供了一个简单、有吸引力的框架。与其他安全搜索系统相比，不需要昂贵的设置过程；客户端只需要将加密的数据库上传到服务器就足够了。提供机密性是因为服务器只处理加密的查询和记录。而搜索功能是由加密方案的全同态实现的。<br></p><p>  由于这一原因，研究人员对该问题的关注度越来越高。自从Akavia等人提出了在FHE加密数据上进行安全搜索的框架(CCS18)，并给出了一个名为SPiRiT的实现，几个更加有效的实现方式已经被提出。<br></p><p>  在本文中，我们确定了该框架的主要瓶颈，并展示了如何显著提高基于FHE的安全搜索的性能。特别地，<br></p><ul><li>要检索ℓ匹配的项目，现有的框架需要按顺序重复该协议ℓ次。在我们的新框架中，所有匹配的项目都将在一次协议执行中被并行地检索出来。</li><li>Wren等人的最新工作(CCS20)需要进行<span class="math inline">\(O(n)\)</span>乘法运算来得到第一个匹配的索引。我们的解决方案不需要同态乘法，只用加法和标量乘法来编码所有匹配的索引。</li><li>我们的实现和实验证明了在获取16条匹配记录的过程中，我们的系统在获取查询结果方面比现有技术提高了1800倍，从而使全部搜索功能的速度提高了26倍。</li></ul><p><strong>关键词</strong><br></p><p>  安全搜索；加密数据库；全同态加密</p><h1 id="简介">1. 简介</h1><p>  随着计算范式向以云为中心的技术转变，这些技术的用户越来越关注他们上传到云端的数据的隐私和保密性。具体来说，客户上传数据到服务器，并期望得到以下保证：<br></p><p>  (1)上传的数据仍然是隐私的，即使对服务器本身来说；<br>   (2)服务器应该能够在上传数据上进行计算，来回应客户的查询；<br>   (3)客户应该能够以最少的后期处理有效地恢复服务器计算的结果。<br></p><p>  在这项工作中，我们将专注于安全搜索的计算任务。在该应用中，客户将一组记录上传到服务器，随后向服务器发送查询。计算过程分两步进行，称为匹配和获取。在匹配步骤中，服务器将客户加密的查询语句与数据库中的所有加密记录相比较，并计算一个加密的0/1向量，其中1表示相应的记录满足查询要求。获取步骤将所有1值的索引和相应的记录返回给客户端进行解密。<br></p><p>  虽然目标看似冲突，对安全搜索设置的(1)(2)(3)的保证可以通过如安全多方计算和可搜索加密等技术同时实现。最近的一系列工作都集中在基于全同态加密（FHE）的安全搜索上，我们接下来会介绍。<br></p><p>  <strong>基于全同态加密（FHE）的安全搜索。</strong>FHE加密数据的安全搜索框架的简单性很有吸引力。与其他安全搜索系统相比，不需要昂贵的设置过程；客户端只需要将加密的数据库上传到服务器即可。由于服务器只在加密的查询和记录上工作，因此提供了保密性。由于底层加密方案的完全同构的强大属性，服务器仍然能够正确地执行搜索。<br></p><p>  出于这个原因，研究人员越来越关注这个问题。特别地，Akavia等人介绍了一个对FHE加密数据进行安全搜索的框架（参见图1）<br> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyfunq1chgj30o10bgq7b.jpg" /></p><p>  非正式地说，一个安全的、同态的加密搜索方案由如下设置：<br></p><p>  (1)(setup)客户加密并上传n项<span class="math inline">\(x=(x_{1},...,x_{n})\)</span>至服务器。设<span class="math inline">\([x]=([x_{1}],...,[x_{n}])\)</span>，表示存储在服务器中的加密数据。<br></p><p>  在本文中，我们设<span class="math inline">\([·]\)</span>表示一个FHE加密的密文。在加密记录被上传后，客户可以使用三种算法进行安全搜索（查询，匹配，获取）<br></p><p>  (2)(query)客户发送加密查询<span class="math inline">\([q]\)</span>至服务器。<br></p><p>  (3)(match)服务器同态地在每一个记录<span class="math inline">\([x_{i}]\)</span>上评估查询<span class="math inline">\([q]\)</span>，以得到加密的匹配结果<span class="math inline">\([b]=([b_{1}],...,[b_{n}])\)</span>。也就是说，如果<span class="math inline">\(x_{i}\)</span>满足给定查询q，则<span class="math inline">\(b_{i}\)</span>是1，否则<span class="math inline">\(b_{i}\)</span>是0。<br></p><p>  (4)(fetch)给定<span class="math inline">\([b]\)</span>，服务器同态地计算<span class="math inline">\([i^{*}]\)</span>，其中<span class="math inline">\(i^{*}=min\{i\in{[n]:b_{i}=1}\}\)</span>，对应于第一个匹配记录索引。得到<span class="math inline">\([x_{i}]\)</span>并发送<span class="math inline">\(([i^{*}],[x_{i^{*}}])\)</span>给客户解密。<br></p><p>  <strong>匹配步骤中的乘法。</strong>Akavia等人同样提供了一种构造，在<span class="math inline">\(O(n\ log^{2}{n})\)</span>次同态乘法中执行fetch步骤。随后，人们提出了<span class="math inline">\(O(n\ logn)\)</span>次乘法和<span class="math inline">\(O(n)\)</span>次乘法的更高效的算法。</p><h2 id="动机">1.1 动机</h2><p>  <strong>瓶颈：按顺序获取记录。</strong>假设客户想要得到所有匹配项。在上述框架下，客户需要首先得到第一个匹配索引<span class="math inline">\(i^{*}\)</span>和它对应的项<span class="math inline">\(x_{i}\)</span>。为了得到第二个匹配项，客户应该把原来的查询q略微修改，变为新的查询<span class="math inline">\(q_{i^{*}}&#39;\)</span>，具体如下：<br></p><ul><li>如果<span class="math inline">\(q(i,x_{i})\)</span>为真且<span class="math inline">\(i&gt;i^{*}\)</span>，则<span class="math inline">\(q_{i^{*}}&#39;(i,x_{i})\)</span>返回真。</li></ul><p>  通过执行一个带有加密查询<span class="math inline">\([q_{i^{*}}&#39;]\)</span>的协议的新实例，客户将得到第二个匹配项。通过重复这一过程，客户将最终得到所有的匹配记录。<br></p><p>  注意查询<span class="math inline">\(q_{i^{*}}&#39;\)</span>将<span class="math inline">\(i^{*}\)</span>作为一个常数嵌入自身，这表明客户没有办法在不获得<span class="math inline">\(i^{*}\)</span>的情况下构造该查询<span class="math inline">\(q_{i^{*}}&#39;\)</span>。换句话说，客户只有在得到第一个匹配项后才能构造第二个匹配项的查询。从这个意义上说，框架内在地限制了客户端每次只能以顺序的方式获取一条匹配记录。<br></p><p>  如果存在ℓ匹配记录，客户和服务器将不得不执行ℓ查询、匹配和获取算法的实例。因为每个匹配和搜索步骤需要昂贵的同态乘法，顺序协议执行的限制在运行时间方面造成了严重的瓶颈。这导致我们提出了以下的自然问题：<br></p><p>  是否存在一个不同的安全搜索框架，允许客户通过较小次数的协议执行，获取所有匹配项，可能避免连续的记录获取？<br></p><p>  <strong>约简同态乘法。</strong>所有先前的方案都必须在获取步骤中进行<span class="math inline">\(\Omega(n)\)</span>同态乘法。由于同态乘法是昂贵的操作，我们希望减少这种计算，这就提出了以下的自然问题：<br></p><p>  能否减少获取步骤中同态乘法的数量？<br></p><p>  在本文中，我们回答了上述两个问题。</p><h2 id="我们的工作">1.2 我们的工作</h2><p>  <strong>并行化获取过程。</strong>为了解决这些问题，我们引入了一个新的安全搜索框架，在这个框架中，匹配项在一个恒定的轮次中被并行检索。我们的设置、查询和匹配算法与先前的工作一样。但是，我们修改了获取过程，将其分为两个步骤：编码和解码。在编码步骤中，服务器同态地将匹配项插入一个数据结构——具体结构取决于构造，我们提供了3中不同的构造，分别使用不同的编码。在接收加密编码后，客户解密该编码，并运行解码步骤恢复项。<br></p><p>  <strong>压缩不经意编码。</strong>编码是同态计算的，最重要的是，允许对整个结果集进行编码，而不仅仅是单个项。特别地，我们引入了压缩不经意编码(COE)的概念。一个压缩不经意编码以一个较大但稀疏的向量作为输入，并将其压缩为更小的编码，从中可以恢复原始向量的非零项。之所以编码是不经意的，是因为编码过程是在加密数据上执行的。在特定构造中，编码包括数据值(CODE，压缩不经意数据编码)，而在其他情况下，它只包含索引(COIE，压缩不经意索引编码)。后一种情况下，解码过程是交互式的，允许客户端从解码后的索引集中恢复数值。<br></p><p>  简单起见，在描述安全搜索方案的通用语法时，我们将编码过程表示为将索引和值都作为输入的情况，我们抑制了这样一个事实，当编码期间不使用值时，解码步骤必须是交互式的。回顾一下，我们使用<span class="math inline">\([b]=([b_{1}],...,[b_{n}])\)</span>表示匹配过程得到的加密比特向量。<br></p><p>  (4)(encode)设<span class="math inline">\(S=\{i\in{[n]}:b_{i}=1\},V={v_{i}:i\in{S}}\)</span>。服务器同态地评估<span class="math inline">\([encoding(S,V)]\)</span>并将其发送给客户。<br></p><p>  (5)(decode)客户解密<span class="math inline">\([encoding(S)]\)</span>并运行解码过程以恢复(S,V)。<br></p><p>  我们假设结果集<span class="math inline">\(|S|\)</span>是很小的(即在n是次线性的)。我们希望在n中压缩编码的大小是次线性的，以保持有意义的通信成本。<br></p><p>  编码步骤中没有乘法。为了确保编码结果的计算代价最小，我们同时想要最小化同态乘法的次数。回顾一下，最好的前期工作需要服务器进行<span class="math inline">\(O(n)\)</span>乘法。有些令人惊讶的是，我们演示了3种编码算法，可以在不进行同态乘法的情况下进行计算！<br></p><p>  使用PIR(私有信息检索)。图2展示了搜索协议的渐近复杂性和权衡。</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gygjjxqmvtj30o109yah2.jpg" /></p><p>  在我们的某些协议中(即BF-COIE和PS-COIE搜索协议；参见第4章和第6.3章)，索引和实际记录是分步骤获取的。这允许我们专注于优化索引的检索，之后可以使用高效(无设置)PIR协议获取值，从而实现整体节约。<br></p><p>  但是，如果不希望依赖于PIR，我们同时提供了一个直接获取值的变体(即图2中的w/BFS-CODE协议)，正如先前的工作。<br></p><p>  实现。我们实现了所有提出的方案并将它们的性能与先前的工作进行了比较。我们的实验证明了我们方案的性能比之前的获取过程高出1800倍，这使得整个搜索功能的速度提高了26倍。<br></p><h1 id="准备工作">2. 准备工作</h1><p>  设<span class="math inline">\(\lambda\)</span>是安全参数。对于向量<span class="math inline">\(a\)</span>，设<span class="math inline">\(nzx(a)\)</span>表示所有<span class="math inline">\(a_{i}\)</span>为非零项的位置i的集合，即<span class="math inline">\(nzx(a):=\{i:a_{i}\ne0\}\)</span><br></p><p>  <strong>切尔诺夫限。</strong>我们将使用如下版本的切尔诺夫限。<br></p><p>  <strong>定理2.1</strong> 设<span class="math inline">\(X_{1},...,X_{n}\)</span>是独立随机变量，其值位于{0,1}，从而有<span class="math inline">\(Pr[X_{i}=1]=p\)</span>。设<span class="math inline">\(\mu:=Exp[\sum{X_{i}}]=np\)</span>。则对于任意<span class="math inline">\(\delta&gt;0\)</span>，有<span class="math inline">\(Pr[\sum_{i=1}^{n}{X_{i}\ge(1+\delta)\mu}]\le(\frac{e^{\delta}}{(1+\delta)^{(1+\delta)}})^{\mu}\)</span><br></p><p>  <strong>FHE。</strong>我们使用标准的CPA安全(分级)全同态加密方案(Gen、Enc、Dec)。用<span class="math inline">\([x]\)</span>表示x的一个加密。<br></p><p>  我们同时使用<span class="math inline">\(+(·)\)</span>表示同态加法(乘法)。例如，<span class="math inline">\([c]:=[a]+[b]\)</span>意味着两个FHE密文<span class="math inline">\([a]\)</span>和<span class="math inline">\([b]\)</span>的同态加法，结果为<span class="math inline">\([c]\)</span>。<br></p><p>  <strong>PIR。</strong>PIR协议允许客户选择索引i并从一个(或更多)不受信任的服务器中检索i，而隐藏索引值i。<br></p><p>  假设k个服务器中每一个都有n条记录<span class="math inline">\(D=(d_{1},...,d_{n})\)</span>，其中所有项<span class="math inline">\(d_{i}\)</span>都有相同的长度。一轮k-服务器PIR协议由以下算法组成：<br></p><ul><li>查询算法<span class="math inline">\(Q_{j}(i,r)\to{q_{j}}\)</span>，服务器<span class="math inline">\(j\in{k}\)</span>，由客户端输入索引i和随机数r执行。</li><li>回答算法<span class="math inline">\(A_{j}(D,q_{j})\to{a_{j}}\)</span>，服务器<span class="math inline">\(j\in{k}\)</span>，由第j个服务器执行。</li><li>重新构造算法<span class="math inline">\(R(i,r,(a_{1},...,a_{k}))\to{d_{i}}\)</span>.</li></ul><p>PIR协议的通信复杂度由所有查询长度和回答长度的和定义，即<span class="math inline">\(\sum_{j\in{[k]}}{|q_{j}|+|a_{j}|}\)</span>。<br></p><p>  如果对任意<span class="math inline">\(D=(d_{1},...d_{n}),|d_{1}|=...=|d_{n}|,i\in{[n]}\)</span>，PIR协议是正确的，当<span class="math inline">\(Pr[R(i,r,\{A_{j}(D,Q_{j}(i,r))\}_{j=1}^{k})=d_{i}]=1\)</span>。如果对任意<span class="math inline">\(j\in{k},i_{0},i_{1}\in{[n]},i_{0}\ne{i_{1}}\)</span>，PIR协议是隐私的，当分布<span class="math inline">\(\{Q_{j}(i_{0},r)\}_{r}\approx{\{Q_{j}(i_{1},r)\}_{r}}\)</span>在计算上（或统计上）无法区分。</p><h2 id="布隆过滤器">2.1 布隆过滤器</h2><p>  布隆过滤器是一个著名的空间有效数据结构，允许用户插入任意关键词，然后检查过滤器中的某个关键词是否符合要求。<br></p><p>  <span class="math inline">\(BF.Init().\)</span>过滤器B本质是一个ℓ比特向量，其中ℓ是一个参数，初始化时为全零。该过滤器还与一组<span class="math inline">\(\eta\)</span>个不同哈希函数的集合有关<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to{[\mathcal{l}]}\}_{q=1}^{n}\)</span><br></p><p>  <span class="math inline">\(BF.Insert(B,\alpha).\)</span>为了插入关键词<span class="math inline">\(\alpha\)</span>，将哈希结果加入到过滤器中，特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\alpha)\)</span>，并设置<span class="math inline">\(B_{j}:=1\)</span>。<span class="math inline">\(B_{j}\)</span>是B的第j比特。<br></p><p>  <span class="math inline">\(BF.Check(B,\beta).\)</span>为检查关键词<span class="math inline">\(\beta\)</span>是否被插入到BF过滤器B中，可以直接用所有哈希结果来检查过滤器。特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\beta)\)</span>，并检查<span class="math inline">\(B_{j}\)</span>是否被设置；如果所有检查都通过则输出“yes”，否则输出“no”。<br></p><p>  过滤器的主要优势是它保证不会有false negatives，并允许一个可调的false positives：<span class="math inline">\((1-(1-\frac{1}{\mathcal{l}})^{\eta s})^{\eta}\approx(1-e^{-\frac{\eta s}{\mathcal{l}}})^{\eta}\)</span>，其中s是布隆过滤器中关键词的数量。<br></p><p>  <strong>哈希函数的随机预言模型。</strong>我们在随机预言模型上证明了我们的分析。也就是说，哈希函数被构造为随机函数。</p><h2 id="代数布隆过滤器">2.2 代数布隆过滤器</h2><p>  在这项工作中，我们利用了布隆过滤器的一个变体，当插入一项时，按位排序的OR操作被加法操作取代。有一些工作使用了类似的想法，让每个单元保存一个整数，而不是一个比特。<br></p><p>  此外，我们考虑了一个受限的场景，即预先知道要插入关键词数量的上界。特别地，设s表示该上界。<br></p><p>  与之前一样，过滤器还与<span class="math inline">\(\eta\)</span>个不同哈希函数的集合<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to{[\mathcal{l}]}\}_{q=1}^{n}\)</span>相关联。但是，现在该过滤器B不是一个ℓ比特向量，其每个元素都位于<span class="math inline">\([s\eta]\)</span>(即<span class="math inline">\(B\in{[s\eta]^{\mathcal{l}}}\)</span>)。因此，编码B的比特数被乘法因子<span class="math inline">\(\lceil{lg\ s\eta}\rceil\)</span>放大。<br></p><p>  下面描述的BF操作，其差异用框标记。<br></p><p>  <span class="math inline">\(BF.Insert(B,\alpha).\)</span>为了插入关键词<span class="math inline">\(\alpha\)</span>，将哈希结果加入到过滤器中，特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\alpha)\)</span>，并设置<span class="math inline">\(B_{j}:=B_{j}+1\)</span><br></p><p>  <span class="math inline">\(BF.Check(B,\beta).\)</span>为检查关键词<span class="math inline">\(\beta\)</span>是否被插入到BF过滤器B中，可以直接用所有哈希结果来检查过滤器。特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\beta)\)</span>，并检查<span class="math inline">\(B_{j}\)</span>是否大于0；如果所有的检查都通过则输出“yes”，否则输出“no”。<br></p><p>  很容易看出，这种变体构造与原BF构造具有相同的性能。</p><h1 id="压缩不经意编码">3. 压缩不经意编码</h1><p>  作为我们的主要构建块，我们引入了一个新的工具，我们称之为压缩不经意编码。压缩不经意编码将一个大但稀疏的向量作为输入，并将其压缩为一个更小的编码，从这个编码中可以恢复原向量的非零项。编码无关是因为编码过程对原始数据是无关的；事实上，在我们的构造中，原始数据都将被加密。一个有效编码必须满足以下两个性能要求：1)编码的大小必须是原始数组的大小的次线性，2)构造这种编码在计算上应该不昂贵。我们的构造只使用常数间(即明文值)的(同态的)加法和乘法。<br></p><p>  一个相关的概念是，对加密数据进行压缩目的是将一个向量的所有非零项放在编码的前面。我们的编码可以被看作噪声压缩的一种形式，其中除了保留所有非零项之外，还允许在结果中混入少量零项。因此，压缩编码用输出中的一些不准确性换取了更便宜的构造成本。<br></p><p>  我们定义了两种压缩不经意编码的变体，一种编码非零项的索引，另一种编码实际项本身。</p><h2 id="压缩不经意索引编码">3.1 压缩不经意索引编码</h2><p>  压缩不经意索引编码(COIE)编码输入数组中的所有非零项的索引或位置。我们首先定义COIE模式的参数和语法。<br></p><p>  <strong>参数。</strong>一个COIE方案参数化如下:</p><ul><li>n: Input size——输入向量v的维数。</li><li>s: Sparsity——v中非零项数目的界限。</li><li>c: Compactness——输出编码的维数。</li><li><span class="math inline">\(f_{p}\)</span>: False positives——解码算法返回的false positives数量的上限。</li></ul><p>  <strong>语法。</strong>一个<span class="math inline">\((n,s,c,f_{p})-COIE\)</span>方案有如下语法：</p><ul><li><span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\gets Encode([v_{1}],...,[v_{n}])\)</span>: 编码算法以密文向量<span class="math inline">\(v_{i}\in\{0,1\},i\in[n]\)</span>作为输入，输出加密编码<span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\)</span>.</li><li><span class="math inline">\(I\gets Decode(\gamma_{1},...,\gamma_{c})\)</span>: 解码算法以解密后的编码<span class="math inline">\((\gamma_{1},...,\gamma_{c})\)</span>作为输入，输出集合<span class="math inline">\(I\subseteq[n]\)</span>.</li></ul><p>  <strong>正确性。</strong>设<span class="math inline">\((\gamma_{1},...,\gamma_{c})\gets Dec([\gamma_{1}],...,[\gamma_{c}])\)</span>表示一个编码的正确解密。<br></p><p>  <strong>定义3.1</strong> 如果满足下列情况，则<span class="math inline">\((n,s,c,f_{p})-COIE\)</span>方案是正确的：</p><ul><li>(No false negatives)对于所有<span class="math inline">\(v\in\{0,1\}^{n}\)</span>，至多有s个非零位置，对于所有<span class="math inline">\(i\in{nzx(v)}\)</span>，有<span class="math inline">\(i\in Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>，其概率至少为<span class="math inline">\(1-negl(\lambda)\)</span>，其中random coins取自Encode</li><li>(Few false positives)对于所有<span class="math inline">\(v\in D^{n}\)</span>，至多s个非零位置，考虑false positives集合<span class="math inline">\(E=\{i\in[n]:v_{i}=0,but\ i\in I\}\)</span>，其中<span class="math inline">\(I=Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>。我们要求<span class="math inline">\(|E|\leqslant f_{p}\)</span></li></ul><p>  <strong>效率。</strong>为了效率，我们考虑以下COIE的三个参数：</p><ul><li>编码算法使用的操作类型和数量。</li><li>编码的大小。</li><li>解码算法的计算花销。</li></ul><p>  对于高效的构造，我们要求后两个在输入向量的大小上是次线性的。</p><h2 id="压缩不经意数据编码">3.2 压缩不经意数据编码</h2><p>  压缩不经意数据编码(CODE)与COIE非常类似，只是它编码的不是非零项的位置，而是这些项的值。我们给出CODE的定义如下，区别用框标记。<br></p><p>  <strong>参数。</strong>CODE方案由与COIE相同的四个参数进行参数化<span class="math inline">\((n,s,c,f_{p})\)</span>.<br></p><p>  <strong>语法。</strong>域D上的<span class="math inline">\((n,s,c,f_{p})-CODE\)</span>方案有如下语法：</p><ul><li><span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\gets Encode([v_{1}],...,[v_{n}])\)</span>: 编码算法以密文向量<span class="math inline">\(v_{i}\in D,i\in[n]\)</span>作为输入，输出加密编码<span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\)</span>.</li><li><span class="math inline">\(V\gets Decode(\gamma_{1},...,\gamma_{c})\)</span>: 解码算法以解密后的编码<span class="math inline">\((\gamma_{1},...,\gamma_{c})\)</span>作为输入，输出值的集合<span class="math inline">\(V=\{v_{i}:v_{i}\ne 0\}\)</span>.</li></ul><p>  <strong>正确性。</strong><br></p><p>  <strong>定义3.2</strong> 如果满足以下情况，则域D上的<span class="math inline">\((n,s,c,f_{p})-CODE\)</span>方案是正确的：</p><ul><li>(No false negatives)对于所有<span class="math inline">\(v\in\{0,1\}^{n}\)</span>，至多有s个非零位置，对于所有<span class="math inline">\(i\in nzx(v)\)</span>，有<span class="math inline">\(v_{i}\in Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>，其概率至少为<span class="math inline">\(1-negl(\lambda)\)</span>，其中random coins取自Encode</li><li>(Few false positives)对于所有<span class="math inline">\(v\in D^{n}\)</span>，至多s个非零位置，考虑false positives集合<span class="math inline">\(E=\{z\in V:z\ne v_{i}\ for\ any\ i\in nzx(v)\}\)</span>其中<span class="math inline">\(V=Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>。我们要求<span class="math inline">\(|E|\leqslant f_{p}\)</span></li></ul><h1 id="coie方案">4. COIE方案</h1><p>  我们假设输入索引向量<span class="math inline">\(v\in\{0,1\}^{n}\)</span>是稀疏的。特别地，在本文中我们假设<span class="math inline">\(s=o(n)\)</span>.</p><h2 id="warm-up构造">4.1 warm-up构造</h2><p>  使用代数BF，我们可以构造一个<span class="math inline">\((n,s,c,f_{p})-COIE\)</span>方案(参数c和f_{p}将在方案描述后进行计算)。<br></p><p>  <span class="math inline">\(Encode([v_{1}],...,[v_{n}])\)</span>编码算法工作如下：<br></p><p>  (1)初始化<span class="math inline">\([B]=([B_{1}],...,[B_{c}])\)</span>，对所有j有<span class="math inline">\(B_{j}=0\)</span>。设<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to{[\mathcal{l}]}\}_{q=1}^{n}\)</span>是相关联的哈希函数集合。<br></p><p>  (2)对<span class="math inline">\(i=1,...,n\)</span>:<br></p><p>   (a)对于<span class="math inline">\(q=1,...,\eta\)</span>，计算<span class="math inline">\(j=h_{q}(i)\)</span>并设置<span class="math inline">\([B_{j}]:=[B_{j}]+[v_{i}]\)</span><br></p><p>  注意上述步骤2.a，若<span class="math inline">\(v_{i}=0\)</span>，则<span class="math inline">\(B_{j}\)</span>保持不变。另一方面，若<span class="math inline">\(v_{i}=1\)</span>，则<span class="math inline">\(B_{j}\)</span>将增加1。这表明B将准确地存储操作<span class="math inline">\(\{BF.Insert(B,i):i\in nzx(v)\}\)</span>的结果。<br></p><p>  <span class="math inline">\(Decode(B_{1},...,B_{c})\)</span>给定代数BF B，我们可以恢复非零元素的索引如下：</p><ul><li>初始化I为空集合。</li><li>对于<span class="math inline">\(i\in[n]\)</span>: 如果<span class="math inline">\(BF.Check(B,i)=yes\)</span>，将i加到I中。</li><li>返回I。</li></ul><p>  <strong>参数𝑐和<span class="math inline">\(f_{p}\)</span>。</strong>因为这是一个warm-up构造，我们只粗略地估计false positive参数和compactness参数。<br></p><p>  出于后续原因，我们希望保持false positives<span class="math inline">\((f_{p})\)</span>的数量上限较小。特别地，我们使用false-positive率为1/n的BF。因为存在n个BF.Check操作，预计的false positive的数量为1，从切尔诺夫限出发，false positive的数量以<span class="math inline">\(Ω(log𝜆)\)</span>为界，在𝜆中具有压倒性的概率。这表明有<span class="math inline">\(f_{p}=\Omega(log\lambda)\)</span>。<br></p><p>  布隆过滤器B的维数c可以使用如下BF false positive比率方程计算得出：<span class="math inline">\((1-e^{-\frac{\eta s}{c}})^{\eta}\leqslant\frac{1}{n}\)</span><br></p><p>  <span class="math inline">\(c=\eta s·n^{\frac{1}{\eta}}\)</span>满足方程。这一点可以使用<span class="math inline">\(1-e^{-x}\leqslant x,x\in[0,1]\)</span>证实: <span class="math inline">\(1-e^{-\frac{\eta s}{c}}\leqslant\frac{\eta s}{c}=1/n^{1/\eta}\)</span><br></p><p>  <strong>效率。</strong></p><ul><li>编码算法使用<span class="math inline">\(n\eta\)</span>同态加法操作以及<span class="math inline">\(n\eta\)</span>哈希函数。</li><li>编码的维数c为<span class="math inline">\(\eta s·n^{\frac{1}{\eta}}\)</span>。通常设置𝜂在2和32之间。</li><li>解码算法使用n次BF.Check的操作。</li></ul><p>  总的来说，我们已经约简编码大小c为n上的次线性。但是，我们仍然需要约简解码中的BF.Check操作的数量为n上的次线性。我们在下一个构造中证明了如何实现。</p><h2 id="bf-coie">4.2 BF-COIE</h2><p>  我们现在展示如何改进上述构造，实现在时间o(n)内解码。该改进的主要思想是使用布隆过滤器来表示一个二叉搜索树，树的每一层都是一个BF。我们可以指导解码算法避免不包含非零项的解码分支。由于大多数分支可以在达到叶级布隆过滤器之前被截断，这导致了次线性的总成本。<br></p><p>  <strong>例子。</strong>在介绍这个构造的正式协议之前，我们通过一个例子来表达我们的想法。设n=32，假设我们希望编码索引<span class="math inline">\(I=\{1,15,16\}\)</span>。定义<span class="math inline">\(I^{k}=\{\lceil\frac{i}{2^{k}}\rceil:i\in I\}\)</span>。<span class="math inline">\(I^{k}\)</span>中的一个元素i可以看作长度为<span class="math inline">\(2^{k}\)</span>的一个范围<span class="math inline">\([(i-1)·2^{k}+1,i·2^{k}]\)</span>。有：</p><ul><li><span class="math inline">\(I^{4}=\{1\}\)</span></li><li><span class="math inline">\(I^{3}=\{1,2\}\)</span></li><li><span class="math inline">\(I^{2}=\{1,4\}\)</span></li><li><span class="math inline">\(I^{1}=\{1,8\}\)</span></li><li><span class="math inline">\(I^{0}=\{1,15,16\}\)</span></li></ul><p>  现在假设我们将每个集合<span class="math inline">\(I^{k}\)</span>插入到它自己的BF。我们可以通过便利这些BF来解码集合<span class="math inline">\(I\)</span>，如下：<br></p><p>  (1)检查<span class="math inline">\(I^{4}\)</span>的所有可能索引。因为n=32，<span class="math inline">\(I^{4}\)</span>将原始索引除以<span class="math inline">\(2^{4}=16\)</span>，得到这一层的可能索引是1和2。<br></p><p>  在上述例子中，当我们查询<span class="math inline">\(I^{4}\)</span>的BF，只包含索引1，这意味着I中不包含大于16的值。因此我们可以避免在较低级别检查任何这样的索引。<br></p><p>  现在考虑下一级的BF(即<span class="math inline">\(I^{3}\)</span>的BF)。这一层的可能索引为1、2、3、4，但是因为我们已经知道I中没有大于16的值，只需要检查1、2(因为3*8&gt;16).<br></p><p>  (2)检查<span class="math inline">\(I^{3}\)</span>的索引1、2。BF显示索引1、2都存在，这意味着我们要检查<span class="math inline">\(I^{2}\)</span>中的索引1、2和3、4。<br></p><p>  (3)检查<span class="math inline">\(I^{2}\)</span>的索引1、2、3、4。BF显示索引1和4存在，这意味着我们只需要检查<span class="math inline">\(I^{1}\)</span>中的索引1、2和7、8，其他索引可以跳过。<br></p><p>  (4)检查<span class="math inline">\(I^{1}\)</span>的索引1、2、7、8。BF将显示索引1和8存在，这意味着我们需要检查索引1、2和15、16。<br></p><p>  (5)检查<span class="math inline">\(I^{0}\)</span>的索引1、2、15、16，并输出最终索引1、2、15、16。<br></p><p>  现在假设不存在false positives，这种方法在每个层次最多检查<span class="math inline">\(2|I|\)</span>个值，且只有<span class="math inline">\(lg\ n\)</span>个层次。因此，解码算法将检查<span class="math inline">\(O(|I|·lg\ n)\)</span>个索引，这在n上是次线性的。<br></p><p>  <strong>BF-COIE。</strong>现在描述我们的BF-COIE构造。与之前一样，我们将在描述我们的构造后计算出参数。编码算法描述在算法1中。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyiq2qbb2lj30o10dz7bi.jpg" /></p><p>  注意上述的步骤(a)到(c)，warm-up构造被用于构造索引<span class="math inline">\(I^{k}\)</span>的BF <span class="math inline">\(B^{k}\)</span>。<br></p><p>  为了约简输出编码的大小，我们设置t为<span class="math inline">\(lg\ \frac{n}{2s}\)</span>而不是<span class="math inline">\(lg\ n\)</span>。注意当t以这种方式设置，<span class="math inline">\(I^{t}\)</span>包含至多<span class="math inline">\(n/2^{t}=2s\)</span>个可能值。<br></p><p>  解码算法描述在算法2中。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyir66u6cmj30o10a243g.jpg" /></p><p>  <strong>有用的引理。</strong>下列引理将用于分析参数c和<span class="math inline">\(f_{p}\)</span>。<br></p><p>  <strong>引理4.1</strong> 考虑误报率为1/m的布隆过滤器，其中m是一个任意正整数。假设BF中至多执行m次BF.Check操作。则对任意<span class="math inline">\(δ&gt;0\)</span>，有：<span class="math inline">\(Pr[\#\ false\ positives \ge 1+\delta]\le \frac{e^{\delta}}{(1+\delta)^{1+\delta}}\)</span><br></p><p>  附录A中给出了应用切尔诺夫限的证明。<br></p><p>  关于上述引理，我们注意到设置<span class="math inline">\(\delta=\Omega(log\ \lambda)\)</span>，有<span class="math inline">\(Pr[\sum_{i=1}^{m}{X_{i}\ge 1+\delta}]=negl(\lambda)\)</span><br></p><p>  <strong>参数c和<span class="math inline">\(f_{p}\)</span>。</strong> 我们设置BF-COIE方案的false positive上限<span class="math inline">\(f_{p}:=\Omega(log\ \lambda)\)</span>。在我们的实验中，设置<span class="math inline">\(𝑓_{𝑝}=16\)</span>。<br></p><p>  现在设<span class="math inline">\(m=max(2s,s+2f_{p})\)</span>，设置BF误报率为1/m。回顾一下BF-COIE构造，最上面的BF<span class="math inline">\(B^{t}\)</span>执行2s次BF.Check操作；参见算法2的第(2)行使用上述引理，顶层BF<span class="math inline">\(B^{t}\)</span>的false positives数量至多为<span class="math inline">\(𝑓_{𝑝}\)</span>，以几乎可以忽略不计的概率<span class="math inline">\(λ\)</span>。此外，<span class="math inline">\(B_{t}\)</span>的索引i被展开为<span class="math inline">\(B^{t-1}\)</span>中的两个索引2i-1和2i。这意味着由于<span class="math inline">\(B^{t}\)</span>的false positives，<span class="math inline">\(B^{t-1}\)</span>中检查出的错误索引的数量至多为<span class="math inline">\(2f_{p}\)</span>。<br></p><p>  现在考虑一个属于<span class="math inline">\(B_{t}\)</span>的索引i。算法2将在<span class="math inline">\(B^{t-1}\)</span>的值2i-1和2i运行BF.Check。因为这些值中至少有一个必须属于<span class="math inline">\(B^{t-1}\)</span>，这导致至多一个错误索引被检查出。因此，<span class="math inline">\(B^{t-1}\)</span>中能够检查出的错误索引的最大数量至多为<span class="math inline">\(s+2f_{p}\)</span>(即<span class="math inline">\(2f_{p}\)</span>来自<span class="math inline">\(B_{t}\)</span>的false positives，s来自<span class="math inline">\(B_{t}\)</span>的true positives)。<br></p><p>  上述论点归纳地适用于最底层，这意味着将在每个层次BF <span class="math inline">\(B_{i}\)</span>将检查的最大错误索引数最多为<span class="math inline">\(s+2f_{p}\)</span>。最后，底部BF将有至多<span class="math inline">\(f_{p}\)</span>false positives，以及整体BF-COIE方案将有至多<span class="math inline">\(f_{p}\)</span>false positives，以几乎可以忽略不计的概率<span class="math inline">\(\lambda\)</span>。<br></p><p>  对于compactness参数c，我们必须决定每个BF的维数ℓ。回顾一下，我们设置BF false positive率为1/m，<span class="math inline">\(m=max(2s,s+2f_{p})\)</span>: <span class="math inline">\((1-e^{-\frac{\eta s}{\mathcal{l}}})\)</span>。设置<span class="math inline">\(\mathcal{l}=\eta·s·m^{\frac{1}{\eta}}\)</span>满足上述条件，可以使用不等式<span class="math inline">\(1-e^{-x}\le x\)</span>证明，x∈[0, 1]；<span class="math inline">\(1-e^{-\frac{\eta s}{\mathcal{l}}}\le \frac{\eta s}{\mathcal{l}}=(1/m)^{1/\eta}\)</span>.<br></p><p>  因为编码有t+1 BF，总的compactness参数如下：<span class="math inline">\(c=(t+1)·\mathcal{l}=O(\eta·s^{1+\frac{1}{\eta}}·lg\frac{n}{s})\)</span><br></p><p>  <strong>效率。</strong></p><ul><li>编码的大小c为<span class="math inline">\(O(\eta·s^{1+\frac{1}{\eta}}·lg\frac{n}{s})\)</span>。在我们的实验中，选择ŋ=2。</li><li>编码算法使用<span class="math inline">\(O(\eta·n·lg\frac{n}{s})\)</span>次同态加法操作和哈希函数。</li><li>解码算法使用<span class="math inline">\(O(s\ lg\frac{n}{s})\)</span>次BF.Check操作。</li></ul><p>  总的来说，假设s=o(n)，我们约简编码大小c为n上的次线性。此外，我们也约简BF.Check操作的数量为n上的次线性。<br></p><p>  <strong>备注。</strong>尽管方案中存在乘法BF，编码c的大小要比warm-up方案更小！这是由于BF的乘法层次，我们可以放宽每个BF的false positive率。编码计算次数减少一个乘法参数<span class="math inline">\(lg\frac{n}{s}\)</span>.<br></p><h2 id="基于指数和的coie方案">4.3 基于指数和的COIE方案</h2><p>  <strong>使用指数和代替false positive。</strong>我们提供了另一个编码方案，使用完全不同的技术，可以消除之前构造的false positives。为了实现这一点，我们放弃了布隆过滤器，而是使用指数和编码，就像在使用DC-Nets进行匿名广播的若干工作中所做的那样。<br></p><p>  <strong>PS-COIE。</strong>我们描述了一个基于指数和的COIE方案，称为PS-COIE。与之前一样，我们将在描述构造之后计算参数。编码算法如下。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyisyn7174j30o105oac8.jpg" /></p><p>  注意<span class="math inline">\(i^{j}\)</span>的值（模底层明文模数）是公共可计算的，因此计算<span class="math inline">\(i^{j}·[v_{i}]\)</span>只需要标量乘法，而没有同态乘法。<br></p><p>  回顾一下，<span class="math inline">\(v_{i}\in \{0,1\}\)</span>。如果我们设<span class="math inline">\(I=\{i:v_{i}=1\}\)</span>表示非零元素的索引，则<span class="math inline">\(w_{j}=\sum_{i=1}^{n}{i^{j}·v_{i}}=\sum_{i\in I}{i^{j}}\)</span>。因此，<span class="math inline">\(w_{j}\)</span>索引的j次指数和。使用指数和，我们在算法4中展示了使用指数和的解码算法。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyit6tpiu0j30o10jhn63.jpg" /></p><p>  <strong>参数c和<span class="math inline">\(f_{p}\)</span>。</strong> COIE方案没有false positives；因此<span class="math inline">\(f_{p}=0\)</span>.compactness参数c等于s。<br></p><p>  <strong>效率。</strong><br></p><ul><li>编码算法使用𝑠·𝑛同态加法操作和标量乘法。</li><li>编码由s个密文组成。</li><li>解码算法在<span class="math inline">\(O(s^{2})\)</span>内计算系数。使用Cantor-Zassenhaus算法，S次多项式的根可以在<span class="math inline">\(O(s^{3}log\ p)\)</span>内找到，其中p是底层FHE的明文模数。</li></ul><h1 id="code方案">5. CODE方案</h1><p>  在之前的章节中，我们展示了COIE方案的两种构造，使用次线性存储对索引向量进行编码。现在我们来看CODE方案的构造，它编码实际的数据值，而不是编码非零项的索引。<br></p><p>  <strong>简化的key-value存储。</strong>为了构造我们的CODE方案，我们首先构造一个辅助数据结构，它支持下列操作：<br></p><ul><li><span class="math inline">\(Init()\)</span>.初始化数据结构。</li><li><span class="math inline">\(Insert(key.value)\)</span>.该操作允许用户基于它的key和values插入项。</li><li><span class="math inline">\(Values()\)</span>.返回插入的所有值。</li></ul><p>  该数据结构要比典型的key-value存储更简单，因为它不需要按key查找单个项。但是注意，这仍然足以满足我们构建CODE方案的目的。</p><h2 id="bf集合">5.1 BF集合</h2><p>  我们现在展示如何使用我们称为布隆过滤器集合（BFS）的数据结构来实例化一个简化的key-value存储，该数据结构基于2.2章中给出的代数布隆过滤器。为了插入一对(key, value)，布隆过滤器集合存储实际值，而不是一个索引比特。与之前类似，通过将值添加到key的哈希所指示的位置来插入项。<br></p><p>  <strong>输入数据格式。</strong>在构造中，我们假定插入数据的格式。具体来说，我们假设所有插入值都包含一个唯一的校验和（例如，一个值的加密哈希）。我们假设该校验和足够长，校验和的一个随机和不会给出一个有效的校验和，以可忽略的概率（λ的一个函数）。<br></p><p>  <strong>构造。</strong>我们首先描述数据结构的构造。下面我们将展示如何选择参数，以便客户能够从这个布隆过滤器中以压倒性的概率提取所有匹配项。<br></p><ul><li><span class="math inline">\(BFS.Init()\to (B,\mathcal{H})\)</span>.创建一个ℓ维向量B，其中每个元素都可以存储域D中任意可能的值。选择ŋ不同哈希函数的一个集合<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to [\mathcal{l}]\}_{q=1}^{\eta}\)</span>。初始化<span class="math inline">\(B_{i}:=0,i\in[\mathcal{l}]\)</span>.</li><li><span class="math inline">\(BFS.Insert(B,\mathcal{H},key,\alpha)\)</span>.为了插入<span class="math inline">\((key,\alpha)\)</span>，我们将<span class="math inline">\(\alpha\)</span>加到key的哈希所指示的位置的值中。具体地说，对于<span class="math inline">\(q\in[\eta]\)</span>:计算<span class="math inline">\(j=h_{q}(key)\)</span>并设置<span class="math inline">\(B_{j}:=B_{j}+\alpha\)</span>.</li><li><span class="math inline">\(BFS.Values(B)\)</span>.)初始化集合V为空集。对于<span class="math inline">\(j\in[\mathcal{l}]\)</span>，如果<span class="math inline">\(B_{j}\)</span>有一个有效的校验和，则将<span class="math inline">\(B_{j}\)</span>添加到V。最后输出V。</li></ul><p>  我们注意到，正如Goodrich先前提出的那样，可以通过维护一个每个位置插入值的数量的计数器来避免校验和。则BFS.Values只返回计数器为1的位置的值。<br></p><p>  <strong>参数。</strong>我们展示了如何设置布隆过滤器参数，以保证所有值都能以几乎可以忽略的概率恢复。我们假设知道插入值的数量的上界s。引入如下引理。<br></p><p>  <strong>引理5.1</strong> 如果至多s个值被插入到BFS数据结构，则通过设置𝜂和ℓ，有<span class="math inline">\(\mathcal{l}\ge 2(s\eta-1)\)</span> ，我们可以以至少<span class="math inline">\(1-s·(1/2)^{\eta}\)</span>的概率恢复所有s值。<br></p><p>  <strong>证明。</strong>考虑一个(key, value)对<span class="math inline">\((k_{i},\alpha_{i})\)</span>。如果这一对的每一个哈希位置都被另一个插入的键值对占据，那么这一对就会完全冲突。在这种情况下，<span class="math inline">\(\alpha_{i}\)</span>不能被恢复。另一方面，如果至少一个哈希位置没有冲突，则我们可以恢复该值。注意冲突取决于键<span class="math inline">\(𝑘_{i}\)</span>而不是值<span class="math inline">\(\alpha_{i}\)</span>.<br></p><p>  对于给定的键<span class="math inline">\(𝑘_{i}\)</span>，我们定义事件<span class="math inline">\(TCOL(k_{i})\)</span>:<span class="math inline">\(TCOL(k_{i})=1\ if\ \forall q\in[\eta],\exists(k&#39;,q&#39;)\ne(k_{i},q):h_{q}(k_{i})=h_{q&#39;}(k&#39;)\)</span>.这里k'可以是已经插入到集合中的任意项的键。因为集合包含至多s项，存在至多s可能的键k'。ŋ哈希函数被应用于每个项。<br></p><p>  因为对于每个<span class="math inline">\(𝑘_{i}\)</span>，存在至多𝜂𝑠−1对<span class="math inline">\((k&#39;,q&#39;)\)</span>与<span class="math inline">\((k_{i}, q)\)</span>不同，我们可以将冲突概率限制如下：<span class="math inline">\(Pr[TCOL(k_{i})]\le (\frac{(\eta s-1)}{l})^{\eta}\)</span><br></p><p>  因此，如果我们选择𝜂和ℓ，<span class="math inline">\(\mathcal{l}\ge 2(s\eta-1)\)</span>，则<span class="math inline">\(Pr[TCOL(k_{i})]\le (1/2)^{\eta}\)</span>.<br></p><p>  <span class="math inline">\(\mathcal{l}\ge 2(s\eta-1)\)</span>，则<span class="math inline">\(Pr[\exists k_{i}:TCOL(k_{i})]\le (1/2)^{\eta}\)</span>.</p><h2 id="基于bf集合的code方案">5.2 基于BF集合的CODE方案</h2><p>  在本节，我们构造一个CODE方案。回顾一下，不同于COIE方案中对索引进行编码，CODE方案以压缩方式编码数据。我们的构造的主要思想是模拟BFS的操作；称我们的方案为BFS-CODE。<br></p><p>  <strong>预处理输入数据。</strong>正如在描述BF集合构造时提到的，我们需要预处理输入数据，从而使每个项都附有其校验和。尽管数据项v表示为单个数字，假设v可以分解为实际值v.val和校验和v.tag。此外，我们假设校验和足够长，从而校验和的一个随机线性组合产生一个有效校验和的可能性微乎其微(即<span class="math inline">\(|𝑐ℎ𝑒𝑐𝑘𝑠𝑢𝑚|=𝜔(𝜆)\)</span>)。</p><p>  我们强调当我们的CODE方案被用于安全搜索时，在对数据进行加密之前，该预处理可以在客户本地执行。此外，计算校验和仅仅增加很少的开销。<br></p><p>  <strong>BFS-CODE。</strong>现在我们描述域D上的<span class="math inline">\((𝑛,𝑠,𝑐,𝑓_{𝑝})-BFS-CODE\)</span>构造。与之前一样，描述构造后将计算出参数。编码算法如下。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyiwldu4v4j30o1091q7v.jpg" /></p><p>  解码算法很简单，描述于算法6。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyiwlkjk63j30o103cmyc.jpg" /></p><p>  注意上述步骤4中，如果<span class="math inline">\(v_{i}\)</span>为0，则<span class="math inline">\(B_{j}\)</span>保持不变。另一方面，如果<span class="math inline">\(v_{i}\)</span>不为0，<span class="math inline">\(B_{j}\)</span>将增加<span class="math inline">\(v_{i}\)</span>。这表明B将准确地保存操作<span class="math inline">\(\{BFS.Insert(B,\mathcal{H},i,v_{i}):i\in nzx(v)\}\)</span>的结果。<br></p><p>  <strong>正确性。</strong>这直接来自底层加密方案加法同态和BFS的参数。特别地，我们设置<span class="math inline">\(𝜂=𝜆+lg\ 𝑠\)</span>，从而恢复误差的可能性至多为<span class="math inline">\(2^{λ}\)</span>.<br></p><p>  <strong>参数c和<span class="math inline">\(f_{p}\)</span>。</strong>附加到数据项上的校验和确保我们没有false positives，即<span class="math inline">\(𝑓_{𝑝}=0\)</span>。compactness参数c是BF的维数ℓ，为𝑂(𝜂𝑠)。<br></p><p>  效率。<br></p><ul><li>编码算法使用ℓ=𝑂(𝜂𝑠)加密操作，𝜂·n乘法操作，和𝜂·n哈希函数。</li><li>编码由ℓ密文组成。</li><li>解码算法使用ℓ解密操作。</li></ul><p>  根据引理5.1，布隆过滤器的大小ℓ只依赖于匹配项s的数量和哈希函数𝜂的数量，我们知道，上述协议的通信复杂度与数据库大小n无关。</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础知识</title>
    <link href="/2022/01/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/01/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="多项式环">多项式环</h1><p>环上的多项式：设R是一个有单位元1的交换环，x是R上的一个未定元，<span class="math inline">\(a_{0},a_{1},a_{2},...,a_{n}∈R\)</span>，称形如<span class="math inline">\(f(x)=a_{0}+a_{1}x+a_{2}x^{2}+...+a_{n}x^{n}\)</span>的表达式为R上x的一个多项式，其中<span class="math inline">\(a_{i}x^{i}\)</span>称为多项式f(x)的i次项，<span class="math inline">\(a_{i}\)</span>称为i次项的系数，如果<span class="math inline">\(a_{n}≠0\)</span>，则称f(x)的次数为n，记作deg f(x)=n。<br><br> 环R上所有关于x的多项式构成的集合记为R[x]。<br><br></p><h1 id="范数">范数</h1><ul><li>1范数<br> 所有元素绝对值的和<br> <span class="math inline">\(||x||_{1}=|x_{1}|+|x_{2}|+...+|x_{n}|\)</span></li><li>2范数<br> 所有元素平方和的开方<br> <span class="math inline">\(||x||_{2}=\sqrt{|x_{1}|^{2}+|x_{2}|^{2}+...+|x_{n}|^{2}}\)</span></li><li>无穷范数<br> 正无穷范数：所有元素中绝对值最大的<br> <span class="math inline">\(||x||_{\infty}=max(|x_{1}|,|x_{2}|,...,|x_{n}|)\)</span><br> 负无穷范数：所有元素中绝对值最小的<br> <span class="math inline">\(||x||_{-\infty}=min(|x_{1}|,|x_{2}|,...,|x_{n}|)\)</span><br></li></ul><h1 id="扩张因子">扩张因子</h1><p>设剩余类环<span class="math inline">\(R=\mathbb{Z}[x]/(f(x)),f(x)∈\mathbb{Z}[x]\)</span>是<span class="math inline">\(\mathbb{Z}\)</span>上的首一多项式，<span class="math inline">\(\forall{u(x),v(x)∈R}\)</span>，称<span class="math inline">\(\gamma=sup\{\frac{||u(x)×v(x)||_{\infty}}{||u(x)||_{\infty}·||v(x)||_{\infty}}:u(x),v(x)∈R\}\)</span>为环R的无穷范数的扩张因子。</p><h1 id="分圆多项式">分圆多项式</h1><p>分圆多项式是指某个n次本原单位根满足的最小次数的首一整系数多项式（必定是不可约多项式）。</p><h1 id="切尔诺夫限">切尔诺夫限</h1><p>https://math.mit.edu/~goemans/18310S15/chernoff-notes.pdf</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用符号</title>
    <link href="/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0hurd7nj30hz05gmzd.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0iwqbipj30l50b8dkl.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0j96699j30m70ffagw.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jj0iubj30l70cbjwf.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jq9b2wj30ka06stb3.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jxopg5j30iw0g810m.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ke2w2uj30jt08z77k.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0kml5r6j30hb068dh2.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ktjbqoj30pp0bs79c.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0l2hinaj30nb05pdhi.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0la0f9mj30kv04wdh4.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0lg44vdj30mc03b0ts.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0llz84tj30it0gp7es.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ltudk8j30fd0c9jxk.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m15qttj30iu0g2129.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m7mr72j30gp07pwi6.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mcw5zij30i707ztci.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mle0q3j30lt07vq7h.jpg" /></p><p>转自：<a href="https://blog.csdn.net/Ying_Xu/article/details/51240291" class="uri">https://blog.csdn.net/Ying_Xu/article/details/51240291</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCS19</title>
    <link href="/2022/01/12/CCS19/"/>
    <url>/2022/01/12/CCS19/</url>
    
    <content type="html"><![CDATA[<center><big>Efficient Multi-Key Homomorphic Encryption with Packed Ciphertexts with Application to Oblivious Neural Network Inference</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  同态加密（HE）是一个支持对密文数据进行操作的密码系统，lópez-Alt 等人提出了一个广义的HE概念，称为多密钥同态加密（MKHE），能够对不同密钥加密的密文执行算术运算。<br></p><p>  在本论文中，我们提出了两种基于压缩密文的多密钥HE方案变体。给出了新的重新线性化算法，比之前等人的方案更简单、更快。然后我们概况了HE的自举性技术，以得到多密钥全同态加密方案。使用Microsoft SEAL提供了两个MKHE方案的概念验证实现。例如，当基环的维数为8192时，与四方相关联的多密钥BGV密文之间的同态乘法以及随后的重新线性化大约用时116毫秒。<br></p><p>  我们的MKHE方案在多个数据提供者之间的安全计算中有着广泛的应用，作为基准，我们使用预训练的卷积神经网络模型对图像进行同态分类，其中输入数据和模型使用了不同的密钥进行加密。我们需要大约1.8秒来实现对MNIST数据集中一个加密图像的一个卷积层和两个完全连接的层的评估。</p><h1 id="介绍">1. 介绍</h1><p>  推动新的科学发现产生和使用了大量数据，有效并负责任地利用大数据仍然是一个巨大的挑战。这个问题可以通过外包给拥有密集计算资源的公共云服务提供商来缓解。但是，在外包数据分析的隐私和安全性方面仍然存在问题。在过去几年里，用于安全计算的密码技术已经取得了重大进展。在安全计算方面的技术中，多方计算（MPC）和同态加密（HE）由于技术上的突破而受到了越来越多的关注。<br></p><p>  MPC的历史可以追溯到三十年前，从那时起理论界就对其进行了深入研究。在多方计算中，两个或多个参与方参与协议交互，来对输入的私有数据进行计算，只有函数的输出会显示给参与方。近年来，人们在提高MPC的实际效率方面进行了大量的工作，最先进的协议在性能方面取得了数量级的改进。但是就通信复杂度而言，这些协议本质上仍然是低效的：协议期间，参与各方需要交换的比特数与函数的复杂性和参与方数目之间的乘积成正比。因此，高通信复杂度仍然是MPC协议的主要瓶颈。<br></p><p>  此外，上述MPC协议对于基于云的应用程序可能并不可取，因为所有相关方都需要执行与功能复杂性成比例的本地计算。但是在实际中，我们不能期望数据提供者在整个协议执行期间执行大量的工作或一直保持在线。因此提出了另一种模型，其中数据所有者与少量独立服务器私密地共享数据，这些服务器再执行MPC来生成计算结果。这些协议具有良好的性能，它们将负担从数据提供者转移到了服务器，但是它们的隐私保证依赖于服务器不相互串通的假设。<br></p><p>  HE指的是一种密码系统，允许在加密数据上进行计算，而无需解密数据，从而能够在不受信任的云中安全地外包计算。在Gentry首次构造后（基于理想格的全同态加密方案），HE的技术有了重大进步。例如，可以将多个明文值加密为单个压缩密文，并使用单指令多数据技术（SIMD）对这些值并行执行操作。因此，具有压缩技术的HE方案的每个明文值具有良好的摊销复杂度，并且已经被应用在隐私保护的大数据分析中。但是，传统的HE方案只允许计算同一密钥下可进行解密的密文。因此，HE并不支持存在多个数据提供者的安全计算应用程序，每个数据提供者都提供自己的密钥。<br></p><p>  lópez-Alt 等人提出了一种MKHE方案，它是一种密码原语，支持密文上的算术运算，而密文不要求需要使用同一密钥解密。除了解决上述HE的问题外，MKHE还可用于以最小的通信成本设计高效的MPC协议。此外，基于MKHE的MPC协议满足动态MPC属性，其中待评估的电路可以在数据提供者上传其加密数据后动态决定。<br></p><p>  尽管MKHE具有多功能性，但在实践中很少使用。早期的研究使用了GSW方案的多密钥变体。这些结构具有较大的密文，且它们的性能不能很好地随参与方的数量而扩展。以前的工作提出了短密文的MKHE方案，并警告一个密文只加密一个比特位。现在唯一的具有压缩密文的MKHE方案是BGV方案的多密钥变体。请注意，上述所有研究都是纯粹抽象的，没有给出实现，支持SIMD操作的MKHE方案是否可行仍然是一个悬而未决的问题。</p><h2 id="贡献">1.1 贡献</h2><p>  我们设计了BFV和CKKS方案的多密钥变体。提出了一种新的生成重新线性化密钥的方法，该方法比以前的技术更简单、更快。此外，我们将这些方案的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥全同态加密。最后，我们给出了使用Microsoft SEAL实现的多密钥方案的概念证明，并给出了实验结果。据我们所知，这是第一个支持压缩密文的MKHE方案的实际实现。<br></p><p>  我们还提出了第一个可行的MKHE应用，能够安全地评估一个预训练卷积神经网络（CNN）模型。我们构造了一个高效的协议，其中云服务器使用模型提供者提供的分类器向数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。我们的方案支持多密钥操作，因此可以在较低的端到端延迟下实现这一点，并且数据和模型提供者的成本接近最优（如图Fig.1）。服务器可以存储不同密钥加密的大量密文，但特定任务的计算成本仅取决于与电路相关的参与方的数量。我们注意到，我们的解决方案比单密钥HE具有优势， 因为ML模型提供者不需要将未加密的模型发送到服务器。</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyayrs3t5vj30o108twgv.jpg" /></p><h2 id="构造概述">1.2 构造概述</h2><p>  设分圆环<span class="math inline">\(R=\mathbb{Z}[X]/(x^{n}+1)\)</span>，<span class="math inline">\(s_{i}∈R\)</span>是第i方的秘密，构造基于环的MKHE方案的出发点是要求生成的方案能够在独立生成的密钥下处理密文上的同态计算。与K个不同方相关联的MKHE方案的密文形式为<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})∈R_{q}^{k+1}\)</span>，其中模数q可以由级联的密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>解密。换句话说，其相位<span class="math inline">\(μ=&lt;\overline{ck},\overline{sk}&gt;(mod\ q)\)</span>是对应于基本方案的密文消息m的随机编码。<br></p><p>  BFV或CKKS的同态乘法包含两个步骤：张量积与再线性化。两个输入密文的张量积满足<span class="math inline">\(&lt;\overline{ct_{1}}\otimes\overline{ct_{2}},\overline{sk}\otimes\overline{sk}&gt;=&lt;\overline{ct_{1}},\overline{sk}&gt;·&lt;\overline{ct_{2}},\overline{sk}&gt;\)</span>，因此它是在<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>下的有效加密。在重新线性化步骤中，我们的目标是将扩展密文<span class="math inline">\(\overline{ct}=\overline{ct_{1}}\otimes\overline{ct_{2}}∈R_{q}^{(k+1)^{2}}\)</span>转换为在<span class="math inline">\(\overline{sk}\)</span>下加密相同消息的规范密文。此步骤可以理解为一个密钥切换过程，需要对<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>进行特殊加密。我们注意到，<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>包含依赖于两个不同方的项<span class="math inline">\(s_{i}s_{j}\)</span>。因此，与传统HE方案不同的是，与非线性项对应的重新线性化密钥不能由一方生成。<br></p><p>  我们提出了一种基于RLWE的密码系统来实现这一功能。它看起来类似于GSW的环形变体，但我们的方案支持不同密钥下密文之间的一些操作。设<span class="math inline">\(g∈\mathbb{Z}_{d}\)</span>是积分向量，成为Gadget向量。该方案使用公共参考字符串模型CRS，各方共享一个随机多项式向量<span class="math inline">\(a∈R_{q}^{d}\)</span>。每一方自己生成一个特殊的对<span class="math inline">\(s_{i}\)</span>的加密，它是一个满足<span class="math inline">\(d_{i,0}+s_{i}·d_{i,1}≈r_{i}·g\ (mod\ q)\)</span>和<span class="math inline">\(d_{i,2}≈r_{i}·a+s_{i}·g\ (mod\ q)\)</span>的矩阵，其中<span class="math inline">\(r_{i}\)</span>是从密钥分布中采样的一个小多项式。它作为第i方的评估密钥被公布。<br></p><p>  我们提出了两种具有不同优点的再线性化方法。对于每一对<span class="math inline">\(1≤i,j≤k\)</span>，第一种方法将第i个评估密钥<span class="math inline">\(D_{i}\)</span>与第j个公钥<span class="math inline">\(b_{j}≈-s_{j}·a\ (mod\ q)\)</span>组合以生成<span class="math inline">\(K_{i,j}∈R_{q}^{d×3}，K_{i,j}·(1,s_{i},s_{j})≈s_{i}s_{j}·g\ (mod\ q)\)</span>。也就是说，<span class="math inline">\(K_{i,j}\)</span>可以用于将扩展密文的一项<span class="math inline">\(c_{i,j}\)</span>重新线性化为一个三元组<span class="math inline">\((c_{0}&#39;,c_{1}&#39;,c_{2}&#39;)，c_{0}&#39;+c_{i}&#39;s_{i}&#39;+c_{j}&#39;s_{j}&#39;≈c_{i,j}s_{i}s_{j}\ (mod\ q)\)</span>。这种方法可以视为先前GSW密文扩展的变体。特别的，<span class="math inline">\(K_{i,j}\)</span>的每一行由<span class="math inline">\(R_{q}\)</span>中的三个多项式组成，因此一个共享的重线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>的比特大小是<span class="math inline">\(O(dk^{2}·nlog\ q)\)</span>，密钥生成的复杂度是<span class="math inline">\(O(d^{2}k^{2})\)</span>多项式运算模q。重新线性化算法从<span class="math inline">\(s_{i,j}\)</span>到<span class="math inline">\((1,s_{i},s_{j})\)</span>重复<span class="math inline">\(O(k^{2})\)</span>密钥切换操作，因此它的复杂度是<span class="math inline">\(R_{q}\)</span>中的<span class="math inline">\(O(dk)^{2}\)</span>。我们注意到，<span class="math inline">\(K_{i,j}\)</span>可用于与第i方第j方相关的任何计算。<br></p><p>  我们的第二种方法通过递归方式将第j方的公钥<span class="math inline">\(b_{j}\)</span>与第i方的评估密钥<span class="math inline">\(D_{i}\)</span>相乘，直接将扩展密文的每一项线性化。第一个解决方案应该生成并存储一个共享的重新线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>，这使得它的空间和时间复杂度在k上二次增长。但是，第二种算法允许我们只保留在k上线性的个人评估密钥。此外，它还显著降低了重新线性化带来的附加噪声的方差，因此我们可以在保持相同功能的同时使用更小的参数。最后，我们将模数提升技术应用于第二种方法，以进一步降低噪声增长。<br></p><p>  作为一个正交问题，压缩MKHE方案的自举性在文献中还没有研究过。我们将现有的HE方案的自举方法推广到多密钥。推广的主要问题是，自举性的pipeline包含一些高级功能，如slot置换。我们通过将多密钥切换技术应用于Galois自同构，解决了这个问题并提供了所有必要的操作。<br></p><p>  最后，我们将最先进的优化技术应用于我们的MKHE方案，以实现对HE方案性能的改进。例如，我们实现了MKHE方案的剩余数系统（RNS）变体，并使用RNS友好的分解方法进行重新线性化，从而避免了昂贵的高精度算法。</p><h2 id="相关工作">1.3 相关工作</h2><p>  lópez-Alt 等人首先提出了一种基于NTRU的MKHE方案。之后Clear和McGoldrick提出了GSW的多密钥变体以及密文扩展技术来设计MKHE 方案，Mukherjee和Wichs对其进行了简化。Peikert和Shiehian在同一个多密钥GSW方案的基础上开发了两个multi-hop MKHE方案。但是，这些方案只能对大量的GSW扩展密文中的一个比特进行加密。<br></p><p>  Brakerski和Perlman提出了一种具有短密文（基于LWE）的MKHE方案，但其渐进/具体效率还没有得到明确的证明。Chen, Chillotti和Song在MKHE原语的首次实现中应用了TFHE框架，提出了一种改进方案。然而该方案不支持压缩技术，因此导致类似于TFHE的较大的膨胀率。<br></p><p>  最相关的研究是由Chen等人和li等人进行的。他们通过基于多密钥GSW方案生成重新线性化密钥来设计BGV的多密钥变体。但是，它由<span class="math inline">\(O(k^{2})\)</span>个密钥交换（从<span class="math inline">\(s_{i}s_{j}\)</span>切换到含有O(k)个分量的普通密钥）组成。此外，他们没有提供任何实施结果或关于具体性能的分析。我们的工作是这些研究的延伸，因为我们的重新线性化方法和其他优化技术也可以应用于BGV。我们还强调，通过观察评估键的稀疏性，可以提高以前MKHE方案的性能，但文章中并没有指明这一点。在表1中，我们提供了最近MKHE方案的表现；在我们的工作中用到了第二项进行比较。 <img src="http://tva1.sinaimg.cn/large/007aD2tWgy1gyb58pbp6rj30mj0a0jww.jpg" /></p><h1 id="背景">2. 背景</h1><h2 id="符号">2.1 符号</h2><p>  除非另有说明，否则所有对数均以2为底。用粗体表示向量，用大写粗体表示矩阵，用<span class="math inline">\(&lt;u,v&gt;\)</span>表示两个向量u、v的点积。对于实数r，<span class="math inline">\(⌊r⌉\)</span>表示距离r最近的整数，在中间时向上取整。我们用x←D来表示根据分布D的采样x。对于有限集S，U(S)表示S上的均匀分布。在本文中，我们令λ表示安全参数，所有已知的针对作用域下加密方案的有效攻击都应该采取<span class="math inline">\(Ω(2^{λ})\)</span>位操作。</p><h2 id="多密钥同态加密">2.2 多密钥同态加密</h2><p>  多密钥同态加密是一种密码系统，它允许我们评估可能使用不同密钥加密的密文上的算数电路。<br></p><p>  设M为具有算数结构的消息空间。一个MKHE方案由五个算法组成（Setup，KeyGen，Enc，Dec，Eval）。我们假设每个参与方都有一个对其公钥和私钥的引用（索引）。多密钥密文隐式包含一组有序的关联规则<span class="math inline">\(T=\{id_{1},...,id_{k}\}\)</span>，例如，一个新密文<span class="math inline">\(ct ← MKHE.Enc(μ; pk_{id})\)</span>对应一个元素集<span class="math inline">\(T = {id}\)</span>，随着各方密文计算的进行，参考集的大小会越来越大。</p><ul><li>Setup：<span class="math inline">\(pp ← MKHE.Setup(1^{λ}\)</span>).将安全参数λ作为输入，并返回公共参数pp。我们假设所有其他算法都隐式地将pp作为输入。</li><li>KeyGeneration：<span class="math inline">\((sk,pk) ← MKHE.KeyGen(pp)\)</span>. 输出一对公钥和私钥。</li><li>Encryption: <span class="math inline">\(ct ← MKHE.Enc(μ; pk_{id}\)</span>). 对明文μ∈M进行加密，输出密文<span class="math inline">\(ct ∈\{0,1\}*\)</span>。</li><li>Decryption：<span class="math inline">\(μ ← MKHE.Dec(\overline{ct};\{sk_{id}\}_{id∈T}\)</span>). 给定具有相应私钥序列的密文，输出明文。</li><li>Homomorphic evaluation：<span class="math inline">\(\overline{ct} ← MKHE.Eval(C,(\overline{ct_{1}},...,\overline{ct_{\iota}}),\{pk_{id}\}_{id∈T}\)</span>).给定电路C、多密钥密文元组以及相应的公钥集，输出密文。其引用集是输入密文的引用集的并集。</li></ul><p>  语义安全：对于任何两条消息<span class="math inline">\(μ_{0},μ_{1}∈M\)</span>，在i=0,1下，其分布<span class="math inline">\(\{MKHE.Enc(μ;pk_{id})\}\)</span>应该是不可区分的，其中<span class="math inline">\(pp←MKHE.Setup(1^(λ)),(sk,pk)←MKHE.KeyGen(pp)\)</span>。<br></p><p>  正确性与紧凑性：对于固定多项式<span class="math inline">\(poly(λ,k)\)</span>，如果与k方相关的密文大小是由poly(.,.)限定，则MKHE方案是紧凑的。<br></p><p>  对于<span class="math inline">\(1\le{j}\le{\iota}\)</span>，设<span class="math inline">\(\overline{ct}_{j}\)</span>为密文（引用集为<span class="math inline">\(T_{j}\)</span>），<span class="math inline">\(MKHE.Dec(\overline{ct}_{j},\{sk_{id}\}_{id\in{T}}),T=T_{1}\cup...\cup{T_{\iota}}\)</span>。则<span class="math inline">\(MKHE.Dec(\overline{ct}_{j},\{sk_{id}\}_{id\in{T}})=C(μ_{1},...,μ_{\iota})\)</span>  (1)<br></p><p>  (1)的等式可用近似等式替代，近似等式类似于支持近似算法的CKKS方案。</p><h2 id="环上的容错学习问题">2.3 环上的容错学习问题</h2><p>  在本文中，我们假设n是一个二次整数，<span class="math inline">\(R=\mathbb{Z}[x]/(X^{n}+1)\)</span>。记模整数q的R的剩余环为<span class="math inline">\(R_{q}=R/q·R)\)</span>。参数为(n,q,χ,ψ)的环上的容错学习问题：假设给定任意形式为<span class="math inline">\((a_{i},b_{i}=s·a_{i}+e_{i})∈R_{q}^{2}\)</span>的样本，其中<span class="math inline">\(a_{i}\)</span>在<span class="math inline">\(R_{q}\)</span>中是均匀随机的，从<span class="math inline">\(R_{q}\)</span>上的密钥分布χ中选择s，从R上的误差分布ψ中选择<span class="math inline">\(e_{i}\)</span>，<span class="math inline">\(b_{i}\)</span>在计算上与<span class="math inline">\(R_{q}\)</span>上的均匀随机元素是无法区分的。</p><h2 id="gadget分解">2.4 Gadget分解</h2><p>  设<span class="math inline">\(g=(g_{i}∈\mathbb{Z}^{d})\)</span>是一个Gadget向量，q为整数。Gadget分解用<span class="math inline">\(g^{-1}\)</span>表示，是一个从<span class="math inline">\(R_{q}\)</span>到<span class="math inline">\(R^{d}\)</span>的函数，它将元素<span class="math inline">\(a∈R_{q}\)</span>转换为小多项式<span class="math inline">\(u=(u_{0},...,u_{d-1})∈R^{d}\)</span>，满足<span class="math inline">\(a=\sum_{i=1}^{d-1}{g_{i}·u_{i}}(mod\ q)\)</span>。<br></p><p>  Gadget分解技术广泛应用于HE方案的构造中。非线性电路的同态评估基于密钥交换技术，大多数HE方案利用各种Gadget分解方法来控制噪声增长。相关文献中提出了各种分解方法，如位分解、基分解和基于RNS的分解。我们的实现利用了RNS-friendly分解来提高效率。</p><h1 id="重新线性化多密钥密文">3. 重新线性化多密钥密文</h1><p>  本节给出了对我们MKHE方案的高级描述，并解释了如何执行作为同态算数核心运算的重新线性化过程。</p><h2 id="具有压缩密文的he概述">3.1 具有压缩密文的HE概述</h2><p>  近年来，HE方案的表现取得了显著进步。例如，密文压缩技术允许我们在一个密文中加密多个数据，并以SIMD方式执行并行同态操作。目前，就每个明文时隙的摊销大小和时间而言，BGV、BFV和CKKS等批处理HE方案是性能最好的方案。他们采用一些类似DFT的算法将明文值向量转换为分圆环的元素。<br></p><p>  令<span class="math inline">\(sk=(1,s)\)</span>表示私钥<span class="math inline">\(s∈R\)</span>。基于RLWE的规范密文形式为<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，内积<span class="math inline">\(μ=&lt;ct,sk&gt;(mod\ q)\)</span>（相位）是明文m的随机编码。例如，BFV密文的相位以<span class="math inline">\(μ=(q/t)·m+e\)</span>的形式来表示模t明文，而CKKS的相位<span class="math inline">\(μ=m+e\)</span>是明文的近似值。<br></p><p>  对于同态计算，我们基本在给定密文的相位之间进行算术运算。特别的，RLWE密文的同态乘法包括两个步骤：张量积和重新线性化。对于输入密文<span class="math inline">\(ct_{1}\)</span>和<span class="math inline">\(ct_{2}\)</span>，我们首先计算它们的张量积并返回满足<span class="math inline">\(&lt;ct,sk\otimes{sk}&gt;=&lt;ct_{1},sk&gt;·&lt;ct_{2},sk&gt;\)</span>的扩展密文<span class="math inline">\(ct=ct_{1}\otimes{ct_{2}}\)</span>。由于<span class="math inline">\(sk\otimes{sk}\)</span>包含非线性项<span class="math inline">\(s^{2}\)</span>，它需要执行重新线性化过程，将扩展密文转换为加密相同消息的规范密文。粗略地说，我们发布了一个重新线性化密钥，它是在sk下对<span class="math inline">\(s^{2}\)</span>进行加密的某种密文，并为此转换执行了密钥交换算法。<br></p><p>  在多密钥情况下，与k个不同方相关的密文形式为<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})∈R_{q}^{k+1}\)</span>，它可以由级联密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>解密，其相位由<span class="math inline">\(μ=&lt;\overline{ct},\overline{sk}&gt;=c_{0}+\sum_{i=1}^{k}{c_{i}·s_{i}}\)</span>计算。如果我们遵循与单密钥设计中相同的同态操作流程，则张量积步骤将返回对应于<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的扩展密文。因此，我们需要生成一个重新线性化密钥，该密钥由对<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的项<span class="math inline">\(s_{i}s_{j}\)</span>加密的多个密文组成。与经典的HE方案不同，它需要一些额外的计算，因为<span class="math inline">\(s_{i}s_{j}\)</span>依赖于由不同方独立生成的两个密钥。接下来，我们将解释如何有效地为多密钥同态乘法生成重新线性化密钥。</p><h2 id="基本方案">3.2 基本方案</h2><p>  在本节中，我们将介绍一个基于环的方案，该方案用于生成一些重新线性化所需的公共参数。<br></p><ul><li><span class="math inline">\(Setup(1^{(\lambda)})\)</span>：对于给定的安全参数λ，设置RLWE维数n，密文模数q，密钥分布χ和在R上的错误分布ψ。生成一个随机向量<span class="math inline">\(\mathrm{a}←U(R_{q}^{d})\)</span>，返回公共参数<span class="math inline">\(pp=(n,q,χ,ψ,\mathrm{a})\)</span>.</li><li><span class="math inline">\(KeyGen(pp)\)</span>：采样私钥<span class="math inline">\(s←χ\)</span>。采样误差向量<span class="math inline">\(e←ψ^{d}\)</span>，并设置公钥为<span class="math inline">\(b=-s·\mathrm{a}+e(mod\ q) ∈ R_{q}^{d}\)</span></li><li><span class="math inline">\(UniEnc(µ;s)\)</span>：对于输入明文µ∈R，生成密文<span class="math inline">\(D=[d_{0}|d_{1}|d_{2}]∈R_{q}^{d×3}\)</span>如下：<br>   (1)采样<span class="math inline">\(r←χ\)</span><br>   (2)采样<span class="math inline">\(d_{1}←U(R_{q}^{d}),e_{1}←ψ^{d}\)</span>，设置<span class="math inline">\(d_{0}=-s·d_{1}+e_{1}+r·g\ (mod\ q)\)</span><br></li></ul><p>  (3)采样<span class="math inline">\(e_{2}←ψ^{d}\)</span>并设置<span class="math inline">\(d_{2}=r·a+e_{2}+µ·g\ (mod\ q)\)</span></p><p>  单加密（uni-encryption）算法是一种对称加密算法，可以加密单个环元素。一个单加密密文<span class="math inline">\(D=[d_{0}|d_{1}|d_{2}]←UniEnc(µ;s)\)</span>由<span class="math inline">\(R_{q}^{d}\)</span>中的三个向量组成，因此是<span class="math inline">\(R_{q}^{2d×2}\)</span>中普通RGSW密文的3/4倍。对于一个单加密密文D，前两列<span class="math inline">\([d_{0}|d_{1}]\)</span>可视为密钥s下r的加密，而<span class="math inline">\([d_{2}|−\mathrm{a}]\)</span>形成密钥r下µ的加密。<br></p><p>  安全性。单加密方案在参数(n,q, χ,ψ)的RLWE假设下是IND-CPA安全的。对任意u∈R，如下分布在计算上与<span class="math inline">\(R_{q}^{d}×R_{q}^{d}×R_{q}^{d×3}\)</span>上的均匀分布是不可区分的。<br></p><p><span class="math inline">\(\{(\mathrm{a},b,D):pp=(n,q,χ,ψ)←Setup(1^{(\lambda)}),(s,b)←KeyGen(pp),D←UniEnc(µ;s)\}\)</span></p><h2 id="重新线性化">3.3 重新线性化</h2><p>  我们重新讨论了扩展密文的重新线性化过程，并提出了两种具有不同优点的解决方案。在级联密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>下加密的两个多密钥密文<span class="math inline">\(\overline{ct}_{i}∈R_{q}^{k+1}\)</span>的张量积<span class="math inline">\(\overline{ct}=\overline{ct}_{1}\otimes\overline{ct}_{2}\)</span>可以被视为对应于张量平方密钥<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的密文。注意，<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>包含一些与两个不同方相关的非线性项<span class="math inline">\(s_{i}s_{j}\)</span>。因此，计算服务器应该能，计算服务器应该能够通过非线性项<span class="math inline">\(s_{i}s_{j}\)</span>的线性化将扩展密文<span class="math inline">\(\overline{ct}_∈R_{q}^{(k+1)×(k+1)}\)</span>转换为规范密文。<br></p><p>  我们的重新线性化方法需要以下各方生成的相同公共材料（评估密钥）：</p><ul><li><span class="math inline">\(EvkGen(s)\)</span>：给定密钥s∈R，返回D ← UniEnc(s;s).</li></ul><p>  确切地说，每一方i都通过运行算法<span class="math inline">\((s_{i},b_{i})←KeyGen(pp)\)</span>和<span class="math inline">\(D_{i}←EvkGen(s_{i})\)</span>来生成自己的私钥、公钥和评估密钥，然后公布<span class="math inline">\((b_{i}, D_{i})\)</span>。在本节的其余部分中，我们将介绍两种重新线性化算法，并解释它们的优缺点。<br></p><p>  我们做了一个额外的循环安全性假设，因为评估密钥是由自身加密的密钥s的单加密。但是需要强调的是，我们的假设并不比要求密文自举或重新线性化的方案中的相同假设强。</p><h3 id="第一种方法">3.3.1 第一种方法</h3><p>  该解决方案包括一个预处理步骤，该步骤生成对应于所涉及的一组参与方的共享重新线性化密钥。共享重新线性化密钥由所有<span class="math inline">\(s_{i}·s_{j},1\leqslant{i,j}\leqslant{k}\)</span>加密组成。然后我们可以通过应用标准密钥交换技术来重新线性化扩展密文。<br></p><p>  此方法类似于先前工作中提出的方法，该方法还生成共享的评估密钥。但是，我们的共享重新线性化密钥的每个元素都是根据最多两方的公共信息计算的，因此由三个向量组成，而先前基于多密钥GSW方案的方法具有O(k)维数的项。</p><ul><li><p><span class="math inline">\(Convert(D_{i},b_{j})\)</span>：将（可能不同的）参与方i和j生成的一对单加密密文<span class="math inline">\(D_{i}=[d_{i,0}|d_{i,1}|d_{i,2}]∈R_{q}^{d×3}\)</span>和公钥<span class="math inline">\(b_{j}∈R_{q}^{d}\)</span>作为输入。设<span class="math inline">\(k_{i,j,0}\)</span>和<span class="math inline">\(k_{i,j,1}\)</span>是<span class="math inline">\(R_{q}^{d}\)</span>中的向量，使得<span class="math inline">\(k_{i,j,0}[\iota]=&lt;g^{-1}(b_{j}[\iota]),d_{i,0}&gt;,k_{i,j,1}[\iota]=&lt;g^{-1}(b_{j}[\iota]),d_{i,1}&gt;,1\leqslant{\iota}\leqslant{d}\)</span>，即，<span class="math inline">\([k_{i,j,0}|k_{i,j,1}]=M_{j}·[d_{i,0}|d_{i,1}]\)</span>，其中<span class="math inline">\(M_{j}∈R^{d×d}\)</span>是第<span class="math inline">\(\iota\)</span>行为<span class="math inline">\(g^{-1}(b_{j}[\iota])∈R^{d}\)</span>的矩阵。设<span class="math inline">\(k_{i,j,2}=d_{i,2}\)</span>，返回密文<span class="math inline">\(K_{i,j}=[k_{i,j,0}|k_{i,j,1}|k_{i,j,2}]∈R_{q}^{d×3}\)</span>。 <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeecubj7uj30o105stai.jpg" /></p></li><li><p><span class="math inline">\(Relin(\overline{ct};\{D_{i},b_{i}\}_{1\leqslant{i}\leqslant{k}})\)</span>：给定扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>和k对评估/公共密钥<span class="math inline">\(\{(D_{i},b_{i})\}_{1\leqslant{i}\leqslant{k}}\)</span>，生成密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span>如下：<br></p></li></ul><p> 1. 对<span class="math inline">\(1\leqslant{i,j}\leqslant{k}\)</span>，计算<span class="math inline">\(K_{i,j}←Convert(D_{i},b_{j})\)</span>，设置重新线性化密钥为<span class="math inline">\(\overline{rlk}=\{K_{i,j}\}_{1\leqslant{i,j}\leqslant{k}}\)</span><br></p><p> 2. 运行算法Algorithm1来重新线性化<span class="math inline">\(\overline{ct}\)</span> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeeo7fhr6j30o10cmaf1.jpg" /></p><p>  我们注意到，第一步(<span class="math inline">\(\overline{rlk}\)</span>的生成)可以在公共信息<span class="math inline">\(\{D_{i},b_{i}\}_{1\leqslant{i}\leqslant{k}}\)</span>上预先计算，而无需将密文作为输入。<br></p><p>  正确性。我们首先声明，如果<span class="math inline">\(D_{i}\)</span>是由第i方加密的<span class="math inline">\(µ_{i}∈R\)</span>的单加密，<span class="math inline">\(b_{j}\)</span>是第j方的公钥，那么Convert算法的输出<span class="math inline">\(K_{i,j}←Convert(D_{i},b_{j})\)</span>是关于<span class="math inline">\((1,s_{i},s_{j})\)</span>的<span class="math inline">\(µ_{i}s_{j}\)</span>的加密，即<span class="math inline">\(k_{i,j,0}+s_{i}·k_{i,j,1}+s_{j}·k_{i,j,2}≈µ_{i}s_{j}·\mathrm{g}\ (mod\ q)\)</span>，由以下公式推导而来：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegp42f5ej30o102o76a.jpg" /></p><p>  请注意，<span class="math inline">\(M_{j},s_{j}\)</span>和<span class="math inline">\(r_{i}\)</span>都应该较小，以保持近似相等。我们在附录C中估算了噪声的大小。<br></p><p>  现在我们展示算法的正确性。因为第i方的评估密钥<span class="math inline">\(D_{i}\)</span>是<span class="math inline">\(µ_{i}=s_{i}\)</span>的单加密，我们得到<span class="math inline">\(K_{i,j}·(1,s_{i},s_{j})≈s_{i}s{j}·\mathrm{g}\ (mod\ q)\)</span>。从<span class="math inline">\(\overline{ct}&#39;\)</span>的定义，我们得到：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegsnbyswj30o109an09.jpg" /></p><h3 id="第二种方法">3.3.2 第二种方法</h3><p>  我们的第二个解决方案不会生成共享重新线性化密钥。相反，它通过递归的方式将扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>的每一项<span class="math inline">\(c_{i,j}\)</span>乘以<span class="math inline">\(b_{j}\)</span>和<span class="math inline">\(D_{i}\)</span>来直接线性化。<br></p><ul><li><span class="math inline">\(Relin(\overline{ct};\{(D_{i},b_{i})\}_{1\leqslant{i}\leqslant{k}})\)</span>：对于给定的扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>和k对评估/公共密钥，按照Algorithm 2中的描述生成密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span></li></ul><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegyd50iij30o10ex0zj.jpg" /></p><p>  在下一节中，我们将分析和比较两种重新线性化方法。简言之，第二种方法在存储和噪声增长方面具有优势，而如果重复使用共享评估密钥来重新线性化对应于同一组参与方的多个密文，则第一种方法可能更快。我们首先来证明第二种方法的正确性。<br></p><p>  正确性。在Algorithm 2的第二个for循环的每次迭代中，我们计算<span class="math inline">\(c_{i,j}&#39;=&lt;\mathrm{g}^{-1}(c_{i,j}),b_{j}&gt;\)</span>，然后分别将<span class="math inline">\(\mathrm{g}^{-1}(c_{i,j}&#39;)·[d_{i,0}|d_{i,1}]\)</span>和<span class="math inline">\(&lt;\mathrm{g}^{-1}(c_{i,j}),d_{i,2}&gt;\)</span>添加到<span class="math inline">\((c_{0}&#39;,c_{1}&#39;)\)</span>和<span class="math inline">\(c_{j}&#39;\)</span>。我们注意到：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh6mj92wj30fs01i0ta.jpg" /> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh6srx3oj30is02kmy8.jpg" /></p><p>  根据<span class="math inline">\(\overline{ct}&#39;\)</span>的定义，我们可以得到：<br> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh7g9odlj30o10d3ady.jpg" /></p><h3 id="重新线性化算法的性能">3.3.3 重新线性化算法的性能</h3><p>  假设多密钥计算涉及k个不同的参与方。对于重新线性化扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}∈R_{q}^{(k+1)^{2}}\)</span>，我们的两种重新线性化方法都在每一个<span class="math inline">\(c_{i,j}\)</span>上重复一些计算，以将其相应的<span class="math inline">\(s_{i}·s_{j}\)</span>转换为<span class="math inline">\((1,s_{i},s_{j})\)</span>。因此，我们将关注每个解决方案的单个步骤(i,j)，以比较它们的性能。<br></p><p>  在第一种方法中，计算方生成共享重新线性化密钥<span class="math inline">\(K_{i,j}\)</span>，并使用它来线性化输入的扩展密文。<span class="math inline">\(K_{i,j}\)</span>的生成包括d×d和d×2矩阵之间的乘法，因此复杂性为<span class="math inline">\(2d^{2}\)</span>多项式乘法。而第二种方法没有任何预处理，Algorithm 2的一次迭代需要4d多项式乘法。因此，当使用预先计算的共享重新线性化密钥来对同一组（或其子集）参与方执行同态运算时，第一种方法的速度可以达到第二种的4/3倍。然而，与第二种方法的线性存储相比，第一种方法所需的存储空间在k上二次增长。<br></p><p>  第二种方法在噪声管理方面也有优势，我们将在下文与模数提升技术一起讨论。</p><h3 id="特殊模数技术">3.3.4 特殊模数技术</h3><p>  噪音增长是决定参数大小和密码系统整体性能的主要因素。总的来说，我们可以使用一个较大的分解度d来减少Gadget分解后向量<span class="math inline">\(\mathrm{g}^{-1}(·)\)</span>的大小以及密钥切换误差，但是这种方法会导致性能下降。此外，随着d的增加，噪声增长和计算复杂度之间的这种权衡的好处会越来越小。因此，当存在一个小噪音时，这一方法并不是最佳选择。特殊模数（又称模数提升）技术是一种很有吸引力的解决方案，可以用更小的开销来解决这一噪声问题。粗略地说，它将密文模数从q提高到pq，整数p称为特殊模数，然后计算<span class="math inline">\(R_{pq}\)</span>上的密钥切换过程，将模数还原回q。方法的主要优点是，由于模数的减少，密钥切换误差减少了约p个因子。我们将该技术应用到我们的重新线性化和加密算法中。特别地，重新线性化的一个特殊的模数变体需要两个连续的模数切换操作。（细节参见附录A）<br></p><p>  我们回顾一下，对于一个扩展密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span>，使得对某个（为提高效率而尽量减少）的误差<span class="math inline">\(e_{lin}\)</span>，有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;=&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;+e_{lin}\)</span>。请读者参考附录C，其中提供了一个基于多项式系数方差的噪声分析，我们在本节中进行了一个简单总结。<br></p><p>  设u是<span class="math inline">\(R_{q}\)</span>上的一个一致随机变量。我们考虑它的Gadget分解<span class="math inline">\(\mathrm{g}^{-1}(u)\)</span>，并用<span class="math inline">\(V_{\mathrm{g}}\)</span>表示其系数的平均方差。我们分别从第一和第二种方法中估计出重新线性化误差的方差：<span class="math inline">\(V_{1}=k^{2}n^{2}\sigma^{2}·d^{2}V_{g}^{2},V_{2}≈k^{2}n^{2}\sigma^{2}·dV_{g}\)</span>。此外，第二种方法的特殊模数变体使得噪声的方差更小：<span class="math inline">\(V_{2}&#39;=p^{-2}·V_{2}+\frac{1}{24}{(k^{2}+k)n}\)</span>。<br></p><p>  与第一种方案相比，我们的第二种解决方案在实践中具有显著的优势，因为我们可以在得到相同噪音增长水平的同时，使用一个具有较小d的有效分解方法。此外，其模数增长的变体得到一个更小的误差方差，几乎不受分解的大小的影响，因为当我们引入一个特殊的模数p（它可以抵消<span class="math inline">\(V_{2}\)</span>）时，<span class="math inline">\(V_{2}&#39;\)</span>由第二项（舍入误差）所控制。</p><h1 id="两个压缩密文的mkhe方案">4. 两个压缩密文的MKHE方案</h1><p>  在本节中，我们提出了BFV和CKKS方案的多密钥变体。它们共享以下设置和密钥生成阶段，但有不同的消息编码和同态操作算法。<br></p><ul><li><span class="math inline">\(MKHE.Setup(1^{\lambda})\)</span>：运行<span class="math inline">\(Setup(1^{\lambda})\)</span>并返回参数pp<br></li><li><span class="math inline">\(MKHE.KeyGen(pp)\)</span>：每一方i根据<span class="math inline">\((s_{i},b_{i})←KeyGen(pp)\)</span>和<span class="math inline">\(D_{i}←EvkGen(s_{i})\)</span>分别生成私钥、公钥和评估密钥<br></li></ul><p>  我们MKHE方案的加密、解密和同态算法将在下一小节中介绍。在密文之间进行同态运算时，有一个共同的预处理。对于给定密文<span class="math inline">\(\overline{ct}_{i}∈R_{q}^{k_{i}+1}\)</span>，我们用<span class="math inline">\(k\ge{max\{k_{1},k_{2}\}}\)</span>表示<span class="math inline">\(\overline{ct}_{1}\)</span>和<span class="math inline">\(\overline{ct}_{2}\)</span>中参与方的数目。我们重新排列<span class="math inline">\(\overline{ct}_{i}\)</span>的元素，并在空条目中填充零，以生成某些共享相同密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>的密文<span class="math inline">\(\overline{ct}_{i}^{*}\)</span>。准确的说，对应于元组<span class="math inline">\((id_{1},...,id_{k})∈{\{1,2,...,k\}}^{k_{i}}\)</span>的密文<span class="math inline">\(\overline{ct}_{i}=(c_{0},c_{1},...,c_{k_{i}})\)</span>被转换为密文<span class="math inline">\(\overline{ct}_{i}^{*}=(c_{0}^{*},c_{1}^{*},...,c_{k}^{*})∈R_{q}^{k+1}\)</span>，其中<span class="math inline">\(c_{0}^{*}=c_{0},c_{i}^{*}=\left\{\begin{aligned}  c_{j}\ \ \ if\ i=id_{j}\ for\ some\ 1\le{j}\le{k}\\  0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise \end{aligned}\right.\)</span>。我们注意到，<span class="math inline">\(&lt;\overline{ct}_{i},(1,s_{id_{1}},...,s_{id_{k_{i}}})&gt;=&lt;\overline{ct}^{*},(1,s_{1},...,s_{k})&gt;\)</span>。为简单起见，我们将假设此预处理总是在同态运算之前完成，以便两个输入密文与k个参与方的同一集合相关。<br></p><p><strong>安全性和正确性</strong>：我们记得，在参数<span class="math inline">\((n,q,\chi,\psi)\)</span>的RLWE假设下，BFV和CKKS是IND-CPA安全的。我们的MKHE方案具有完全相同的单密钥加密算法，因此它们的安全性依赖于同一RLWE问题的难度（细节参见附录B）。本节中我们将简单展示我们方案的正确性，噪音分析的严格证明将在附录C中提供。</p><h2 id="多密钥bfv">4.1 多密钥BFV</h2><p>  BFV方案是一种大小不变的HE，它支持在具有有限特征的离散空间上进行精确计算。我们用t来表示明文模数，<span class="math inline">\(\Delta=\lfloor{q/t}\rceil\)</span>表示BFV方案的比例因子。原始明文空间是分圆多项式<span class="math inline">\(R_{t}\)</span>的集合，但是，根据t和n的关系，明文通过<span class="math inline">\(R_{t}\)</span>的环同构被解码为有限域元素的元组。<br></p><ul><li><span class="math inline">\(MK-BFV.Enc(m;b,\mathrm{a})\)</span>：这是标准的BFV加密，以多项式<span class="math inline">\(m∈R_{t}\)</span>为输入。设<span class="math inline">\(a=\mathrm{a}[0],b=b[0]\)</span>。采样<span class="math inline">\(v\gets\chi\)</span>和<span class="math inline">\(e_{0},e_{1}\gets\psi\)</span>。返回密文<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，其中<span class="math inline">\(c_{0}=v·b+\Delta·m+e_{0}\ (mod\ q),c_{1}=v·a+e_{1}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Dec(\overline{ct};s_{1},...,s_{k})\)</span>：设<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>是与k方相关联的密文，<span class="math inline">\(s_{1},...,s_{k}\)</span>是他们的私钥。设置<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>并计算<span class="math inline">\(\lfloor{(t/q)·&lt;\overline{ct},\overline{sk}&gt;}\rceil\ (mod\ t)\)</span>.</li><li><span class="math inline">\(MK-BFV.Add(\overline{ct}_{1},\overline{ct}_{2})\)</span>：给定两个密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;=\overline{ct}_{1}+\overline{ct}_{2}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Mult(\overline{ct}_{1},\overline{ct}_{2};{\{(D_{i},b_{i})\}}_{1\le{i}\le{k}})\)</span>：给定两个密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，计算<span class="math inline">\(\overline{ct}=\lfloor{(t/q)·(\overline{ct}_{1}\otimes\overline{ct}_{2})\rceil\ (mod\ q)\in{R_{q}^{(k+1)^{2}}}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;\gets{Relin(\overline{ct};\{(D_{i},b_{i})\}_{1&lt;i&lt;k})}\)</span>.<br></li></ul><p>  我们方案的正确性是从基本BFV和重新线性化算法的性质得到的。<span class="math inline">\(m\in{R_{t}}\)</span>的一个多密钥BFV加密是一个向量<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>，从而对于私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>有<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\approx\Delta·m\ (mod\ q)\)</span>。因此解密算法能够正确回复m。如果<span class="math inline">\(\overline{ct}_{1}\)</span>和<span class="math inline">\(\overline{ct}_{2}\)</span>是<span class="math inline">\(m_{1}\)</span>和<span class="math inline">\(m_{2}\)</span>关于私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>的加密，则它们的（标度）张量积<span class="math inline">\(\overline{ct}=\lfloor{(t/q)·(\overline{ct}_{1}\otimes\overline{ct}_{2})\rceil\ (mod\ q)}\)</span>满足<span class="math inline">\(&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;\approx\Delta·m_{1}m_{2}\ (mod\ q)\)</span>，与原始BFV方案类似。输出<span class="math inline">\(\overline{ct}&#39;\gets{Relin(\overline{ct};\overline{rlk})}\)</span>有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;\approx&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;\approx\Delta·m_{1}m_{2}\ (mod\ q)\)</span>。</p><h2 id="多密钥ckks">4.2 多密钥CKKS</h2><p>  CKKS方案是一种支持近似不动点算法的分层HE方案。我们假设对于某些整数<span class="math inline">\(p_{i}\)</span>有<span class="math inline">\(\prod_{i=0}^{L}{p_{i}}\)</span>，存在一个密文模链<span class="math inline">\(q_{0}&lt;q_{1}&lt;...&lt;q_{L},q_{\iota}=\prod_{i=0}^{\iota}{p_{i}}\)</span>。原始明文是一个小多项式<span class="math inline">\(m\in{R}\)</span>，但通过DFT，一个多项式最多可以包含(n/2)个复数。除了基本的算数运算之外，它还支持重缩放算法来控制加密信息的大小。对于不同层次间密文的同态运算，它需要将一个高层次的密文转换为与另一个密文相同的层次。<br></p><ul><li><span class="math inline">\(MK-CKKS.Enc(m;b,a)\)</span>：设<span class="math inline">\(m∈R\)</span>是一个输入明文，<span class="math inline">\(a=\mathrm{a}[0],b=b[0]\)</span>。采样<span class="math inline">\(v\gets\chi\)</span>和<span class="math inline">\(e_{0},e_{1}\gets\psi\)</span>。返回密文<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，其中<span class="math inline">\(c_{0}=v·b+m+e_{0}\ (mod\ q),c_{1}=v·a+e_{1}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-CKKS.Dec(\overline{ct};s_{1},...,s_{k})\)</span>：设<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q_{\iota}}^{k+1}}\)</span>是层次为<span class="math inline">\(\iota\)</span>的与k方相关联的密文，<span class="math inline">\(s_{1},...,s_{k}\)</span>是它们的私钥。设置<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>并返回<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q_{\iota})\)</span>.</li><li><span class="math inline">\(MK-CKKS.Add(\overline{ct}_{1},\overline{ct}_{2})\)</span>：给定两个<span class="math inline">\(\iota\)</span>层的密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;=\overline{ct}_{1}+\overline{ct}_{2}\ (mod\ q_{\iota})\)</span>.</li><li><span class="math inline">\(MK-CKKS.Mult(\overline{ct}_{1},\overline{ct}_{2};{\{(D_{i},b_{i})\}}_{1\le{i}\le{k}})\)</span>：给定两个<span class="math inline">\(\iota\)</span>层的密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，计算<span class="math inline">\(c_{i}&#39;=\lfloor{p_{\iota}^{-1}·c_{i}\rceil,0\le{i}\le{k},}\)</span>并返回密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,c_{1}&#39;,...,c_{k}&#39;)\in{R_{q_{\iota-1}}^{k+1}}\)</span>.</li></ul><p>  明文m的一个与私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>相关联的<span class="math inline">\(\iota\)</span>层多密钥加密是一个向量<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q_{\iota}}^{k+1}}\)</span>，满足<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\approx{m}\ (mod\ q_{\iota})\)</span>。对于基础同态操作，我们以<span class="math inline">\(m_{1}\)</span>和<span class="math inline">\(m_{2}\)</span>的<span class="math inline">\(\iota\)</span>层加密作为输入。然后同态加法（乘法）返回一个密文<span class="math inline">\(\overline{ct}&#39;\)</span>，使得<span class="math inline">\([&lt;\overline{ct}&#39;,\overline{sk}&gt;]_{q_{\iota}}\)</span>与<span class="math inline">\(m_{1}+m_{2}\ (m_{1}m_{2})\)</span>近似相等。最后，我们展示了对于m的一个<span class="math inline">\(\iota\)</span>层加密<span class="math inline">\(\overline{ct}\)</span>，重缩放算法从公式<span class="math inline">\([&lt;\overline{ct}&#39;,\overline{sk}&gt;]_{q_{\iota-1}}\approx{p_{\iota}^{-1}}·[&lt;\overline{ct},\overline{sk}&gt;]_{q_{\iota}}\)</span>中返回加密了<span class="math inline">\(p_{\iota}^{-1}·m\)</span>的一个<span class="math inline">\((\iota-1)\)</span>层密文<span class="math inline">\(\overline{ct}&#39;\)</span>。</p><h2 id="分布式解密">4.3 分布式解密</h2><p>  在MKHE原本的经典定义中，解密多密钥密文需要涉及所有参与方的密钥。但是实际上，假设有一方持有多个私钥是不合理的。相反，我们可以考虑多个密钥持有者之间的协议来共同解密一个密文。我们方案的解密算法是已知系数的私钥的（近似）线性组合，且已经提出了一些用于此任务的安全方法。我们介绍了一种基于噪声淹没技术的简单解决方案，但可以使用任意实现相同功能的安全解决方案。<br></p><p>  分布式解密由两个算法组成：部分解密和合并。在第一部分，每一方i接收密文的第i个条目，并带有噪音进行解密。我们设置了比基本方案的标准误差分布<span class="math inline">\(\psi\)</span>方差更大的噪声分布<span class="math inline">\(\phi\)</span>。然后我们将部分解密的结果与<span class="math inline">\(c_{0}\)</span>合并以恢复信息。</p><ul><li><span class="math inline">\(MKHE.PartDec(c_{i},s_{i})\)</span>：给定一个多项式<span class="math inline">\(c_{i}\)</span>和一个秘密<span class="math inline">\(s_{i}\)</span>，采样误差<span class="math inline">\(e_{i}\gets{\phi}\)</span>并返回<span class="math inline">\(\mu_{i}=c_{i}·s_{i}+e_{i}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Merge(c_{0},\{\mu_{i}\}_{1\le{i}\le{k}})\)</span>：计算<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}\ (mod\ q)\)</span>并返回<span class="math inline">\(m=\lfloor{(t/q)·\mu\rceil}\)</span>.</li><li><span class="math inline">\(MK-CKKS.Merge(c_{0},\{\mu_{i}\}_{1\le{i}\le{k}})\)</span>：计算并返回<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}\ (mod\ q)\)</span>.</li></ul><p>  对于一个多密钥密文<span class="math inline">\(\overline{ct}=(c_{0},...,c_{k})\)</span>，多密钥BFV和CKKS方案都在合并阶段计算<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}=&lt;\overline{ct},\overline{sk}&gt;+\sum_{i=1}^{k}{e_{i}}\approx&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q)\)</span>。然后，BFV通过取消比例因子(q/t)来提取明文。</p><h1 id="两个mkhe方案的自举性">5. 两个MKHE方案的自举性</h1><p>  已经存在一些关于基于标准（单密钥）环的HE方案自举过程的研究。以前的工作有不同的基于基础方案的目标和解决方案，但它们基本上遵循Gentry的技术-解密电路的同态评估。特别地，BFV和CKKS方案具有非常相似的自举途径，由以下四步组成：（1）模数提升；（2）多项式系数到时隙；（3）提取和（4）时隙到多项式系数。第二步和最后一步是特定的线性变换，这需要对加密的向量进行旋转操作。<br></p><p>  在本节的其余部分，我们首先解释了如何基于Galois自同构的计算来对多密钥密文进行旋转操作。然后我们重新讨论了BFV和CKKS的自举过程，以推广MKHE方案的现有解决方案。</p><h2 id="galois自同构的同态计算">5.1 Galois自同构的同态计算</h2><p>  分圆域的Galois群<span class="math inline">\(Gal(\mathbb{Q}[X]/(X^{n}+1))\)</span>由<span class="math inline">\(X\mapsto{X^{j}},j\in{\mathbb{Z}_{2n}^{*}}\)</span>的转换组成。我们记得BFV（CKKS）使用<span class="math inline">\(R_{t}(R)\)</span>上的DFT来将多个明文值压缩到单个多项式中。这些自同构为压缩密文提供了特殊的功能，例如明文时隙的旋转。<br></p><p>  自同构的评估可以基于密钥切换技术来完成。设<span class="math inline">\(\tau_{j}:a(X)\mapsto{a(X^{j})}\)</span>是Galois群的一个元素。给定m的一个加密<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>，我们用<span class="math inline">\(\tau_{j}(\overline{ct})=(\tau_{j}(c_{0}),...,\tau_{j}(c_{k}))\)</span>表示通过将<span class="math inline">\(\tau_{j}\)</span>取为<span class="math inline">\(\overline{ct}\)</span>条目而得到的密文。<span class="math inline">\(\tau_{j}(\overline{ct})\)</span>是<span class="math inline">\(\tau_{j}(m)\)</span>对应于私钥<span class="math inline">\(\tau_{j}(\overline{sk})\)</span>的一个有效加密。然后我们执行从<span class="math inline">\(\tau_{j}(\overline{sk})\)</span>到<span class="math inline">\(\overline{sk}\)</span>的密钥切换程序，从而生成一个新密文，在原始私钥<span class="math inline">\(\overline{sk}\)</span>下对同一信息进行加密。 接下来，我们提出了两种Galois元素的评估算法。第一个算法为Galois自同构<span class="math inline">\(\tau_{j}\)</span>生成一个评估密钥。第二个算法收集多方的评估密钥，并使用多密钥切换技术对多密钥密文上的<span class="math inline">\(\tau_{j}\)</span>进行评估。<br></p><ul><li><span class="math inline">\(MKHE.GkGen(j;s)\)</span>：生成一个随机向量<span class="math inline">\(h_{1}\gets{U(R_{q}^{d})}\)</span>和一个误差向量<span class="math inline">\(e&#39;\gets{\psi^{d}}\)</span>。对于一个RLWE秘密<span class="math inline">\(s\in{R}\)</span>，计算<span class="math inline">\(h_{0}=-s·h_{1}+e&#39;+\tau_{j}(s)·g\ (mod\ q)\)</span>。返回Galois评估密钥<span class="math inline">\(gk=[h_{0}|h_{1}]\in{R_{q}^{d×2}}\)</span>.</li><li><span class="math inline">\(MKHE.EvalGal(\overline{ct};\{gk_{i}\}_{1\le{i}\le{k}})\)</span>：设<span class="math inline">\(gk_{i}=[h_{i,0}|h_{i,1}]\)</span>是第i方（1≤i≤k）的Galois评估密钥。给定密文<span class="math inline">\(\overline{ct}=(c_{0},...,c_{k})\in{R_{q}^{k+1}}\)</span>，计算并返回密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,...,c_{k}&#39;)\)</span>，其中<span class="math inline">\(1≤i≤k,c_{0}&#39;=\tau_{j}(c_{0})+\sum_{i=1}^{k}{&lt;g^{-1}(\tau_{j}(c_{j})),h_{i,0}&gt;}\ (mod\ q),c_{i}&#39;=&lt;g^{-1}(\tau_{j}(c_{i})),h_{i,1}&gt;\ (mod\ q)\)</span></li></ul><p>  在CKKS的上下文中，所有<span class="math inline">\(\iota\)</span>层密文的计算都是在模数<span class="math inline">\(q=q_{\iota}\)</span>上进行的。现在我们展示我们算法的正确性。<br></p><p><strong>正确性</strong>：根据定义，输出密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,...,c_{k}&#39;)\gets{MKHE.EvalGal(\overline{ct};\{gk_{i}\}_{1\le{i}\le{k}})}\)</span>，有</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyfnwz8dzbj30le09ttbx.jpg" /> 换句话说，如果输入密文具有相位<span class="math inline">\(\mu(X)=&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q)\)</span>，则输出密文的相位大约等同于<span class="math inline">\(\tau_{j}(\mu(X))=\mu(X^{j})\)</span>。<br></p><p>  除了明文时隙的旋转，我们使用相同的技术评估BFV密文上的Frobenius自同态<span class="math inline">\(X\mapsto{X}^{t}\)</span>。在CKKS中，映射<span class="math inline">\(X\mapsto{X}^{t}\)</span>对应于明文时隙上的复数共轭。<br></p><p>  任意线性转换都可以表示为移位明文向量的线性组合。我们注意到之前线性转换的HE优化技术能够直接应用到我们的MKHE方案中。</p><h2 id="多密钥bfv的自举性">5.2 多密钥BFV的自举性</h2><p>  Chen和Han描述了单密钥BFV方案的一个自举过程。该自举方案以具有任意噪音的密文作为输入，并输出另一个加密了相同明文的具有较小噪音的密文。下面我们介绍一个多密钥变体。<br></p><p>  （1）先前的工作公布了一个私钥本身的加密来提高模数。但是我们证明了这一步可以通过在没有额外信息的情况下乘以一个常数来完成。假设输入密文<span class="math inline">\(\overline{ct}\)</span>加密了一个明文模数为t的信息m，即<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;=\frac{q}{t}m+e\ (mod\ q)\)</span> ，e为某个误差。我们将模数转换为q的一个除数q'， 从而有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;=\frac{q&#39;}{t}m+e&#39;\ (mod\ q)\)</span>，然后将密文与q/q’相乘，得到密文<span class="math inline">\(\overline{ct}&#39;&#39;\)</span>，其相位为<span class="math inline">\(&lt;\overline{ct}&#39;&#39;,\overline{sk}&gt;=\frac{q}{q&#39;}·(\frac{q&#39;}{t}m+e&#39;)\ (mod\ q)\)</span>。这是一个简单（无噪音）的<span class="math inline">\(\mu=\frac{q&#39;}{t}m+e&#39;\)</span>的加密，明文模数为q'，密文模数为q。<br></p><p>  （2）计算一个同态线性转换，该变换产生多个系数<span class="math inline">\(\mu_{i}\in\mathbb{Z}_{t}\)</span>在它们的明文时隙中的密文。我们主要到这一步可以通过加法、标量乘法和多密钥旋转来实现。<br></p><p>  （3）我们同态地评估上一步得到的多密钥密文上的一个多项式，称之为低位数字去除。它去除了噪音e'并保留了明文时隙中m的系数。<br></p><p>  （4）最后一步是另一个线性转换，它将第二步反转并输出m的一个加密。<br></p><p>  因此，对于小于初始噪音e的误差，输出密文具有相位<span class="math inline">\(\frac{q}{t}m+e&#39;&#39;\ (mod\ q)\)</span>。</p><h2 id="多密钥ckks的自举性">5.3 多密钥CKKS的自举性</h2><p>  Cheon等人提出了单密钥CKKS方案的一个自举过程。CKKS的该自举过程目的是刷新一个低层次密文，并返回在较大的密文模数中（几乎）相同信息的一个加密。如下我们描述了它的多密钥版本。<br></p><p>  （1）第一步以一个最低层次的密文<span class="math inline">\(\overline{ct}\)</span>作为输入。设<span class="math inline">\(\mu=&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q_{0})\)</span>。则对于一个小的I∈R，有<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;=q_{0}·I+\mu\)</span>，因此可认为<span class="math inline">\(\overline{ct}\)</span>是最大密文模数<span class="math inline">\(q_{\iota}\)</span>中<span class="math inline">\(t=q_{0}·I+\mu\)</span>的一个加密。<br></p><p>  （2）我们应用了一个同态线性转换来计算一个或两个加密了它们明文时隙中t(X)的系数的密文。这一步需要多密钥旋转和第5.1节中描述的共轭。<br></p><p>  （3）我们评估了一个多项式，其近似于模<span class="math inline">\(q_{0}\)</span>函数的约简。它去除了t的I部分并保留了时隙中μ的系数。<br></p><p>  （4）最后，我们应用了第二步的逆线性转换来将μ的全部系数压缩至一个密文中。<br></p><p>  输出密文<span class="math inline">\(\overline{ct}&#39;\)</span>加密了相比与输入密文<span class="math inline">\(\overline{ct}\)</span>更高层次的相同明文μ，即对某些<span class="math inline">\(0&lt;\iota&lt;L\)</span>，有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;\approx\mu\ (mod\ q_{\iota})\)</span>。<br><br></p><hr /><p>  理论部分暂时就到这里了，后面的应用部分如果用得到的话就再更新吧</p><hr />]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FHE</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GXUCTF easy-伪协议</title>
    <link href="/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>题目直接给出了源码</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9apna123j60r80cl75m02.jpg" /></p><p>一些新东西👇 open_basedir：将php所能打开的文件限制在指定的目录树中 pathinfo()：以数组的形式返回关于文件路径的信息(PATHINFO_DIRNAME - 只返回 dirname; PATHINFO_BASENAME - 只返回 basename; PATHINFO_EXTENSION - 只返回 extension; PATHINFO_FILENAME - 只返回 filename)</p><p>首先对$text进行了匹配，要求是字符串"how_to_bypass?"，可以利用伪协议进行写入 <code>data://text/plain,how_to_bypass?</code></p><p>继续对$file传入参数的后缀进行了检查，如果是php就进行文件包含，这里的绕过只需要在最后加一个.php就可以，很easy~</p><p>剩下的问题就是进行flag文件的读取了，现在我们是不知道flag所在文件的名称和路径的，我试着读了一下当前目录下的flag.php..失败了</p><p>这里看了大佬的博客，学到了新的知识=&gt;利用glob://伪协议进行目录遍历是可以无视open_basedir的</p><p><code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=var_dump(scandir('glob:///*'));</code></p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9brxnl0ej61ne0chjwk02.jpg" /></p><p>其实open_basedir对解这道题并没啥影响，flag文件就在当前目录下，所有直接用scandir('.')就能看到</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9brhg4dxj61l0091ace02.jpg" /></p><p>得到文件名后就可以进行读取了，可以file_get_contents直接读 <code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=echo file_get_contents('fll11llaaaggg.php');</code></p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c3k8uqpj60it032t8u02.jpg" /></p><p>我真的是个憨批..这里读出的flag在源码里，我还以为没读到来回搞了好久，最后去问了出题人..给自己一锤😢</p><p>或者php://filter读取</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c2kzk3ij61hw096ac902.jpg" /></p><p>解码得到flag</p>]]></content>
    
    
    <categories>
      
      <category>CTF刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PHP伪协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF ZJCTF不过如此</title>
    <link href="/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/"/>
    <url>/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/</url>
    
    <content type="html"><![CDATA[<p>直接给出源码</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9c9lvljyj60um0gadhl02.jpg" /></p><p>这里$text可以利用data伪协议写入，根据提示利用filter读取next.php <code>text=data://text/plain,I have a dream&amp;file=php://filter/read=convert.base64-encode/resource=next.php</code></p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv9cciyy2ij61nz0cz41x02.jpg" /></p><p>解码得到next.php源码 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$id</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-variable">$id</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complex</span>(<span class="hljs-params"><span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> preg_replace(<br>        <span class="hljs-string">&#x27;/(&#x27;</span> . <span class="hljs-variable">$re</span> . <span class="hljs-string">&#x27;)/ei&#x27;</span>,<br>        <span class="hljs-string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,<br>        <span class="hljs-variable">$str</span><br>    );<br>&#125;<br><br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$_GET</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$re</span> =&gt; <span class="hljs-variable">$str</span>) &#123;<br>    <span class="hljs-keyword">echo</span> complex(<span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span>). <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlag</span>(<span class="hljs-params"></span>)</span>&#123;<br>@<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里读flag肯定要通过getFlag()函数，没什么思路去看了wp，学到很多新知识</p><p>⭐preg_replace(<span class="math inline">\(pattern,\)</span>replacement,<span class="math inline">\(subject)：在\)</span>subject中匹配<span class="math inline">\(pattern，并将其替换为\)</span>replacement /e修正符，$replacement中的字符串会被当作PHP代码执行 这里就提供给我们执行命令的机会，'strtolower("\\1")'会被当做PHP代码执行</p><p>⭐正则表达式中的'\\1'，其实就是转义后的'\1'，表示取出正则匹配后的第一个子匹配中的第一项 构造payload<code>\S%2b=phpinfo();</code> 这里，+表示匹配1或更多次，+就能匹配一个完整字符串了，URL传参的话+需要进行编码，否则会被认作空格</p><p>得到'strtolower("phpinfo();")' 传参进去后发现代码并没有被执行？</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9cvepa7aj60yn08emya02.jpg" /></p><p>这里又涉及到一个PHP的小性质 ⭐在php中，双引号里面如果包含有变量，php解释器会进行解析；单引号中的变量不会被处理。 目前我们构造的payload最终执行时相当于=&gt;eval('strrolower("phpinfo();")');</p><p>⭐PHP可变变量<span class="math inline">\({\)</span>a} <code>\S%2b=$&#123;phpinfo()&#125;</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PHP伪协议</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF Easy_MD5</title>
    <link href="/2021/10/06/BJDCTF-Easy-MD5/"/>
    <url>/2021/10/06/BJDCTF-Easy-MD5/</url>
    
    <content type="html"><![CDATA[<p>1、打开是一个查询框，用burp发包看一下</p><p><img src="https://tvax4.sinaimg.cn/large/007aD2tWgy1gv5p06qjefj612208843202.jpg" /></p><p>在Response里有一句提示 <code>Hint: select * from 'admin' where password=md5($pass,true)</code></p><p>首先说明一下这个函数 👉md5(<span class="math inline">\(pass, true)：\)</span>pass是待加密字符串，第二个参数设为true，控制输出为原始16字符二进制格式</p><p>所以我们要想办法结合这个函数来进行SQL注入，这里看了大佬的wp，学习到一个类似万能密码的东东<code>ffifdyop</code></p><p>这个字符串经过md5加密后会输出一串<code>'or'6XXXXX</code>，结合查询语句 👉<code>select * from 'admin' where password = ''or'6XXXXX'</code> 后面的'6XXXXX'就等价于一个永真式，至此就绕过了md5函数，注入成功！</p><p>2、下面来到第二个界面，一句大大的Do you like MD5，那必然like..在源码里找到提示信息</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv5pz39fwhj60l305gmxe02.jpg" /></p><p>这里涉及到PHP的'=='弱比较漏洞，如果进行比较的两个值类型不同，PHP会首先将其化为相同类型再进行比较，在处理哈希字符串时，它会把所有以'0e'开头的哈希值都解析为0，所以这里传两个哈希后'0e'开头的字符串即可</p><p>附上一些可用字符串： * QNKCDZO * 240610708 * s878926199a * s155964671a</p><p>也附上一个弱类型比较表给大家</p><p><img src="https://tva2.sinaimg.cn/large/007aD2tWgy1gv5q4kysamj61bg0riqp702.jpg" /></p><p>3、绕过成功，来到第三个界面</p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv5qizplz3j60tl07q3z202.jpg" /></p><p>'==='进行比较时，会判断值+类型，可以选择强碰撞或者md5数组绕过</p><p>PHP的md5()函数是无法处理数组的，在传入的参数为数组时会返回NULL，因此只需要传入两个不同值的数组，得到的结果就是'NULL === NULL'啦</p><p>强碰撞的话，这里给出几个md5值相同的字符串： <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$s1 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br>$s2 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab&quot;</span><br>$s3 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br></code></pre></td></tr></table></figure></p><p>然后就顺利得到flag啦~</p>]]></content>
    
    
    <categories>
      
      <category>CTF刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>MD5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
